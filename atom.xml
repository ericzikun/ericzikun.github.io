<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EricKun</title>
  
  
  <link href="https://ericzikun.github.io/atom.xml" rel="self"/>
  
  <link href="https://ericzikun.github.io/"/>
  <updated>2022-02-14T05:37:14.437Z</updated>
  <id>https://ericzikun.github.io/</id>
  
  <author>
    <name>Eric kun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>deep21-负载均衡算法之一致性哈希环</title>
    <link href="https://ericzikun.github.io/2022/02/14/deep21-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%8E%AF/"/>
    <id>https://ericzikun.github.io/2022/02/14/deep21-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B9%8B%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%8E%AF/</id>
    <published>2022-02-14T05:35:01.000Z</published>
    <updated>2022-02-14T05:37:14.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在有一个场景：一个客户端去访问服务端，只能一直访问一台机器，因为有一些用户数据就存在该服务器上面，如果访问其他服务器的话，这个用户数据就丢了，如何用算法来解决这个问题？</p><h2 id="一致性哈希环算法"><a href="#一致性哈希环算法" class="headerlink" title="一致性哈希环算法"></a>一致性哈希环算法</h2><h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p><img src="https://img-blog.csdnimg.cn/b99eb80ced9b4ff3ae40f950fedb2816.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里的环结构是我们想象的、抽象出来的，最朴素的想法，就是给一个请求，用哈希函数等操作去计算出它对应到的服务器位置，然后分配即可。<br>客户端如何映射到哈希环上的节点呢?</p><p>比如有一个userId =1去请求：<br>计算了哈希值后落在了P1与P4之间，哈希环处理规则就是找到比它大的最近的那个节点，这里的哈希环是一个有序环，依次递增：P1&lt; P2&lt; P3&lt; P4，那么比userId =1大的最近的就是P1，那么就会分配给P1这个服务器。<br> <img src="https://img-blog.csdnimg.cn/24177b3a34d045298d3ecfefc655b791.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在Java中有哪个数据结构是可以满足这个需求的呢？完成自动排序（比如一个数字进到集合中后，该结构能够将新来的和之前的集合元素进行排序，这里采用的是TreeMap）</p><h3 id="变种：穿插虚拟节点分担请求压力"><a href="#变种：穿插虚拟节点分担请求压力" class="headerlink" title="变种：穿插虚拟节点分担请求压力"></a>变种：穿插虚拟节点分担请求压力</h3><p>思考一个问题：如果在某个高峰时间，所有的请求都打到了P1-P4这个区域，那么将会全部击中P1这台服务器，P1承受很大流量，可能导致宕机，同时其他服务器可能比较空闲，这样并不合理，我们可以采用很多的<strong>虚拟节点</strong>，就可以在原有基础之上，中间穿插许多的虚拟节点，类似孙悟空拔了一根汗毛做分身，这样就可以把刚刚那一大堆流量给分散到不同服务器上，使得压力分散的很均匀、散列：<br><img src="https://img-blog.csdnimg.cn/48ea734428b84de484fd399cea12cd30.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="一致性哈希环的数据结构实现：TreeMap"><a href="#一致性哈希环的数据结构实现：TreeMap" class="headerlink" title="一致性哈希环的数据结构实现：TreeMap"></a>一致性哈希环的数据结构实现：TreeMap</h3><p>TreeMap的底层采用的是红黑树，<br><img src="https://img-blog.csdnimg.cn/9be4fe9e273c4f409868bfa8c6657aad.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/ebbad91495c14062bb85fbb14940ca14.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里的红黑树会对插入的数据完成自动排序，在TreeMap的api中有一个tailMap() 函数，输入一个fromKey，输出的是一个SortedMap有序Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SortedMap&lt;Integer,String&gt; subMap = virtualNodes.tailMap(<span class="number">2</span>);</span><br><span class="line">Integer nodeIndex = subMap.firstKey();<span class="comment">//拿到第一个元素</span></span><br></pre></td></tr></table></figure><blockquote><p>能够得到2、3、4、5这几个索引的数据，String是它对应的value。<br>简单来说：能够通过tailMap() 找到2右边的子树（也就是大于等于2的子树），再用firstKey()拿到比他大的第一个元素。</p></blockquote><p>这样就对应到了我们的一致性哈希环，可以拿到它最近的比他大的服务器节点</p><blockquote><p>考虑边界：如果请求计算出比P4还要大，那么就直接返回P1即可（环状）</p></blockquote><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一致性hash 利用treemap实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeMap&lt;Integer,String&gt; virtualNodes = <span class="keyword">new</span> TreeMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRTUAL_NODES = <span class="number">160</span>;<span class="comment">//虚拟节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//预处理 哈希环</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//对每个真实节点添加虚拟节点 根据hash算法进行散列</span></span><br><span class="line">        <span class="keyword">for</span>(String ip: ServerIps.LIST) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> hash = getHash(ip+<span class="string">"VN"</span>+i);</span><br><span class="line">                virtualNodes.put(hash,ip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">(String clientInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = getHash(clientInfo);</span><br><span class="line">        <span class="comment">//得到大于该Hash值的子红黑树</span></span><br><span class="line">        SortedMap&lt;Integer,String&gt; subMap = virtualNodes.tailMap(hash);</span><br><span class="line">        <span class="comment">//获取该子树最小元素</span></span><br><span class="line">        Integer nodeIndex = subMap.firstKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有大于该元素的子树 取整树的第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIndex == <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodeIndex = virtualNodes.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNodes.get(nodeIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//hash算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHash</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            hash = (hash^str.charAt(i))*p;</span><br><span class="line">            hash +=hash &lt;&lt;<span class="number">13</span>;</span><br><span class="line">            hash ^=hash &gt;&gt;<span class="number">7</span>;</span><br><span class="line">            hash +=hash &lt;&lt;<span class="number">3</span>;</span><br><span class="line">            hash ^=hash &gt;&gt;<span class="number">17</span>;</span><br><span class="line">            hash +=hash &lt;&lt;<span class="number">5</span>;</span><br><span class="line">            <span class="comment">//如果算出来的值为负数 取其绝对值</span></span><br><span class="line">            <span class="keyword">if</span>(hash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                hash = Math.abs(hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(getServer(<span class="string">"userId"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一致性hash 利用treemap实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsistentHash</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeMap&lt;Integer,String&gt; virtualNodes = <span class="keyword">new</span> TreeMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIRTUAL_NODES = <span class="number">160</span>;<span class="comment">//虚拟节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//预处理 哈希环</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//对每个真实节点添加虚拟节点 根据hash算法进行散列</span></span><br><span class="line">        <span class="keyword">for</span>(String ip: ServerIps.LIST) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; VIRTUAL_NODES; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> hash = getHash(ip+<span class="string">"VN"</span>+i);</span><br><span class="line">                virtualNodes.put(hash,ip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">(String clientInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = getHash(clientInfo);</span><br><span class="line">        <span class="comment">//得到大于该Hash值的子红黑树</span></span><br><span class="line">        SortedMap&lt;Integer,String&gt; subMap = virtualNodes.tailMap(hash);</span><br><span class="line">        <span class="comment">//获取该子树最小元素</span></span><br><span class="line">        Integer nodeIndex = subMap.firstKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有大于该元素的子树 取整树的第一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (nodeIndex == <span class="keyword">null</span>) &#123;</span><br><span class="line">            nodeIndex = virtualNodes.firstKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> virtualNodes.get(nodeIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//hash算法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHash</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> p = <span class="number">16777619</span>;</span><br><span class="line">        <span class="keyword">int</span> hash = (<span class="keyword">int</span>) <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            hash = (hash^str.charAt(i))*p;</span><br><span class="line">            hash +=hash &lt;&lt;<span class="number">13</span>;</span><br><span class="line">            hash ^=hash &gt;&gt;<span class="number">7</span>;</span><br><span class="line">            hash +=hash &lt;&lt;<span class="number">3</span>;</span><br><span class="line">            hash ^=hash &gt;&gt;<span class="number">17</span>;</span><br><span class="line">            hash +=hash &lt;&lt;<span class="number">5</span>;</span><br><span class="line">            <span class="comment">//如果算出来的值为负数 取其绝对值</span></span><br><span class="line">            <span class="keyword">if</span>(hash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                hash = Math.abs(hash);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(getServer(<span class="string">"userId"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/34609e4c28f9497da8f604293b784b23.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以看出运行结果是相对比较散列的，对于服务器来说压力就比较小了。<br>这里还要测试保证一下：对于同一个userId，每次去请求，都会到达同一个服务器上，这样才合理（每次运行，结果都一致即可）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在有一个场景：一个客户端去访问服务端，只能一直访问一台机器，因为有一些用户数据就存在该服务器上面，如果访问其他服务器的话，这个用户数据就丢</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="高性能" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="负载均衡" scheme="https://ericzikun.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="一致性哈希环" scheme="https://ericzikun.github.io/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>初探负载均衡算法【随机、轮询、加权随机、加权轮询、平滑加权轮询】</title>
    <link href="https://ericzikun.github.io/2022/02/14/deep20-%E5%88%9D%E6%8E%A2%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E3%80%90%E9%9A%8F%E6%9C%BA%E3%80%81%E8%BD%AE%E8%AF%A2%E3%80%81%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E3%80%81%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E3%80%81%E5%B9%B3%E6%BB%91%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E3%80%91/"/>
    <id>https://ericzikun.github.io/2022/02/14/deep20-%E5%88%9D%E6%8E%A2%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E3%80%90%E9%9A%8F%E6%9C%BA%E3%80%81%E8%BD%AE%E8%AF%A2%E3%80%81%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA%E3%80%81%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E3%80%81%E5%B9%B3%E6%BB%91%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E3%80%91/</id>
    <published>2022-02-14T03:51:50.000Z</published>
    <updated>2022-02-14T03:54:20.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>负载平衡（Load balancing）是一种在多个计算机（网络、CPU、磁盘）之间均匀分配资源，以提高资源利用的技术。使用负载均衡可以最大化服务吞吐量，可能最小化响应时间，同时由于使用负载均衡时，会使用多个服务器节点代单点服务，也提高了服务的可用性。</p><p>负载均衡的实现可以软件可以硬件，硬件如大名鼎鼎的 F5 负载均衡设备，软件如 NGINX 中的负载均衡实现，又如 Springcloud Ribbon 组件中的负载均衡实现。本文主要从软件层面来说明其实现算法。</p><p>负载均衡算法主要分为以下6大类：</p><ul><li>随机</li><li>轮询</li><li>加权随机</li><li>加权轮询</li><li>一致性哈希</li><li>平滑加权轮询<br><img src="https://img-blog.csdnimg.cn/15b516435634462abc7ff221ed412ee4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ul><p>代码示例:<br>先把三台服务器放在集合中去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器IP</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerIps</span> </span>&#123;</span><br><span class="line"><span class="comment">//不带权重的三台服务器，用List存储</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; LIST = Arrays.asList(</span><br><span class="line">            <span class="string">"A"</span>,</span><br><span class="line">            <span class="string">"B"</span>,</span><br><span class="line">            <span class="string">"C"</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//带权重，用于加权xx算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Integer&gt; WEIGHT_LIST = <span class="keyword">new</span> LinkedHashMap&lt;String, Integer&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"A"</span>,<span class="number">2</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"B"</span>,<span class="number">3</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"C"</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h2><p>很简单，对三台服务器随机抽取一个进行访问即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomSelect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> rand = random.nextInt(ServerIps.LIST.size());</span><br><span class="line">        <span class="keyword">return</span> ServerIps.LIST.get(rand);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h2><p>也很简单，每次按照顺序依次对服务器进行访问即可，用一个pos指针来记录轮询的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//轮询</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobin</span> </span>&#123;</span><br><span class="line">    <span class="comment">//位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer pos = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String ip = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (pos) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pos &gt;= ServerIps.LIST.size()) &#123;</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ip = ServerIps.LIST.get(pos);</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加权轮询"><a href="#加权轮询" class="headerlink" title="加权轮询"></a>加权轮询</h2><p>在前面ServerIps类的带权重的服务器定义中，每个服务器A、B、C被储存在一个WEIGHT_LIST中，并分别带有权重2、3、5，意思就是服务器C访问的次数可以相对最大…，前面我们的轮询算法中，遍历的集合是A、B、C组成的，现在无非是放入2个A，3个B，5个C即可，如下图所示：<br><img src="https://img-blog.csdnimg.cn/ef0ad6da9f024864adf6a9a8385af5f8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>相当于，10次请求里面有2次是去访问A，3次去访问B，5次去访问C，这样就实现了加权轮询的功能。</p><h2 id="加权随机"><a href="#加权随机" class="headerlink" title="加权随机"></a>加权随机</h2><p>和加权轮询类似，依旧是按照权重把List集合中放满服务器元素，再去随机取即可，无非是取每个服务器的概率不是均等的罢了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缺点 权重大 ips越大 占内存 带权重随机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRandom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成随机数作为List下标</span></span><br><span class="line">        List&lt;String&gt; ips = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String ip: ServerIps.WEIGHT_LIST.keySet()) &#123;</span><br><span class="line">            Integer weight = ServerIps.WEIGHT_LIST.get(ip);</span><br><span class="line">            <span class="comment">//weight多少 在ips里面存多少 例 A 权重为2 在ips里面存两个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight ; i++) &#123;</span><br><span class="line">                ips.add(ip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> randomPos = random.nextInt(ips.size());</span><br><span class="line">        <span class="keyword">return</span> ips.get(randomPos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加权轮询优化"><a href="#加权轮询优化" class="headerlink" title="加权轮询优化"></a>加权轮询优化</h2><p>前面讲了加权轮询的实现很容易，无非是按照权重数量把服务器放进集合中，但是如果有一万个服务器呢，一百万个服务器呢？那我们还这样去装集合然后遍历，其实是很浪费资源的！<br>这里看另一种优化加权轮询的算法：这里总共是10的权重，我们的三台服务器的权重分别是2、3、5，那么我们的10次请求就应该按照比例分配到这三台服务器上，如下图所示：<br><img src="https://img-blog.csdnimg.cn/6b585b3be3af4fc19cb1ee05225064b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里能发现一个规律，如果请求次数小于该权重，就会放到该权重下，比如我第0次、第1次请求都小于2，所以都击中了第一台服务器。<br>简单来说：如果请求的次数小于某权重，就可以放到该权重中来，如果不小于，则继续往后找</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//轮询优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRoundRobin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalWeights = ServerIps.WEIGHT_LIST.values().stream().mapToInt(w -&gt; w).sum();</span><br><span class="line"><span class="comment">//把请求对总权重和取模，就落在0到9之间</span></span><br><span class="line">        Integer pos = num % totalWeights;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String ip: ServerIps.WEIGHT_LIST.keySet()) &#123;</span><br><span class="line">            Integer weight = ServerIps.WEIGHT_LIST.get(ip);</span><br><span class="line">            <span class="keyword">if</span>(pos &lt; weight) &#123;</span><br><span class="line">                <span class="keyword">return</span> ip;<span class="comment">//如果小于该权重，直接返回该服务器（击中）</span></span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos - weight;<span class="comment">//如果不小于，继续往后看哪个权重满足</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">            System.out.println(getServer(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加权轮询、加权随机都是基于这种方式进行实现的，它解决了List放重复数据的问题，但是也有一个缺陷，就是如果某台服务器的权重很大的时候，那么在一段时间内就会一直击中它，服务器压力也很大，我们希望将请求尽可能的打散会好一点，所以就提出了平滑加权轮询算法。</p><h2 id="平滑加权轮询算法"><a href="#平滑加权轮询算法" class="headerlink" title="平滑加权轮询算法"></a>平滑加权轮询算法</h2><p><img src="https://img-blog.csdnimg.cn/23be0834cff54ce58c4698bdf1e30190.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>简单来说就是通过数学公式，在保证每次权重和不变的前提下，使用动态变化权重去更新每一次的权重，是的击中服务器更加分散，但是整体的权重又是满足初始化定义的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRoundRobinV2</span> </span>&#123;</span><br><span class="line"><span class="comment">//初始化动态权重</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Weight&gt; currWeights = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> totalWeights = ServerIps.WEIGHT_LIST.values().stream().mapToInt(w -&gt; w).sum();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//currentWeight 默认值 0</span></span><br><span class="line">        <span class="keyword">if</span>(currWeights.isEmpty()) &#123;</span><br><span class="line">            ServerIps.WEIGHT_LIST.forEach((ip,weight)-&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                currWeights.put(ip,<span class="keyword">new</span> Weight(ip,weight,<span class="number">0</span>));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Weight weight: currWeights.values()) &#123;</span><br><span class="line">            weight.setCurrentWeight(weight.getCurrentWeight() + weight.getWeight());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找最大值</span></span><br><span class="line">        Weight maxCurrentWeight = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(Weight weight: currWeights.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(maxCurrentWeight == <span class="keyword">null</span> || weight.getCurrentWeight() &gt; maxCurrentWeight.getCurrentWeight()) &#123;</span><br><span class="line">                maxCurrentWeight = weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        maxCurrentWeight.setCurrentWeight( maxCurrentWeight.getCurrentWeight() - totalWeights);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxCurrentWeight.getIp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2a8f1e59f04548ed8f19dcfd9b9a155e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>整体来看，C有5个，B有3个，A有2个，和我们初始化定义的权重是一致的，只不过访问更加随机了，这样服务器的压力就变得更小了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;负载平衡（Load balancing）是一种在多个计算机（网络、CPU、磁盘）之间均匀分配资源，以提高资源利用的技术。使用负载均衡可以最大</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="高性能" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
    
    <category term="负载均衡" scheme="https://ericzikun.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="随机" scheme="https://ericzikun.github.io/tags/%E9%9A%8F%E6%9C%BA/"/>
    
    <category term="轮询" scheme="https://ericzikun.github.io/tags/%E8%BD%AE%E8%AF%A2/"/>
    
    <category term="加权随机" scheme="https://ericzikun.github.io/tags/%E5%8A%A0%E6%9D%83%E9%9A%8F%E6%9C%BA/"/>
    
    <category term="加权轮询" scheme="https://ericzikun.github.io/tags/%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2/"/>
    
    <category term="平滑加权轮询" scheme="https://ericzikun.github.io/tags/%E5%B9%B3%E6%BB%91%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存穿透 击穿 雪崩</title>
    <link href="https://ericzikun.github.io/2022/02/14/deep19-Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E5%87%BB%E7%A9%BF-%E9%9B%AA%E5%B4%A9/"/>
    <id>https://ericzikun.github.io/2022/02/14/deep19-Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E5%87%BB%E7%A9%BF-%E9%9B%AA%E5%B4%A9/</id>
    <published>2022-02-14T01:53:08.000Z</published>
    <updated>2022-02-14T01:57:44.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存请求流程"><a href="#缓存请求流程" class="headerlink" title="缓存请求流程"></a>缓存请求流程</h2><p>Redis缓存的雪崩、穿透、击穿属于日常工作中经常会遇到的经典问题，下面来一探究竟，他们的解决方案主要是：布隆过滤器、分布式锁（下次再写）<br><img src="https://img-blog.csdnimg.cn/0378bf2a880f45c8b84d9019b13ca178.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这是一个简单的客户端、服务端请求Redis的流程图，简单来说就是当用户向服务端进行访问时，服务端如果需要向数据库请求数据时，先去缓存中看有没有，有则直接返回，没有才会再去数据库中查询返回，这是一个正常的缓存流程。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><img src="https://img-blog.csdnimg.cn/f989928a5e56421fb100e3ea1a9845ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>比如这个某宝的场景，当双十一来临之日，用户的访问量是非常之大的，所以有很多的数据是放进Redis中缓存起来，对应了Redis的key，并且设置了缓存失效时间是三小时，当双十一期间，购物超过三小时之后，缓存同时在一瞬间全部都失效了，导致所有的请求全部打到了数据库上，造成数据库响应不及时而挂掉，这时候就没办法对外提供该服务了。<br>简单来说：用户访问某宝，Redis中的key大面积失效，导致直接与数据库沟通，这种现象就叫缓存雪崩。<br>解决方案:</p><ul><li>设置失效时间，让他不要在同一时间失效，在设置缓存的时候，随机初始化失效时间，这样就不会让所有的缓存在同一时间全部失效，尽可能分散分布。</li><li>Redis一般都是集群部署，我们将热点key放到不同的节点上去，让这些热点缓存平均的分布在不同的节点上。</li><li>不设置缓存失效时间</li><li>跑定时任务，不断的刷新缓存，就是当缓存即将失效的时候再去让他延长三小时</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p><img src="https://img-blog.csdnimg.cn/6da58d46056a49e39ef4ca0de694ad83.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这里有个场景，比如有个黑客想攻击我们的网站：<br>数据库的主键都是从0开始递增，是没有负数的，这个黑客一直用id&lt;0的方式向我们的服务器进行请求，redis自然没有这个id，就会向MySQL进行请求，这样就造成请求不断的打到数据库上，因为Redis并没有拦截id&lt;0的数据，直接被这样的非法请求给穿透了。<br>简单来说：缓存穿透就是Redis和数据库中都没有这样的数据，一般出现这种情况都不是正常的用户，都是恶意用户。<br>解决方案：</p><ul><li>当数据穿透Redis打到数据库上时，数据库返回的空值也要同步到Redis中去，起码保证这个非法id下次请求就直接从Redis中返回了</li><li>（黑客会换不同的非法参数），直接拉黑ip</li><li>（黑客也会换不同的ip），对输入的参数进行合法性校验</li><li>布隆过滤器</li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><img src="https://img-blog.csdnimg.cn/96f5eb51acc34c21ae25340625373c38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>比如这个场景：双十一的时候，把马爸爸的鞋拿出来拍卖，程序员就把鞋的数据放到了Redis缓存中，对应一个key，拍卖的时候，可想而知，大家的热情非常高涨，一直持续了4小时，这个鞋缓存失效了，导致大量的请求查询不到这个鞋的数据，进而全部打到数据库上，造成数据库响应不及时而挂掉。<br>简单来说：就是击穿某一个非常热点的key<br>解决方案：</p><ul><li>让缓存永远不过期（不太好）</li><li>最好的方式：分布式锁（在请求数据库这一步给上锁，这时候只有一个线程可以抢到锁，也就是只有一个线程能操作数据库，那么这时候数据库的压力就非常小了，当查询到这个热点key后又写会Redis中，其他没有抢到锁的线程，让他先睡几毫秒，再重新去redis中查询数据）</li></ul><p>思考：<br>一个项目可以分为三个阶段，上线前准备、项目运行中的准备、项目宕机后的处理措施。<br>比如项目上线前，可以给它搭成集群：Redis集群、MySQL集群、本身的分布式集群，这样可以形成高可用集群，增强了系统的健壮性。<br>项目运行过程中发生的一些问题，可以采用限流降级的处理措施，防止大量请求打到数据库上，造成系统的不可用。<br>如果系统真的挂掉了，可以集成一些报警系统，即使的通知我们的开发人员，同时快速重启这个项目，利用Redis的aof、rdb持久化机制，去快速的恢复缓存数据，最大限度的去减少系统不可用的时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;缓存请求流程&quot;&gt;&lt;a href=&quot;#缓存请求流程&quot; class=&quot;headerlink&quot; title=&quot;缓存请求流程&quot;&gt;&lt;/a&gt;缓存请求流程&lt;/h2&gt;&lt;p&gt;Redis缓存的雪崩、穿透、击穿属于日常工作中经常会遇到的经典问题，下面来一探究竟，他们的解决方案主要是：布</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="数据库" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://ericzikun.github.io/tags/Redis/"/>
    
    <category term="缓存穿透" scheme="https://ericzikun.github.io/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
    <category term="缓存击穿" scheme="https://ericzikun.github.io/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    
    <category term="缓存雪崩" scheme="https://ericzikun.github.io/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器【1970年由布隆提出；Redis缓存穿透解决方案】</title>
    <link href="https://ericzikun.github.io/2022/02/14/deep18-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%901970%E5%B9%B4%E7%94%B1%E5%B8%83%E9%9A%86%E6%8F%90%E5%87%BA%EF%BC%9BRedis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91/"/>
    <id>https://ericzikun.github.io/2022/02/14/deep18-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E3%80%901970%E5%B9%B4%E7%94%B1%E5%B8%83%E9%9A%86%E6%8F%90%E5%87%BA%EF%BC%9BRedis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%91/</id>
    <published>2022-02-14T01:52:06.000Z</published>
    <updated>2022-02-14T01:57:51.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>布隆过滤器（Bloom Filter），是1970年，由一个叫布隆的小伙子提出的，距今已经五十年了。</p><p>它实际上是一个很长的二进制向量和一系列随机映射函数，二进制大家应该都清楚，存储的数据不是0就是1，默认是0。</p><p>主要用于判断一个元素是否在一个集合中，0代表不存在某个数据，1代表存在某个数据。<br><img src="https://img-blog.csdnimg.cn/215960170bbf4f779149909e57969050.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="布隆过滤器用途"><a href="#布隆过滤器用途" class="headerlink" title="布隆过滤器用途"></a>布隆过滤器用途</h2><ul><li><p>解决Redis缓存穿透 </p></li><li><p>举例：在爬虫时，对爬虫网址进行过滤，已经存在布隆中的网址，不再爬取。</p></li><li><p>举例：垃圾邮件过滤，对每一个发送邮件的地址进行判断是否在布隆的黑名单中，如果在就判断为垃圾邮件。</p></li></ul><h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><p>存入过程<br>布隆过滤器上面说了，就是一个二进制数据的集合。当一个数据加入这个集合时，经历如下洗礼（这里有缺点，下面会讲）：</p><ol><li>通过K个哈希函数计算该数据，返回K个计算出的hash值</li><li>这些K个hash值映射到对应的K个二进制的数组下标</li><li>将K个下标对应的二进制数据改成1。</li></ol><p>例如，第一个哈希函数返回x，第二个第三个哈希函数返回y与z，那么： X、Y、Z对应的二进制改成1。<br><img src="https://img-blog.csdnimg.cn/ccb185430544403ab921a5275cee4918.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><p>布隆过滤器主要作用就是查询一个数据，在不在这个二进制的集合中，查询过程如下：</p><ol><li><p>通过K个哈希函数计算该数据，对应计算出的K个hash值</p></li><li><p>通过hash值找到对应的二进制的数组下标</p></li><li><p>判断：如果存在一处位置的二进制数据是0，那么该数据不存在。如果都是1，该数据存在集合中。（这里有缺点，下面会讲）</p></li></ol><h2 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h2><p>一般不能删除布隆过滤器里的数据，这是一个缺点之一，我们下面会分析。</p><h2 id="布隆过滤器的优缺点"><a href="#布隆过滤器的优缺点" class="headerlink" title="布隆过滤器的优缺点"></a>布隆过滤器的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>由于存储的是二进制数据，所以占用的空间很小</p><p>它的插入和查询速度是非常快的，时间复杂度是O（K），可以联想一下HashMap的过程</p><p>保密性很好，因为本身不存储任何原始数据，只有二进制数据</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这就要回到我们上面所说的那些缺点了。</p><p>添加数据是通过计算数据的hash值，那么很有可能存在这种情况：两个不同的数据计算得到相同的hash值。<br><img src="https://img-blog.csdnimg.cn/5263f8a6caba46a2b780cc5c270ca85d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>例如图中的“你好”和“hello”，假如最终算出hash值相同，那么他们会将同一个下标的二进制数据改为1。这个时候，你就不知道下标为2的二进制，到底是代表“你好”还是“hello”。</p></blockquote><p>由此得出如下缺点：</p><ol><li><p>存在误判<br>假如上面的图没有存”hello”，只存了”你好”，那么用”hello”来查询的时候，会判断”hello”存在集合中。<br>因为“你好”和“hello”的hash值是相同的，通过相同的hash值，找到的二进制数据也是一样的，都是1。</p></li><li><p>删除困难<br>还是用上面的举例，因为“你好”和“hello”的hash值相同，对应的数组下标也是一样的。<br>这时候想去删除“你好”，连“hello”都一起删了。（0代表有这个数据，1代表没有这个数据）</p></li></ol><p>实现布隆过滤器<br>有很多种实现方式，其中一种就是Guava提供的实现方式。</p><ol><li>引入Guava pom配置 </li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;29.0-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 预计要插入多少数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 期望的误判率</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> fpp = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 布隆过滤器</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 插入10万样本数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      bloomFilter.put(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用另外十万测试数据，测试误判率</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; size + <span class="number">100000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bloomFilter.mightContain(i)) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(i + <span class="string">"误判了"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"总共的误判数:"</span> + count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7983195b95a0427387443fb2d3b66ae0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="深入分析代码"><a href="#深入分析代码" class="headerlink" title="深入分析代码"></a>深入分析代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">BloomFilter&lt;T&gt; <span class="title">create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">long</span> expectedInsertions, <span class="keyword">double</span> fpp, Strategy strategy)</span> </span>&#123;</span><br><span class="line">    。。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>funnel：数据类型(一般是调用Funnels工具类中的)</li><li>expectedInsertions：期望插入的值的个数</li><li>fpp：误判率(默认值为0.03)</li><li>strategy：哈希算法</li></ul><h3 id="调整fpp误判率"><a href="#调整fpp误判率" class="headerlink" title="调整fpp误判率"></a>调整fpp误判率</h3><p>情景一：fpp = 0.01</p><ul><li>误判个数：947<br><img src="https://img-blog.csdnimg.cn/11bcaf53dfeb4145aec70d3d786ae394.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>占内存大小：9585058位数<br><img src="https://img-blog.csdnimg.cn/8173ae884909482ba4263d974888df7d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="情景总结"><a href="#情景总结" class="headerlink" title="情景总结"></a>情景总结</h2></li><li>误判率可以通过fpp参数进行调节</li><li>fpp越小，需要的内存空间就越大：0.01需要900多万位数，0.03需要700多万位数。</li><li>fpp越小，集合添加数据时，就需要更多的hash函数运算更多的hash值，去存储到对应的数组下标里。（忘了去看上面的布隆过滤存入数据的过程）</li></ul><h2 id="Redis缓存穿透解决方案：布隆过滤器"><a href="#Redis缓存穿透解决方案：布隆过滤器" class="headerlink" title="Redis缓存穿透解决方案：布隆过滤器"></a>Redis缓存穿透解决方案：布隆过滤器</h2><p>首先，布孔过滤器类似于一个白名单、黑名单，主要元素就是判断元素存不存在一个过滤器中，核心在此。</p><p><img src="https://img-blog.csdnimg.cn/c1fa52df01bf41e99ecccc5884f1f9d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="白名单"><a href="#白名单" class="headerlink" title="白名单"></a>白名单</h3><p>场景：<br>前端发送一个查询请求，通过参数key，首先通过布隆过滤器，如果不存在过滤器（白名单）中，就会被过滤器给拦截，然后直接返回这个空数据给前端；如果key存在于过滤器中，就会往下执行正常的查Redis、mysql的流程；<br>这里有个流程4：如果mysql中查询不到这个key，说明什么？说明key在白名单中，单数MySQL查不到，也就是说布隆过滤器误判了！那么这个4路线就是打算把这个误判给删除，以防止下次重复同样的请求，但是由于布隆过滤器哈希碰撞导致删除很难（容易误伤），所以这个线路4是实际走不通的！<br>注意</p><ol><li>整体来说，由于我们前面说到布隆过滤器的误判概率是比较小的，所以直接打到MySQL的概率也就小，这种情况不用过于担心！</li><li>所有合法参数key都要放到布隆过滤器、Redis中。</li></ol><h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><p><img src="https://img-blog.csdnimg.cn/83675d075f644ef09d157031b5847517.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>场景:某视频网站推送视频给用户<br>布隆过滤器作用:当黑名单使用。<br>要求:已经推送过的视频,不在推送给用户<br>流程:当推送给用户一批视频时,先判断这些视频是否存在过滤器里,如果存在就不推送给用户,不存在就推送给用户,同时将推送过的视频存入过滤器黑名单里。防止下次重复推送。</p><p>代码：<br>用户实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String maYunPhone = <span class="string">"18890019390"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决缓存穿透—白名单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonBloomFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造Redisson</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> RedissonClient redisson = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> RBloomFilter&lt;String&gt; bloomFilter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      Config config = <span class="keyword">new</span> Config();</span><br><span class="line">      config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//构造Redisson</span></span><br><span class="line">      redisson = Redisson.create(config);</span><br><span class="line">      <span class="comment">//构造布隆过滤器</span></span><br><span class="line">      bloomFilter = redisson.getBloomFilter(<span class="string">"userIdFilter"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将查询数据放入Redis缓存和布隆过滤器里</span></span><br><span class="line">      initData(redisson, bloomFilter);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = getUserById(<span class="number">2L</span>);</span><br><span class="line">    System.out.println(<span class="string">"user对象为："</span> + JSON.toJSONString(user));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">(RedissonClient redisson, RBloomFilter&lt;String&gt; bloomFilter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%</span></span><br><span class="line">      bloomFilter.tryInit(<span class="number">100000000L</span>,<span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将id为1的数据，插入到布隆过滤器中</span></span><br><span class="line">      bloomFilter.add(<span class="string">"1"</span>);</span><br><span class="line">      bloomFilter.add(<span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将id为1对应的user数据，插入到Redis缓存中</span></span><br><span class="line">      redisson.getBucket(<span class="string">"1"</span>).set(<span class="string">"&#123;id:1, userName:'张三', age:18&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> == id) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String idKey = id.toString();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始模拟缓存穿透</span></span><br><span class="line">      <span class="comment">// 前端查询请求key</span></span><br><span class="line">      <span class="keyword">if</span> (bloomFilter.contains(idKey)) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 通过了过滤器白名单校验，去Redis里查询真正的数据</span></span><br><span class="line">          RBucket&lt;Object&gt; bucket = redisson.getBucket(idKey);</span><br><span class="line">          Object object = bucket.get();</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果Redis有数据，直接返回该数据</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> != object) &#123;</span><br><span class="line">              System.out.println(<span class="string">"从Redis里面查询出来的"</span>);</span><br><span class="line">              String userStr = object.toString();</span><br><span class="line">              <span class="keyword">return</span> JSON.parseObject(userStr, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果Redis为空，去查询数据库</span></span><br><span class="line">          User user = selectByDb(idKey);</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">null</span> == user) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 将数据重新刷进缓存</span></span><br><span class="line">              redisson.getBucket(id.toString()).set(JSON.toJSONString(user));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> user;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> User <span class="title">selectByDb</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"从MySQL里面查询出来的"</span>);</span><br><span class="line">      User user = <span class="keyword">new</span> User();</span><br><span class="line">      user.setId(<span class="number">1L</span>);</span><br><span class="line">      user.setUserName(<span class="string">"张三"</span>);</span><br><span class="line">      user.setAge(<span class="number">18</span>);</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分转载于：<br><a href="https://www.cnblogs.com/itlaoge/p/14219693.html" target="_blank" rel="noopener">https://www.cnblogs.com/itlaoge/p/14219693.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是布隆过滤器&quot;&gt;&lt;a href=&quot;#什么是布隆过滤器&quot; class=&quot;headerlink&quot; title=&quot;什么是布隆过滤器&quot;&gt;&lt;/a&gt;什么是布隆过滤器&lt;/h2&gt;&lt;p&gt;布隆过滤器（Bloom Filter），是1970年，由一个叫布隆的小伙子提出的，距今已经五</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="数据库" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://ericzikun.github.io/tags/Redis/"/>
    
    <category term="布隆过滤器" scheme="https://ericzikun.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
    <category term="缓存穿透" scheme="https://ericzikun.github.io/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL用了索引为什么还是查询很慢？查询速度和什么因素有关？</title>
    <link href="https://ericzikun.github.io/2022/02/13/deep17-mysql%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%98%AF%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%EF%BC%9F/"/>
    <id>https://ericzikun.github.io/2022/02/13/deep17-mysql%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E6%98%AF%E6%9F%A5%E8%AF%A2%E5%BE%88%E6%85%A2%EF%BC%9F/</id>
    <published>2022-02-13T07:43:33.000Z</published>
    <updated>2022-02-14T03:41:20.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近几个月在华为实习的过程中，有个场景下取数，对于一个sn号的查询竟然长达几分钟的时间，批量查几十个sn时，则需要一二十分钟的sql查询时间，故专门对这个问题进行一些整理和思考。<br>首先，这个数据库是存在HIVE上，经过和一些前辈交流后，了解到企业中的数据库主要分为两大种：OLTP（on-line transaction processing）事务型、OLAP（On-Line Analytical Processing）分析型。</p><ul><li>OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。</li><li>OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 </li></ul><ol><li>那么，事务型数据库OLTP主要以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。在这样的系统中，单个数据库每秒处理的Transaction往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。OLTP系统最容易出现瓶颈的地方就是CPU与磁盘子系统。</li><li>OLAP，也叫联机分析处理（Online Analytical Processing）系统，有的时候也叫DSS决策支持系统，就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB/s的流量。磁盘子系统的吞吐量则往往取决于磁盘的个数，这个时候，Cache基本是没有效果的，数据库的读写类型基本上是db file scattered read与direct path read/write。应尽量采用个数比较多的磁盘以及比较大的带宽，如4Gb的光纤接口。<br>在OLAP系统中，常使用分区技术、并行技术。</li></ol><h1 id="查询速度影响因素"><a href="#查询速度影响因素" class="headerlink" title="查询速度影响因素"></a>查询速度影响因素</h1><p>回到正题，为什么我用了索引，查询速度还是很慢？到底会出现什么问题，以及如何去解决？本文来探究一二。</p><p>先给出结论：MySQL用到了索引和执行时间的长短没有必然关系，确定查询执行效率的是 “<strong>扫描行数</strong>”与“<strong>回表次数</strong>”。 </p><ul><li>扫描行数</li><li>回表次数</li></ul><p>在实际的sql优化过程中，也是尽量去优化这两块影响因素。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>举例说明：<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">a <span class="built_in">varchar</span>(<span class="number">64</span>)<span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">b <span class="built_in">int</span>(<span class="number">11</span>)<span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">KEY</span> a(a) <span class="keyword">ENGINE</span>-<span class="keyword">InnoDB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Query</span> OK, O <span class="keyword">rows</span> affected(<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><br>先建一个表，InnoDB必须有一个主键索引，这里给id为主键，其次有a、b两个字段，再给a字段（姓名字段）一个普通索引，目前就有了主键索引和a索引树结构，如下图所示：</p><p> <img src="https://img-blog.csdnimg.cn/b00afa5810134e7da7773d258828dc5d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>这里再回顾一下，InnoDB默认有主键索引，存储的是主键id1、2、3…，它是采用B+ tree的聚簇索引，所有的数据都存放在叶子结点中，而普通索引a的数据只包含对应的id，没有整行数据，所以如果通过普通索引找到了某个id，需要select别的字段，则还需要回表找主键索引中的整行数据取值！</p></blockquote><blockquote><p>慢查询:<br>sq中慢查询阈值为ong_ query time=10s<br>当sq执行后大于10s就会被记录到慢sq志<br>般建议缩小到1s，一般来说当并发系统中某一条sql查询时间大于1s了，对整体系统的性能影响就会比较大了。</p></blockquote><h2 id="情况1："><a href="#情况1：" class="headerlink" title="情况1："></a>情况1：</h2><p>select * from t #全表扫描<br><img src="https://img-blog.csdnimg.cn/e21558f2aa7a49b787b25de97d3f242e.png" alt="在这里插入图片描述"></p><p>其中，type=ALL表示扫描所有行，速度是最慢的，从头到尾扫描。</p><h2 id="情况2："><a href="#情况2：" class="headerlink" title="情况2："></a>情况2：</h2><p>select * from where id = 2 #主键索引快速过滤<br><img src="https://img-blog.csdnimg.cn/b49d907f292a4237b0546dfbc6983191.png" alt="在这里插入图片描述"><br>根据主键id索引进行查询，这时采用了key也就是索引，速度是最快的，也不用回表</p><h2 id="情况3："><a href="#情况3：" class="headerlink" title="情况3："></a>情况3：</h2><p>select a from t #索引覆盖，无需回表<br><img src="https://img-blog.csdnimg.cn/a5bac585102b40c897df3d3857684666.png" alt="在这里插入图片描述"><br>采用了索引覆盖，查询速度也是很快的，因为也不用回表，采用了索引为a，取的也是a字段，也是一步到位。</p><blockquote><p>在MySQL大分页的过程中也用到了索引覆盖的方式进行了优化</p></blockquote><h2 id="情况4："><a href="#情况4：" class="headerlink" title="情况4："></a>情况4：</h2><p>select * from t where id&gt;0 #基于id扫描全表，且产生大量回表，速度慢<br> <img src="https://img-blog.csdnimg.cn/a8c3b2516da84b6d9ff825cd2f52840a.png" alt="在这里插入图片描述"></p><p>用*或者多个字段可能要全表扫描。<br>一般来说查询的数据量要是全表的25%以内，数据库才会判断有走索引的价值，这里不能光看key中有primary就认为走了索引就很快，而还要看row中扫描了多少行，这种情况下row中的行数就等于表的总行数，查询的速度并不快，是全表扫描！</p><h2 id="情况5："><a href="#情况5：" class="headerlink" title="情况5："></a>情况5：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create index t on(a, b)</span><br><span class="line">假设t表有1亿人,其中600万姓“张”</span><br><span class="line"></span><br><span class="line">select* from t <span class="built_in">where</span> a=张三 and b=23</span><br><span class="line">索引选择性就很好</span><br><span class="line"></span><br><span class="line">select from t <span class="built_in">where</span> a like 5k%<span class="string">' and b =23</span></span><br><span class="line"><span class="string">索引选择性较差,但仍会用到索引</span></span><br></pre></td></tr></table></figure><p>作为联合索引，根据前面博客提到的最左前缀法则，我们必须在where中按照联合索引的顺序来查，在左索引基础上查右索引，所以第一句sql是比较快的，直接可以在联合索引树中找到张三这个人；而第二句由于使用了模糊查询，如果姓张的人超过了总数的10%、15%，MySQL就会认为这样的选择性太差，就不会给使用索引了！（没有使用索引的价值！）而转去走全表扫描了。这里的设计是1亿人中有600万人姓“张”，所以虽然索引选择性相对较差，但是MySQL认为还是可以用索引。<br>MySQL5.6之后做的优化：index condition pushdown，优化了回表数量级</p><ul><li>mysq5.6以前,基于左侧列对600万张回表筛选23岁数据,速度比较慢</li><li>mysq5.6以后,基于联合索引左侧列a筛选“张”再去筛选“23岁”,再讲符<br>合条件的id回表提取,回表数量大幅度减少<br>这种新特性称为” index condition pushdown”</li></ul><p>几种调优方式：</p><ol><li>增加多种不同规格索引提高索引选择性(5~6组)</li><li>空间换时间,定时任务增加时报、日报、约报等中间结果</li><li>边缘运算数据压缩:物联网惯用伎俩<br>4硬件调优:增大 innodb buffer pool多利用内存,减少硬盘回表<blockquote><p>解释：<br>2.每一个小时 每一分钟去做计算，做汇总，而不是全量汇总，这样数据量就小很多了<br>3.边缘运算：比如几百万的基站给服务器去每秒上传数据，那么服务器的压力肯定是很大的，如果过往一个小时内数据没有任何异常，则可以用一个表达式把一个小时的数据状态记录压缩成一条记录，实现数据的压缩，再向上上报一次，压力大大降低<br>4.从硬件角度优化，增大内存！</p></blockquote></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;近几个月在华为实习的过程中，有个场景下取数，对于一个sn号的查询竟然长达几分钟的时间，批量查几十个sn时，则需要一二十分钟的sql查询时间，</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="数据库" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://ericzikun.github.io/tags/MySQL/"/>
    
    <category term="InnoDB" scheme="https://ericzikun.github.io/tags/InnoDB/"/>
    
    <category term="sql优化" scheme="https://ericzikun.github.io/tags/sql%E4%BC%98%E5%8C%96/"/>
    
    <category term="查询速度" scheme="https://ericzikun.github.io/tags/%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6/"/>
    
    <category term="OLAP" scheme="https://ericzikun.github.io/tags/OLAP/"/>
    
    <category term="OLTP" scheme="https://ericzikun.github.io/tags/OLTP/"/>
    
  </entry>
  
  <entry>
    <title>初探MySQL 读已提交和可重复读级别下 MVCC并发版本控制实现原理</title>
    <link href="https://ericzikun.github.io/2022/02/07/deep16-MySQL-%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%92%8C%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%BA%A7%E5%88%AB%E4%B8%8B-MVCC%E5%B9%B6%E5%8F%91%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://ericzikun.github.io/2022/02/07/deep16-MySQL-%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%92%8C%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E7%BA%A7%E5%88%AB%E4%B8%8B-MVCC%E5%B9%B6%E5%8F%91%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2022-02-07T15:06:29.000Z</published>
    <updated>2022-02-07T15:08:44.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事务ACID回顾"><a href="#事务ACID回顾" class="headerlink" title="事务ACID回顾"></a>事务ACID回顾</h2><p>InnDB引擎下，具备事务功能，事务具备ACID（原子性、一致性、隔离性、持久性），一致性其实是目的，由原子性、隔离性和持久性共同来保证！原子性是由undo log来进行保证的（回滚的时候采用undo log），持久性由InnoDB的redo log、undo log、 binlog来保证，而隔离性指的是它有四个隔离级别，分别是：</p><ul><li><p>读未提交</p></li><li><p>读提交</p></li><li><p>可重复读</p></li><li><p>串行化</p><p><img src="https://img-blog.csdnimg.cn/067f353e47b34f71b0e5823ca2314725.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li></ul><p>其中我们用的比较多的是 读提交（RC） 和 可重复读（RR），下面来详细介绍一下他们是如何通过MVCC多版本并发控制实现的。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>在MySQL InnoDB存储引擎下,RC、RR基于MVCC（<strong>多版本并发控制</strong>）进行并发事务控制</p><p>MVCC是基于”数据版本”<strong>对并发事务进行访问</strong></p><p>下面举一个例子来说明实现原理：</p><p> <img src="https://img-blog.csdnimg.cn/a8f9adfd0fa549b99d39cea25a74e2fb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>现在有三个事务，事务id分别是 trx_id = 1、2、3、4；前面三个事务都对张三这个人做了name的更新并且提交，事务4就是在两个时间段去做了“读”操作，我们先来看在“读提交”的隔离级别下，事务4的两次读操作会读出什么结果呢？</p><p>如果是RC级别，那么 select1 = 张三，select2=张小三，在图中可以看出这个时序关系。</p><p>如果是RR级别，那么select1= 张三，select2=张三，两次结果相同。</p><p>下面来分析底层实现原理：</p><h3 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h3><p>先来了解一下undo log版本链，他用链的形式存储了数据的变化：</p><p> <img src="https://img-blog.csdnimg.cn/481ad58818164bd0b199ce5236c82d8d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>其中trx_id代表导致当前数据版本的事务id，DB_ROLL_PTR储存着上一个数据版本的数据地址</p><blockquote><p>这里补充一个undo log回滚的过程：</p><p>如果要回滚，那么就得</p><p>比如插入一条记录，得把这个记录的id记录下来，回滚的时候直接删掉这个id即可。</p><p>删除记录则要把记录的内容保留，回滚的时候插入即可。修改的时候则把旧值记录，回滚时直接把旧值写入。</p><p>问：</p><p>undo log不是会被删除吗？中间数据万一被删了版本链不就断了吗？</p><p>undo log版本链不是立即删除，mysql确保版本链数据不再被“引用”后再进行删除！</p></blockquote><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>ReadView就是读视图，</p><p>ReadView是“<strong>快照读</strong>”SQL执行时MVCC提取数据的<strong>依据</strong>.</p><p><strong>快照读就是最普通的Select查询SQL语句</strong></p><p>当前读指代执行下列语句时进行数据读取的方式（比如插入或者删除数据，必须是最新的表的状态下去做变更操作！）</p><p>Insert、Update、Delete、</p><p>Select…for update</p><p>Select…lock in share mode</p><p>只有当快照读的时候才会用到MVCC</p><p>ReadView的数据结构：</p><p>ReadView是一个数据结构，包含4个字段</p><ul><li>m_ids:当前活跃的事务编号集合</li><li>min_trx_id:最小活跃事务编号</li><li>max_trx_id:预分配事务编号，当前最大事务编号+1</li><li>creator_trx_id:ReadView创建者的事务编号</li></ul><h3 id="读已提交（RC）下"><a href="#读已提交（RC）下" class="headerlink" title="读已提交（RC）下"></a>读已提交（RC）下</h3><p>读已提交（RC）：在每执行一次快照读的时候，都去生成一个ReadView，所以两次生成了两个不同的ReadView读视图</p><p><img src="https://img-blog.csdnimg.cn/e546b3e4b7614607a94298dfa44912fd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/13d0001ccbcd4131b89202f3a34dd46f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>分析：</p><p>在事务4的第一个select语句执行时，生成了一个ReadVIew，它是用来判断读取undo log版本链中具体哪一个数据版本的，根据右侧的规则一步步进行判断即可，</p><p>举例：</p><p>先对TRX_ID = 3进行判断：</p><p>从undo log的最新一个版本（TRX-ID = 3）开始遍历，当前的事务id为3，不等于creator_id，也就是说，select的事务和这个数据版本不是同一个事务，那就继续向下判断（如果相等，说明select事务之前可能做了一个更新操作，之后才select 是同一个事务中的前后操作 所以肯定是可以读的！）</p><p>继续判断：当前的事务id和min_trx_id相比，比min要大，所以还得继续判断（如果确实比min小，那么说明是在最小活跃事务之前数据提交得，是可以访问的）</p><p>继续判断：当前事务id和max_trx_id相比，比max要小，所以还得继续判断（如果比max大，说明这个数据版本在的事务是在ReadView生成之后才开启的，不允许访问）</p><p>继续判断：如果当前事务在min和max之前，就是最小活跃事务和最大活跃事务之间，并且还要判断当前事务存在于活跃事务中（m_ids：记录了还有哪些事务没有被提交），如果不在活跃事务中也就是提交了，那就可以访问</p><p>先对TRX_ID = 2进行判断：</p><p>…</p><p>先对TRX_ID = 1进行判断：</p><p>满足条件 trx_id &lt; min_trx_id(2) 成立，说明在最小活跃事务之前就提交了已经，可以访问！</p><h3 id="可重复读（RR）下"><a href="#可重复读（RR）下" class="headerlink" title="可重复读（RR）下"></a>可重复读（RR）下</h3><p>仅在第一次执行快照读时生成ReadView，后续快照读复用前面的ReadVIew</p><p> <img src="https://img-blog.csdnimg.cn/7f4b58ac7060498a942767566ec95664.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>RR级别下使用MVCC能避免幻读吗？</p><p>能，但不完全能！</p><ol><li>连续多次快照读，ReadView会产生复用，没有幻读问题</li><li>当两次快照读之间存在当前读，<strong>ReadView会重新生成，导致产生幻读</strong></li></ol></blockquote><p>举例：</p><p>在事务B中两次select快照读的中间有一个 更新语句（当前读），这种情况下，第二次的快照读生成的ReadVIew就会重新生成，而不是复用，否则在同一个事务中前后就会造成不一致！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事务ACID回顾&quot;&gt;&lt;a href=&quot;#事务ACID回顾&quot; class=&quot;headerlink&quot; title=&quot;事务ACID回顾&quot;&gt;&lt;/a&gt;事务ACID回顾&lt;/h2&gt;&lt;p&gt;InnDB引擎下，具备事务功能，事务具备ACID（原子性、一致性、隔离性、持久性），一致性其</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="数据库" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://ericzikun.github.io/tags/MySQL/"/>
    
    <category term="InnoDB" scheme="https://ericzikun.github.io/tags/InnoDB/"/>
    
    <category term="MVCC" scheme="https://ericzikun.github.io/tags/MVCC/"/>
    
    <category term="隔离级别" scheme="https://ericzikun.github.io/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL底层采用B+ tree的原因剖析【哈希、平衡二叉、B树为啥不行？】</title>
    <link href="https://ericzikun.github.io/2022/01/27/deep14-MySQL%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8B-tree%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>https://ericzikun.github.io/2022/01/27/deep14-MySQL%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8B-tree%E7%9A%84%E5%8E%9F%E5%9B%A0/</id>
    <published>2022-01-27T15:12:04.000Z</published>
    <updated>2022-01-27T15:24:00.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引底层采用B-tree的原因"><a href="#MySQL索引底层采用B-tree的原因" class="headerlink" title="MySQL索引底层采用B+ tree的原因"></a>MySQL索引底层采用B+ tree的原因</h1><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html</a></p><p>通过 哈希 函数计算和类似取余运算，可以将元素插入到对应的bucket中，find的过程是o(1)时间复杂度，那find速度这么快，为啥Mysql底层不用呢？<br> <img src="https://img-blog.csdnimg.cn/df8153bbe6144c2fa2ea631bf22dac01.gif" alt="在这里插入图片描述"></p><p>因为Mysql的查询涉及大量的范围查询，Hash索引这个无序集合，是不支持范围查询的，再比如mysql的排序查询（order by），而哈希是无序的，也无法支持！就像我们的uuid是无序的，不可能用他来做主键。</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</a></p><p>平衡二叉树的左右子树的高度差不会大于1。</p><p>无论怎么插，高度差都会维持，</p><p>随着树的高度增加，他的查询速度也会逐渐变慢，</p><p>比如这里找8，一次就找到了，但是找10找了三次。</p><p>还有一个致命缺点，如果我们去查5，通过三次定位找到了5，如果要找大于5的数据，就要从5这个节点往回查找，找到6，7，再回到更上一层的8，往下再9、10，这样才把大于5的数据找出来了，想象一下，如果大于5的数据特别多，那么回旋查询的次数就会增多，在这种范围查找上的效率很低。</p><p>这就是平衡二叉树的缺点：</p><ul><li><p>高度越高，查询速度越慢</p></li><li><p>范围查找需要回旋的次数很大，效率低</p><p><img src="https://img-blog.csdnimg.cn/de7ce7d8c3814a3a955733f229b84e38.gif" alt="在这里插入图片描述"></p></li></ul><p><img src="https://img-blog.csdnimg.cn/8497978b36c145cca37c16a127c4617b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p><p> <img src="https://img-blog.csdnimg.cn/77e9a5963064495a8ad671671201ab37.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1c2b6713610e4b15bd504a2830e8a375.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>B树最大的特点就是一个节点可以存两个值</p><p>这样存储有什么好处呢？</p><p>对比平衡二叉树，同时存10个数字的情况下，平衡二叉树有4层，而B树只有三层。</p><p>树的高度上面，B树更优（毕竟一个节点存放的数字更多了，更紧凑）</p><p>变矮之后的好处就在于：查询的效率变高了，查数字的速度更快了</p><p>样例：之前平衡树找10需要找3次，而B树只用了2次。</p><p>所以，<strong>从平衡二叉树-&gt;B树，解决了树的高度的问题，树越矮，查询的效率越高。</strong></p><p>那么，B树存在回旋查找的问题吗？答案是肯定的：</p><p>比如要查找大于5的数，一样需要回旋到上一层的6、8…，所以B树的范围查找仍然不太理想。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p><p> <img src="https://img-blog.csdnimg.cn/6eb238e2215348c082328ca82630ecf5.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3e8f3c6e346942e2a52b2ca4a35a1647.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>B+树彻底解决了回旋查找的问题</p><p>它和B树的共同特点是一个节点可以存两个值，B+树和B树的明显区别就在叶子节点，B+树用了一个链表去解决了回旋查找的问题（比如查找大于5的数，找到5之后，通过链表直接把后面的数字全拿出来了），所以范围查找的效率极高。</p><p><strong>这也解释了为什么排序的时候要用索引去排序，因为B+树已经帮我们排好序了！我们按照索引排序的话，就不会触发文件内排序了！</strong></p><p>上面的树和叶子节点的关系：</p><ul><li><p>凡是非叶子结点出现的数组都会出现的叶子节点</p></li><li><p>非叶子节点只存储key，不存储value，这里的key就是这些数字索引，而叶子节点存储的除了key之外，还有value（数字的地址）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL索引底层采用B-tree的原因&quot;&gt;&lt;a href=&quot;#MySQL索引底层采用B-tree的原因&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引底层采用B+ tree的原因&quot;&gt;&lt;/a&gt;MySQL索引底层采用B+ tree的原因&lt;/h1</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="数据库" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://ericzikun.github.io/tags/MySQL/"/>
    
    <category term="B+树" scheme="https://ericzikun.github.io/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL如何通过索引找到一条真实的数据？</title>
    <link href="https://ericzikun.github.io/2022/01/27/deep15-MySQL%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E6%89%BE%E5%88%B0%E4%B8%80%E6%9D%A1%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>https://ericzikun.github.io/2022/01/27/deep15-MySQL%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E6%89%BE%E5%88%B0%E4%B8%80%E6%9D%A1%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%95%B0%E6%8D%AE/</id>
    <published>2022-01-27T15:10:58.000Z</published>
    <updated>2022-01-27T15:16:27.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL如何通过索引找到一条真实的数据"><a href="#MySQL如何通过索引找到一条真实的数据" class="headerlink" title="MySQL如何通过索引找到一条真实的数据"></a>MySQL如何通过索引找到一条真实的数据</h1><h2 id="Mylsan和-InnoDB常见区别"><a href="#Mylsan和-InnoDB常见区别" class="headerlink" title="Mylsan和 InnoDB常见区别"></a>Mylsan和 InnoDB常见区别</h2><h3 id="事务方面"><a href="#事务方面" class="headerlink" title="事务方面"></a>事务方面</h3><p>noDB支持事务, MyISAM不支持事务。这是 MySQL将默认存储引擎从 MyISAM变成 innoDB的重要原因之</p><h3 id="外键方面"><a href="#外键方面" class="headerlink" title="外键方面"></a>外键方面</h3><p>nnoDB支持外键,而 MyISAM不支持。对一个包含外键的 innoDB表转为 MYISAM会失败。</p><h3 id="索引层面"><a href="#索引层面" class="headerlink" title="索引层面"></a>索引层面</h3><p>innoDB是<strong>聚集(聚簇)索引</strong>, MyISAM是非聚集(非聚簇)索引。后面会重点讲解这两种索引的区别<br>MyISAM支持 FULLTEXT类型的<strong>全文索引,</strong><br>innoDB不支持 FULLTEXT类型的全文索引,但是 innoDB可以使用 sphinx插件支持全文索引,并且效果更好。</p><h3 id="锁粒度方面"><a href="#锁粒度方面" class="headerlink" title="锁粒度方面"></a>锁粒度方面</h3><p>innoDB最小的锁粒度是行锁, MyISAM最小的锁粒度是表锁。<br>一个更新语句会锁住整张表,导致其他查询和更新都会被阻塞,因此并发访问受限</p><p>这也是MySQL将默认存储引擎从MyISAM变成InnoDB的重要原因之一。</p><h3 id="硬盘存储结构"><a href="#硬盘存储结构" class="headerlink" title="硬盘存储结构"></a>硬盘存储结构</h3><p>MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。</p><ul><li>frm文件存储表的定义</li><li>数据文件的扩展名为.MND( MYData)</li><li>素引文件的扩展名是,MYr( MYIndex)</li></ul><p>Innodb存储引擎存储数据库数据，一共有两个文件（没有专门保存数据的文件）：</p><ul><li>frm文件存储表的定义</li><li>Ibd文件：数据和索引存储文件。数据以主键进行聚集存储，把真正的数据保存在叶子节点中。</li></ul><h3 id="聚簇索引-和非聚簇索引"><a href="#聚簇索引-和非聚簇索引" class="headerlink" title="聚簇索引 和非聚簇索引"></a>聚簇索引 和非聚簇索引</h3><h4 id="聚簇索引-InnoDB"><a href="#聚簇索引-InnoDB" class="headerlink" title="聚簇索引( InnoDB)"></a>聚簇索引( InnoDB)</h4><p>将<strong>数据存储</strong>与<strong>素引</strong>放到了一块,索引结构的<strong>叶子节点保存了数据</strong>（B+ tree）<br>表数据按照索引的顺序来存储的,也就是说索引项的顺序与表中记录的物理顺序一致。<br>InnoDB中,在聚簇索引之上创建的索引称之为辅助索引,像复合索引、前缀索引、唯一索引等等。</p><ul><li>聚簇索引默认是主键</li><li>如果表中没有定义主键, InnoDB会选择一个<strong>唯一的非空索引代替</strong>。【唯一非空索引】</li><li>如果没有这样的索引, InnoDB会在内部生成一个名为GEN_ CLUST INDEX的隐式的聚簇索引。</li></ul><h4 id="非聚簇索引-MyISAM"><a href="#非聚簇索引-MyISAM" class="headerlink" title="非聚簇索引( MyISAM)"></a>非聚簇索引( MyISAM)</h4><p>将数据与索引分开存储,表数据存储顺序与索引顺序无关。</p><h2 id="MyISAM索引查询数据过程"><a href="#MyISAM索引查询数据过程" class="headerlink" title="MyISAM索引查询数据过程"></a>MyISAM索引查询数据过程</h2><p><img src="https://img-blog.csdnimg.cn/8b845237939f4e40bc068520efd7c781.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>该图的左边是索引文件，右边是数据文件。</p><p>索引文件和数据文件是分开存储的。</p><p>之前提到过，索引是B+ tree存储的，左图的非叶子节点就是主键id，叶子结点存储的除了id外，还有每一行数据的物理存储地址，通过B+ tree找到id对应的地址，再通过右边的地址映射找到数据。</p><h2 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h2><p><img src="https://img-blog.csdnimg.cn/9cf035b3883946a5ae135935a6137ee2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> 对于InnoDB来说，它的索引和数据是存储到同一个文件里面去的，</p><ul><li>左图叫聚簇索引：InnoDB中以主键id为索引key</li><li>右图是辅助索引：别的字段为索引</li></ul><p>InnoDB同样是B+ tree，而这里和MyISAM引擎不同的是，叶子节点储存的不再是物理地址，而是真实的数据！</p><p>比如找id为15的数据，通过左图的B+ tree找到它对应的叶子结点，直接就把它整行的数据都拿出来了，不用再去找物理地址了！【和MyISAM区分开】</p><p>右图：辅助索引的叶子节点存储的是辅助索引key和它对应的id主键，而不是整行的数据！所以如果要如果user_name这个辅助索引找整行的数据，比如找user_name = Eric的整行数据，先要通过右图辅助索引找到它对应的id，然后再通过左图的聚簇索引找到它对应的叶子节点，从而才能拿到整行的数据！</p><p>这样就解释了，为什么 select的时候，尽量使用<strong>覆盖索引</strong>，也就是和后面检索条件中的索引尽可能一致或者是查它id，这样一次查到，而不用再去左图聚簇索引中查了！</p><h2 id="对比MyISAM和InnoDB"><a href="#对比MyISAM和InnoDB" class="headerlink" title="对比MyISAM和InnoDB"></a>对比MyISAM和InnoDB</h2><ul><li><p>MyISAM：无论是主键索引还是普通索引，查找数据的流程都是一样的，都会先去B+ tree找到对应叶子节点，再去物理地址取数据。【<strong>先找地址，再通过地址找数据</strong>】</p></li><li><p>InnDB，查找数据的流程分为两种类型</p><ul><li>聚簇索引：通过主键id能够直接取出全部数据（叶子节点中存放真实数据）</li><li>辅助索引：通过索引找到对应id，再通过聚簇索引的B+ tree找到真实数据，要找两次！</li></ul></li><li><p>InnoDB在<strong>聚簇索引</strong>的查询过程中比MyISAM快一些；InnoDB辅助索引的查询过程在一定程度上比MyISAM慢一些</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL如何通过索引找到一条真实的数据&quot;&gt;&lt;a href=&quot;#MySQL如何通过索引找到一条真实的数据&quot; class=&quot;headerlink&quot; title=&quot;MySQL如何通过索引找到一条真实的数据&quot;&gt;&lt;/a&gt;MySQL如何通过索引找到一条真实的数据&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="数据库" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://ericzikun.github.io/tags/MySQL/"/>
    
    <category term="B+树" scheme="https://ericzikun.github.io/tags/B-%E6%A0%91/"/>
    
    <category term="索引" scheme="https://ericzikun.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="InnoDB" scheme="https://ericzikun.github.io/tags/InnoDB/"/>
    
    <category term="MyISAM" scheme="https://ericzikun.github.io/tags/MyISAM/"/>
    
  </entry>
  
  <entry>
    <title>还不了解lambda？还再用迭代遍历操作集合？赶紧上Stream流！</title>
    <link href="https://ericzikun.github.io/2021/11/28/deep13-%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86Java-lambda-Stream-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://ericzikun.github.io/2021/11/28/deep13-%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86Java-lambda-Stream-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-11-28T02:18:50.000Z</published>
    <updated>2021-11-28T02:33:33.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数式编程（Lambda-amp-amp-Stream）"><a href="#函数式编程（Lambda-amp-amp-Stream）" class="headerlink" title="函数式编程（Lambda &amp;&amp; Stream）"></a>函数式编程（Lambda &amp;&amp; Stream）</h1><p>参考：《Java8实战》+《B站三更草堂》</p><h1 id="以sort引入"><a href="#以sort引入" class="headerlink" title="以sort引入"></a>以sort引入</h1><p>匿名内部类-&gt;lambda</p><p>​    我们常常用传入Comparator来完成排序行为的传入，这里我们传进去的实际上是如何排序这个行为，lambda实际上就是让我们尽可能的去关注这个行为本身，至于Comparator这个接口里面要覆盖重写的方法叫啥，我们其实没必要过多的关心，关注一下返回类型就够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line">        Collections.sort(integers, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(integers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个简单例子很容易转换为lambda，这里刚开始不熟悉，可以直接使用IDEA的自动转换功能</p><p> <img src="https://img-blog.csdnimg.cn/c314e2b31afe4399b7ff22f750f4b8e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line">       Collections.sort(integers, (o1, o2) -&gt; o1-o2);</span><br><span class="line">       System.out.println(integers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="几个官方提供的接口"><a href="#几个官方提供的接口" class="headerlink" title="几个官方提供的接口"></a>几个官方提供的接口</h1><h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p>​    再来几个官方提供的常用接口，其实接口叫什么名字并不重要，具体的行为是我们程序员去设计的，我们只需要关注它的返回值类型就行了，比如Predicate这个接口</p><p>​    比如我们要对一组数做相同的判定操作，这个判定操作返回的就是布尔类型，每个数字是或否，那么官方提供的IntPredicate这个接口的test方法就能满足我们这个需求，我们只需要在调用printNum方法时，传入判定的具体内容，就可以灵活改变判定行为了，这个在《Java8实战》中聊的比较多，主要是为了方法的扩展性，当需求不断变更时，我们只需要去改变传入的行为即可，而不是整篇代码大幅度修改，那么显得并不那么优雅！<br><img src="https://img-blog.csdnimg.cn/51b61fd839a94533a53bc7daba18f5fd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       printNum(<span class="keyword">new</span> IntPredicate() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">           </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> value%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           &#125; &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(IntPredicate predicate)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">           <span class="keyword">if</span>(predicate.test(i))&#123; System.out.println(i);</span><br><span class="line">           &#125; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>​    Function函数简单来说，就是传入一个类型T，返回一个类型R，具体怎么操作T这个传入，自己来定行为即可！</p><p>这样就大大扩展了我们实际想去传入的这个行为，因为这个行为的扩展还包括了我们想灵活定制的传入传出类型！比如这里我们将字符串接受，返回Integer类型：<br><img src="https://img-blog.csdnimg.cn/ceb47129de1f41649027f79fb6bfa07e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer result = typeConver(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">typeConver</span><span class="params">(Function&lt;String, R&gt; function)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"1235"</span>;</span><br><span class="line">        R result = function.apply(str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c256eaf7438b450097306cd7cfb7cd50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>还可以对输出类型做改变，比如改成双层List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = typeConver(<span class="keyword">new</span> Function&lt;String, List&lt;List&lt;Integer&gt;&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; apply(String s) &#123;</span><br><span class="line"></span><br><span class="line">                List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                integers.add(Integer.valueOf(s));</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(integers);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">typeConver</span><span class="params">(Function&lt;String, R&gt; function)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"1235"</span>;</span><br><span class="line">        R result = function.apply(str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/1865897b7c4b4e5ab1b32a3f66c0c27a.png" alt="在这里插入图片描述"></p><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>​    这个接口返回的类型最简单，因为它没有返回，比如这个IntConsumer，接受的Int类型，啥也不返回，一般我们主要用于打印语句上：</p><p>​    当然还有Consumer<T>，void accept(T t)接受泛型输入</p><p> <img src="https://img-blog.csdnimg.cn/979d6217e97a4b8ab6d818ac4038d57b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       foreachArr(<span class="keyword">new</span> IntConsumer() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">               System.out.println(value);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foreachArr</span><span class="params">(IntConsumer consumer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">           consumer.accept(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h2><p>生产型接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回</p><p><img src="https://img-blog.csdnimg.cn/daea3d4c566743bd97fb570a08f2a8c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="流Stream"><a href="#流Stream" class="headerlink" title="流Stream"></a>流Stream</h1><p>​    流的操作主要分为创建、中间操作、终结操作：</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>​    创建很简单，分为集合单列对象、数组、双列集合（Map-&gt;entrySet）</p><p>集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line">Stream&lt;Author&gt; stream = authors.stream();</span><br></pre></td></tr></table></figure><p>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(arr); </span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(arr);</span><br></pre></td></tr></table></figure><p>双列集合：</p><p>本质上还是将Map转化为单列集合entrySet 再做流操作，和前面一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">map.put(<span class="string">"蜡笔小新"</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">"黑子"</span>,<span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">"日向翔阳"</span>,<span class="number">16</span>);</span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="流式debug"><a href="#流式debug" class="headerlink" title="流式debug"></a>流式debug</h3><p> <img src="https://img-blog.csdnimg.cn/fc7644b506234c1e9e16e7c4a413569c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>​    过滤操作，简单来说就是对集合中的元素根据每个判定条件筛选过滤，比如年龄都大于18、名字长度都小于3…<br>​    前面调到了Predicate，返回一个布尔类型判定, 这里的filter传入的就是该匿名内部类，可以对集合里面的元素对象的属性做任何值的判定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">       authors.stream()<span class="comment">//把集合转换成流</span></span><br><span class="line">               .distinct()<span class="comment">//先去除重复的作家</span></span><br><span class="line">               .filter(<span class="keyword">new</span> Predicate&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">return</span>  author.getAge() &lt; <span class="number">18</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)<span class="comment">//筛选年龄小于18的</span></span><br><span class="line">               .forEach(author -&gt; System.out.println(author.getName()));<span class="comment">//遍历打印名字</span></span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()<span class="comment">//把集合转换成流</span></span><br><span class="line">                .distinct()<span class="comment">//先去除重复的作家</span></span><br><span class="line">                .filter(<span class="keyword">new</span> Predicate&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span>  author.getAge() &lt; <span class="number">18</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)<span class="comment">//筛选年龄小于18的</span></span><br><span class="line">                .forEach(author -&gt; System.out.println(author.getName()));<span class="comment">//遍历打印名字</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>​    map操作相当于是将集合里面的对象一一映射到另一个对象上去，比如我想拿到作者集合中的所有人名，类型为List&lt;String&gt;而不是List&lt;Author&gt;，这里就已经改变了集合中的元素类型了，按传统方法不用流的话，就要再new一个List&lt;String&gt;，遍历一遍List&lt;Author&gt;，不断的add，相当不优雅！这里直接用map操作得到想要的映射对象。</p><p>​    那么此处传入的接口应该是啥呢？很明显是前后类型不一致，传入的就是Function接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.map(<span class="keyword">new</span> Function&lt;Author, String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> author.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()<span class="comment">//把集合转换成流</span></span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .forEach(authorName -&gt; System.out.println(authorName));<span class="comment">//遍历打印名字</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b3051af8557d4d4aa349337663a351cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>​    这个很简单，就是<strong>去重</strong>操作，基于对象的equals重写方法，一般默认去比较对象的属性值是否相等，如果作者的名字、年龄等其他属性都相等的情况下，说明是同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line">authors.stream()</span><br><span class="line">       .distinct()</span><br><span class="line">.forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>​    这个排序操作，本文一开始就引入了，这里就不赘述了，直接上代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors(); 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span><br><span class="line">authors.stream() </span><br><span class="line">  .distinct()</span><br><span class="line">    .sorted((o1, o2) -&gt; o2.getAge()-o1.getAge()) </span><br><span class="line">  .forEach(author -&gt;System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>​    flatMap，翻译过来就是平铺下去，和map的区别在于，map是一个对象对应一个值做映射，而flatMap中一个对象可以对应多个值，比如这里每个作者有一个Book集合，我们想把所有Book都放在一个集合中，这里相当于把每个对象所对应关联的那个属性值拼接在一个集合里面，就可以这样做：</p><p>​    这里Function第二个参数是Stream，要记得转换一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//     打印所有书籍的名字。要求对重复的元素进行去重。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()</span><br><span class="line">                .flatMap(<span class="keyword">new</span> Function&lt;Author, Stream&lt;? extends Book&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Stream&lt;? extends Book&gt; apply(Author author) &#123;</span><br><span class="line">                        <span class="keyword">return</span> author.getBooks().stream();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;) .distinct()</span><br><span class="line">                .forEach(book -&gt; System.out.println(book.getName()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//     打印所有书籍的名字。要求对重复的元素进行去重。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream()) .distinct()</span><br><span class="line">                .forEach(book -&gt; System.out.println(book.getName()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>​    设置一个返回的长度限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line">authors.stream()</span><br><span class="line">.distinct()</span><br><span class="line">.sorted()</span><br><span class="line">.limit(<span class="number">2</span>)</span><br><span class="line">.forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>​    跳过几个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line">authors.stream()</span><br><span class="line">.distinct()</span><br><span class="line">.sorted()</span><br><span class="line">.skip(<span class="number">1</span>)</span><br><span class="line">.forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h2 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h2><p>​    在前面流已经经过了一些列中间操作，对元素中的对象比如做了筛选过滤、去重、后者映射等等，现在已经有这些元素了，下面要对这些元素进行最终的输出，可以采用以下几种方式，最简单的遍历foreach（最常用的就是打印输出每个元素），count统计个数、max&amp;min计算值的最值、collect用于将元素转化为List输出或者合并字符串等等。</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()<span class="comment">//把集合转换成流</span></span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .forEach(authorName -&gt; System.out.println(authorName));<span class="comment">//遍历打印名字</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="max-amp-min"><a href="#max-amp-min" class="headerlink" title="max&amp;min"></a>max&amp;min</h3><p>​    可以用来或者流中的最值。 例子:</p><p>分别获取这些作家的所出书籍的最高分和最低分并打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">       Optional&lt;Integer&gt; max = authors.stream()</span><br><span class="line">               .flatMap(author -&gt; author.getBooks().stream()).map(book -&gt; book.getScore())</span><br><span class="line">               .max((score1, score2) -&gt; score1 - score2);</span><br><span class="line">       Optional&lt;Integer&gt; min = authors.stream().flatMap(author -&gt; author.getBooks().stream()).map(book -&gt; book.getScore())</span><br><span class="line">               .min((score1, score2) -&gt; score1 - score2);</span><br><span class="line">       System.out.println(max.get());</span><br><span class="line">       System.out.println(min.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>把当前流转换成一个集合。 例子:</p><p>获取一个存放所有作者名字的List集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        List&lt;String&gt; nameList = authors.stream()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(nameList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/edbbcd8252624fdb8d9deeabe964b722.png" alt="在这里插入图片描述"></p><p>这里还有个骚操作，可以转化为Map，设定好key和value分别是什么即可，类型可以自定义，依旧还是Function接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="comment">//        Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream().distinct()</span></span><br><span class="line"><span class="comment">//                .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getBooks()));</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = authors.stream().distinct()</span><br><span class="line">                .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getAge()));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查找与匹配</p><h3 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h3><p>可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。</p><p>例子: 判断是否有年龄在29以上的作家</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 判断是否有年龄在29以上的作家 </span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line"><span class="keyword">boolean</span> flag = authors.stream()</span><br><span class="line">.anyMatch(author -&gt; author.getAge() &gt; <span class="number">29</span>); </span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure><h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p>可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。 例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 判断是否所有的作家都是成年人 </span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line"><span class="keyword">boolean</span> flag = authors.stream()</span><br><span class="line">.allMatch(author -&gt; author.getAge() &gt;= <span class="number">18</span>); </span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure><h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p>可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false 例子:</p><p>判断作家是否都没有超过100岁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 判断作家是否都没有超过100岁的。 </span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="keyword">boolean</span> b = authors.stream()</span><br><span class="line">.noneMatch(author -&gt; author.getAge() &gt; <span class="number">100</span>);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><h3 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h3><p>​    获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p><p>例子：</p><p>​    获取任意一个年龄大于18的作家，如果存在就输出他的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        获取任意一个年龄大于18的作家，如果存在就输出他的名字</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Optional&lt;Author&gt; optionalAuthor = authors.stream()</span><br><span class="line">                .filter(author -&gt; author.getAge()&gt;<span class="number">18</span>)</span><br><span class="line">                .findAny();</span><br><span class="line"></span><br><span class="line">        optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p>​    获取流中的第一个元素。</p><p>例子：</p><p>​    获取一个年龄最小的作家，并输出他的姓名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        获取一个年龄最小的作家，并输出他的姓名。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Optional&lt;Author&gt; first = authors.stream()</span><br><span class="line">                .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())</span><br><span class="line">                .findFirst();</span><br><span class="line"></span><br><span class="line">        first.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="reduce归并"><a href="#reduce归并" class="headerlink" title="reduce归并"></a>reduce归并</h3><p>​    对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）</p><p>​    reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p><p>​    reduce两个参数的重载形式内部的计算方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T result = identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>​    其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。</p><p>例子：</p><p>​    使用reduce求所有作者年龄的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者年龄的和</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Integer sum = authors.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .reduce(<span class="number">0</span>, (result, element) -&gt; result + element);</span><br><span class="line">        System.out.println(sum);</span><br></pre></td></tr></table></figure><p>​    使用reduce求所有作者中年龄的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最大值</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Integer max = authors.stream()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .reduce(Integer.MIN_VALUE, (result, element) -&gt; result &lt; element ? element : result);</span><br><span class="line"></span><br><span class="line">        System.out.println(max);</span><br></pre></td></tr></table></figure><p>​    使用reduce求所有作者中年龄的最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最小值</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Integer min = authors.stream()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .reduce(Integer.MAX_VALUE, (result, element) -&gt; result &gt; element ? element : result);</span><br><span class="line">        System.out.println(min);</span><br></pre></td></tr></table></figure><p>​    reduce一个参数的重载形式内部的计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> foundAny = <span class="keyword">false</span>;</span><br><span class="line">  T result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (T element : <span class="keyword">this</span> stream) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">          foundAny = <span class="keyword">true</span>;</span><br><span class="line">          result = element;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          result = accumulator.apply(result, element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure><p>​    如果用一个参数的重载方法去求最小值代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最小值</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Optional&lt;Integer&gt; minOptional = authors.stream()</span><br><span class="line">        .map(author -&gt; author.getAge())</span><br><span class="line">        .reduce((result, element) -&gt; result &gt; element ? element : result);</span><br><span class="line">minOptional.ifPresent(age-&gt; System.out.println(age));</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）</li><li>流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）</li><li>不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）</li></ul><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>​    我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。</p><p>​    例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Author author = getAuthor();</span><br><span class="line"><span class="keyword">if</span>(author!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(author.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    尤其是对象中的属性还是一个对象的情况下。这种判断会更多。    </p><p>​    而过多的判断语句会让我们的代码显得臃肿不堪。</p><p>​    所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。</p><p>​    并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>​    Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。</p><p>​    我们一般使用<strong>Optional</strong>的<strong>静态方法ofNullable</strong>来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Author author = getAuthor();</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure><p>​    你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。</p><p>​    而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。</p><p>​    如果你<strong>确定一个对象不是空</strong>的则可以使用<strong>Optional</strong>的<strong>静态方法of</strong>来把数据封装成Optional对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Author author = <span class="keyword">new</span> Author();</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.of(author);</span><br></pre></td></tr></table></figure><p>​    但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果）</p><p>​    如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用<strong>Optional</strong>的<strong>静态方法empty</strong>来进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.empty()</span><br></pre></td></tr></table></figure><p>​    </p><p>​    所以最后你觉得哪种方式会更方便呢？<strong>ofNullable</strong></p><h3 id="安全消费值"><a href="#安全消费值" class="headerlink" title="安全消费值"></a>安全消费值</h3><p>​    我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其<strong>ifPresent</strong>方法对来消费其中的值。</p><p>​    这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。</p><p>​    例如,以下写法就优雅的避免了空指针异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"></span><br><span class="line">authorOptional.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><p>​    如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。</p><h3 id="安全获取值"><a href="#安全获取值" class="headerlink" title="安全获取值"></a>安全获取值</h3><p>​    如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。</p><ul><li><p>orElseGet</p><p>获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line">Author author1 = authorOptional.orElseGet(() -&gt; <span class="keyword">new</span> Author());</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>orElseThrow</p><p>获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Author author = authorOptional.orElseThrow((Supplier&lt;Throwable&gt;) () -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">"author为空"</span>));</span><br><span class="line">    System.out.println(author.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">    throwable.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>​    我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line">authorOptional.filter(author -&gt; author.getAge()&gt;<span class="number">100</span>).ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>​    我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，<strong>更推荐使用ifPresent方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (authorOptional.isPresent()) &#123;</span><br><span class="line">    System.out.println(authorOptional.get().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>​    Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。</p><p>例如我们想获取作家的书籍集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Author&gt; authorOptional = getAuthorOptional();</span><br><span class="line">    Optional&lt;List&lt;Book&gt;&gt; optionalBooks = authorOptional.map(author -&gt; author.getBooks());</span><br><span class="line">    optionalBooks.ifPresent(books -&gt; System.out.println(books));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数式编程（Lambda-amp-amp-Stream）&quot;&gt;&lt;a href=&quot;#函数式编程（Lambda-amp-amp-Stream）&quot; class=&quot;headerlink&quot; title=&quot;函数式编程（Lambda &amp;amp;&amp;amp; Stream）&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="lambda" scheme="https://ericzikun.github.io/tags/lambda/"/>
    
    <category term="Stream" scheme="https://ericzikun.github.io/tags/Stream/"/>
    
    <category term="函数式编程" scheme="https://ericzikun.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="匿名内部类" scheme="https://ericzikun.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java方法传参/值传递/引用传递</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep12-Java%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82-%E5%80%BC%E4%BC%A0%E9%80%92-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep12-Java%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82-%E5%80%BC%E4%BC%A0%E9%80%92-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2021-11-06T09:53:48.000Z</published>
    <updated>2021-11-28T02:21:15.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文主要讲解Java方法传参、值传递、引用传递，其中涉及到JVM的相关知识，最近弥补了这一块，发现理解很多问题都变得豁然开朗了，知其所以然！（JVM在我其他博客中有详细辨析）<br><img src="https://img-blog.csdnimg.cn/c67559137da140af82c20d0920c3864e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在刷力扣题目时，遇到这样一个问题，当我把一个变量传进dfs方法后，无论递归中如何对该变量赋值，最终都没有生效，今来探究其原因，说到底还是Java值传递、引用传递的问题：</p><h2 id="方法传参"><a href="#方法传参" class="headerlink" title="方法传参"></a>方法传参</h2><p>Java的方法传值，有基本数据类型以及引用类型两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;   <span class="comment">//基本类型</span></span><br><span class="line">String str = <span class="string">"hello"</span>;  <span class="comment">//引用类型</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/24ed132a8be844cfa527b15150f670fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这里num是基本类型，str是引用类型，str是引用类型，对于引用类型来说，它本质上保存的是一个地址，指向了 “hello”这个字符串。</p><p>再还要来理解一下赋值操作(=)的具体含义：</p><p>基本类型的赋值，是直接对其保存的值进行修改的，而引用类型的赋值，本质上是改变了它指向的对象而已，原来指向的对象并没有改变：</p><p><img src="https://img-blog.csdnimg.cn/21d8d07cb8e14ffaa2280222193241bb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>继续看方法的调用：</p><p>在方法中传参数时，实际上是进行了赋值操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">作者：Intopass</span><br><span class="line">链接：https:<span class="comment">//www.zhihu.com/question/31203609/answer/50992895</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line">第一个例子：基本类型</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(num); <span class="comment">// num 没有被改变</span></span><br><span class="line"></span><br><span class="line">第二个例子：没有提供改变自身方法的引用类型</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    text = <span class="string">"windows"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(str); <span class="comment">// str 也没有被改变</span></span><br><span class="line"></span><br><span class="line">第三个例子：提供了改变自身方法的引用类型</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder.append(<span class="string">"4"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 被改变了，变成了"iphone4"。</span></span><br><span class="line"></span><br><span class="line">第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder = <span class="keyword">new</span> StringBuilder(<span class="string">"ipad"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 没有被改变，还是 "iphone"。</span></span><br></pre></td></tr></table></figure><p>从JVM视角来看，所有的线程共享的区域是堆、元空间；每一个线程有独占的虚拟机栈、本地方法栈、程序计数器。那么对于传进参数的的这个方法，自然会加载到当前线程的虚拟机栈中，所以呢，对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更不用谈修改了。</p><p>当我们在方法内部去声明变量时(int i =0, Object obj = null)，仅仅是在栈(Stack)中加入了局部变量，并没有影响到堆(共享区域)。当我们外部new Object() 对象时，会在堆中开辟一段内存空间并初始化该对象实例，如果给这个对象赋值给方法内的obj局部变量时，仅仅只是把栈中的这个obj局部变量的地址指向改变了到了新new的Object而已。</p><p>总结：</p><ol><li>如果参数是<strong>基本类型</strong>，Java方法参数传递的是<strong>基本类型值的拷贝</strong>。</li><li>如果参数是<strong>引用类型</strong>，Java传递的是所引用的对象在堆中<strong>地址值的拷贝</strong></li></ol><p>所以如果想把某个对象传进方法，并且还想在方法内部修改它，则必须得调用这个对象自己的成员方法去修改，才能对堆上这个对象做实际的修改，如果只是赋值操作(=)，那么仅仅改变的是方法内局部变量的指向而已，并没有真正改变原来的对象值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;本文主要讲解Java方法传参、值传递、引用传递，其中涉及到JVM的相关知识，最近弥补了这一块，发现理解很多问题都变得豁然开朗了，知其所以然！</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
    <category term="值传递" scheme="https://ericzikun.github.io/tags/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    
    <category term="引用传递" scheme="https://ericzikun.github.io/tags/%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM【垃圾回收机制】</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-11-06T08:20:51.000Z</published>
    <updated>2021-11-06T08:22:58.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、JVM垃圾回收机制"><a href="#三、JVM垃圾回收机制" class="headerlink" title="三、JVM垃圾回收机制"></a>三、JVM垃圾回收机制</h1><h2 id="3-1-堆为什么要分成年轻代和老年代？"><a href="#3-1-堆为什么要分成年轻代和老年代？" class="headerlink" title="3.1 堆为什么要分成年轻代和老年代？"></a>3.1 堆为什么要分成年轻代和老年代？</h2><p><img src="https://img-blog.csdnimg.cn/90318ff2219b4046a6872637405b5965.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>因为年轻代和老年代不同的特点，需要采用不同的垃圾回收算法；</p><p>年轻代的对象，它的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法；</p><p>老年代的对象，它的特点是需要长期存活，所以需要另外一种垃圾回收算法 ；</p><p>所以需要分成两个区域来放不同的对象；</p><p><strong>1、绝大多数对象都是朝生夕灭的；</strong></p><p>如果一个区域中大多数对象都是朝生夕灭，那么把它们集中放在一起，每次回收时只关注如何保留少量存活对象，而不是去标记那些大量将要被回收的对象，就能以较低的代价回收到大量的空间；</p><p><strong>2、熬过越多次垃圾收集的对象就越难以回收；</strong></p><p>如果是需要长期存活的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用；</p><p><strong>3、JVM划分出新生代、老年代之后，垃圾收集器可以每次只回收其中某一个或者某些部分的区域 ，同时也有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；</strong></p><p>Minor GC/Young GC ：新生代收集 </p><p>Major GC/Old GC：老年代收集</p><p>Full GC：整堆收集，收集整个Java堆和元空间/方法区的垃圾收集；</p><p>Mixed GC：混合收集，收集整个新生代以及部分老年代的垃圾收集，目前只有G1收集器会有这种行为； </p><p>4、针对不同的区域对象存亡特征采用不同的垃圾收集算法：</p><p>（1）复制算法</p><p>（2）标记-清除算法</p><p>（3）标记-整理算法</p><h2 id="3-2-JVM堆的年轻代为什么要有两个Survivor区？"><a href="#3-2-JVM堆的年轻代为什么要有两个Survivor区？" class="headerlink" title="3.2 JVM堆的年轻代为什么要有两个Survivor区？"></a>3.2 JVM堆的年轻代为什么要有两个Survivor区？</h2><p><strong>1、如果没有Survivor区会怎么样？</strong></p><p>此时每触发一次Minor GC，就会把Eden区的对象复制到老年代，这样当老年代满了之后会触发Major Gc/Full GC(通常伴随着MinorGC)，比较耗时，所以必须有Survivor区；</p><blockquote><p>解释：</p><p>会比较频繁的出发Full GC，开销太大</p></blockquote><p><strong>2、如果只有1个Survivor区会怎么样？</strong>【导致内存碎片】</p><p>刚刚创建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中存活的对象就会被移动到Survivor区，下一次Eden满了的时候，此时进行Minor GC，Eden和Survivor各有一些存活对象，因为只有一个Survivor，所以Eden区第二次GC发现的存活对象也是放入唯一的一个Survivor区域中，但此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化问题，并且由于不连续的空间会导致再分配大对象的时候，由于没有连续的空间来分配，会导致提前垃圾回收；</p><p>如果将Survivor中的所有存活对象进行整理消除碎片，然后将所有的存活对象放入其中，这样做会降低效率；</p><p>如果把两个区域中的所有存活对象都复制转移到一个完全独立的空间中，也就是第二块Survivor中，这样就可以留出一块完全空着的Eden和Survivor了，下次GC的时候再重复这个流程，所以我们便要有两个Survivor区；</p><p><img src="https://img-blog.csdnimg.cn/8e18f9530d264d51868277c612a3c25f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：</p><p>如果只有一个Survivor区域，触发Minor GC后会有内存碎片问题的产生(内存不连续)，大大降低了效率</p><p>所以得有第二个Survivor区域来装要存活的对象，从而使得第一个Survivor空闲、Eden也空闲，保证了内存空间的连续性——需要2个Survivor区域的原因解析</p></blockquote><h2 id="3-3-Eden区与Survivor区的空间大小比值为什么默认是8-1-1？"><a href="#3-3-Eden区与Survivor区的空间大小比值为什么默认是8-1-1？" class="headerlink" title="3.3 Eden区与Survivor区的空间大小比值为什么默认是8:1:1？"></a>3.3 Eden区与Survivor区的空间大小比值为什么默认是8:1:1？</h2><p>一个eden区 ，新生代对象出生的地方；</p><p>两个survivor区，一个用来保存上次新生代GC存活下来的对象，还有一个空着，在新生代GC时把eden+survivor中存活对象复制到这个空的survivor中；</p><p>统计和经验表明，<strong>90%的对象朝生夕死存活时间极短</strong> ，每次gc会有90%对象被回收，剩下的10%要预留一个survivor空间去保存； </p><blockquote><p>解释</p><p>8：1：1原因在于每次gc会有90%的对象被回收 ，这是个统计的结果</p></blockquote><h2 id="3-4-请介绍下JVM中的垃圾回收算法？"><a href="#3-4-请介绍下JVM中的垃圾回收算法？" class="headerlink" title="3.4 请介绍下JVM中的垃圾回收算法？"></a>3.4 请介绍下JVM中的垃圾回收算法？</h2><p><img src="https://img-blog.csdnimg.cn/457179f481b940119c2e236eaed29b5b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-4-1-标记-清除算法"><a href="#3-4-1-标记-清除算法" class="headerlink" title="3.4.1 标记-清除算法"></a>3.4.1 标记-清除算法</h3><p>标记-清除算法是最基础的收集算法，后续的很多垃圾回收算法是基于该算法而发展出来的，它分为‘ 标记 ’和‘ 清除 ’两个阶段；</p><p><strong>1、标记</strong></p><p>标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记出所有存活的对象，在标记完成后，统一回收所有未被标记的对象，标记过程就是对象是否属于垃圾的判定过程，基于可达性分析算法判断对象是否可以回收；</p><p><strong>2、清除</strong></p><p>标记后，对所有被标记的对象进行回收；</p><p>该算法如下图所示：</p><p>会发现回收后，内存空间就不连续了，有内存碎片<br><img src="https://img-blog.csdnimg.cn/28fa94791cfc4ff18e7a928008ef8243.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>优点：</strong></p><p>基于最基础的可达性分析算法，实现简单，后续的收集算法都是基于这种思想实现的；</p><p><strong>缺点：</strong></p><p>1、执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</p><p>2、内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集；</p><h3 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2 复制算法"></a>3.4.2 复制算法</h3><p>复制算法是标记-复制算法的简称，将可用内存按容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活的对象复制到另外一块内存上，然后再把已使用过的内存空间一次清理掉；</p><p><img src="https://img-blog.csdnimg.cn/4cc321ebb7484b3d8d35e09eba1e4b7c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>优点：</strong></p><p>实现简单，效率高，解决了标记-清除算法<strong>导致的内存碎片问题</strong>；</p><p><strong>缺点：</strong></p><p>1、代价太大，将可分配内存缩小了一半，<strong>空间浪费太多</strong>了；</p><p>2、对象存活率较高时就要进行较多的复制操作，效率将会降低；</p><h3 id="3-4-3-标记-整理算法"><a href="#3-4-3-标记-整理算法" class="headerlink" title="3.4.3 标记-整理算法"></a>3.4.3 标记-整理算法</h3><p>标记-整理算法是根据<strong>老年代</strong>的特点而产生的； </p><p><strong>1、标记</strong></p><p>标记过程与上面的标记-清理算法一致，也是基于可达性分析算法进行标记；</p><p><strong>2、整理</strong></p><p>和标记-清理不同的是，该算法不是针对可回收对象进行清理，而是根据存活对象进行整理，让存活对象都向一端移动，然后直接清理掉边界以外的内存；</p><p>而<strong>标记-清除算法</strong>不移动存活对象，导致有大量不连续空间，即内存碎片，而老年代这种每次回收都有大量存活对象的区域，移动存活对象并更新所有引用这些对象的引用，这是一种比较耗时的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，像这样的停顿我们也称为“Stop The World”即STW；</p><p>但是即便是移动存活对象是耗时的操作，但是如果不这么做，那么在充满内存碎片的空间中分配对象，又影响了对象的分配和访问的效率，所以JVM权衡两者之后，还是采用了<strong>移动存活对象的方式，也就是对内存进行了整理</strong>；</p><p>另外像cms垃圾收集器，平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间，所以像基于标记-清除算法的CMS收集器面临空间碎片过多时就会进行一次整理； </p><p><strong>优点：</strong></p><p>1、不会像复制算法那样划分两个区域，提高了空间利用率；</p><p>2、不会产生不连续的内存碎片；</p><p><strong>缺点：</strong></p><p>效率问题，除了像标记-清除算法的标记过程外，还多了一步整理过程，效率变低；</p><p>如下图所示：<br><img src="https://img-blog.csdnimg.cn/a551f71a551a48a9acd916a83ce47c39.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-4-4-分代收集算法"><a href="#3-4-4-分代收集算法" class="headerlink" title="3.4.4 分代收集算法"></a>3.4.4 分代收集算法</h3><p>现在一般虚拟机的垃圾收集都是采用“ <strong>分代收集</strong> ”算法；</p><p>根据对象存活周期的不同将内存划分为几块，一般把java堆分为<strong>新生代和老年代</strong>，JVM根据各个年代的特点采用不同的收集算法；</p><p>新生代中，每次进行垃圾回收都会发现大量对象死去，只有少量存活，因此采用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集；——只需要复制少于10%的对象，效率很高！</p><p>老年代中，因为对象存活率较高，采用<strong>标记-清理、标记-整理</strong>算法来进行回收；</p><h2 id="3-5-请介绍一下JVM垃圾收集器？"><a href="#3-5-请介绍一下JVM垃圾收集器？" class="headerlink" title="3.5 请介绍一下JVM垃圾收集器？"></a>3.5 请介绍一下JVM垃圾收集器？</h2><p><img src="https://img-blog.csdnimg.cn/083fe79ca2af48a9a0ff6d3df1576daf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如上图，一共有7种作用于不同分代的垃圾收集器，如果两个收集器之间存在连线，则说明它们可以搭配使用，垃圾收集器所处区域表示它是属于新生代收集器还是老年代收集器；</p><p>新生代收集器：Serial、ParNew、Parallel Scavenge [ˈpærəlel] [ˈskævɪndʒ] </p><p>老年代收集器：CMS、Serial Old、Parallel Old</p><p>整堆收集器： G1</p><p>垃圾收集器的最前沿成果：ZGC（Jdk11中引入了） 和 Shenandoah（Open JDK12，Oracle没引入，很前沿 ）</p><blockquote><p>解释：</p><p>目前在生产环境中，G1是比较先进的垃圾收集器了</p></blockquote><h3 id="3-5-1-Serial收集器-新生代、单线程"><a href="#3-5-1-Serial收集器-新生代、单线程" class="headerlink" title="3.5.1 Serial收集器[新生代、单线程]"></a>3.5.1 Serial收集器[新生代、单线程]</h3><p>新生代收集器，最早的收集器，单线程的，收集时需暂停用户线程的工作，所以有卡顿现象，效率不高，致使java语言的开发团队一直在改进垃圾收集器的算法和实现，但Serial收集器<strong>简单</strong>，不会有线程切换的开销，是Client模式下默认的垃圾收集器，-client， -server；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数： -XX:+UseSerialGC</span><br><span class="line"></span><br><span class="line">java -XX:+PrintFlagsFinal -version 打印jvm默认的参数值；</span><br></pre></td></tr></table></figure><p>垃圾收集时间线如下：</p><p>所有线程卡住（停下来），进行垃圾收集，收集完毕，然后再继续…<br><img src="https://img-blog.csdnimg.cn/e5e1db8a41cd4a6798c87112495fb211.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-5-2-ParNew收集器-新生代、多线程"><a href="#3-5-2-ParNew收集器-新生代、多线程" class="headerlink" title="3.5.2 ParNew收集器[新生代、多线程]"></a>3.5.2 ParNew收集器[新生代、多线程]</h3><p>它是新生代收集器，就是<strong>Serial收集器的多线程版本</strong>，大部分基本一样，单CPU下，ParNew还需要切换线程，可能还不如Serial；</p><p>Serial和ParNew收集器可以配合CMS收集器，前者收集新生代，后者CMS收集老年代，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;-XX:+UseConcMarkSweepGC&quot;：指定使用CMS后，会默认使用ParNew作为新生代垃圾收集器；</span><br><span class="line">&quot;-XX:+UseParNewGC&quot;：强制指定使用ParNew；</span><br><span class="line">&quot;-XX:ParallelGCThreads&#x3D;2&quot;：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b9fab178b75e4d64ae51fdf65ee5874b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-5-3-Parallel-Scavenge收集器【新生代、多线程】"><a href="#3-5-3-Parallel-Scavenge收集器【新生代、多线程】" class="headerlink" title="3.5.3 Parallel Scavenge收集器【新生代、多线程】"></a>3.5.3 Parallel Scavenge收集器【新生代、多线程】</h3><p> <img src="https://img-blog.csdnimg.cn/628f0c5d16144edb9bdffc4296e5da31.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>简称Parallel，它是新生代收集器，基于<strong>复制算法</strong>，并行的多线程收集器（与ParNew收集器类似），侧重于达到一个可控的吞吐量，虚拟机运行100分钟，垃圾收集花1分钟，则吞吐量为99%，有时候我们也把该垃圾收集器叫吞吐量垃圾收集器或者是吞吐量优先的垃圾收集器；而且这个垃圾收集器是jvm默认的新生代的垃圾收集器；</p><p>它提供一个<strong>参数设置吞吐量：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis 该参数设置大于0的毫秒数，每次GC的时间将尽量保持不超过设置的值，但是这个值也不是设置得越小就越好，GC暂停时间越短，那么GC的次数会变得更频繁；</span><br><span class="line"></span><br><span class="line">-XX:+UseAdaptiveSizePolicy 自适应新生代大小策略，默认这个参数是开启的，当这个参数被开启之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间获得最大的吞吐量，这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）；</span><br></pre></td></tr></table></figure><p>如果我们不知道怎么对jvm调优，我们可以使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用-XX:MaxGCPauseMillis参数（最大停顿时间）给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成，自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">参数：-XX:+UseParallelGC 指定使用Parallel Scavenge垃圾收集器</span><br><span class="line"></span><br><span class="line">java -XX:+PrintCommandLineFlags -version 打印jvm默认初始堆和最大堆大小以及垃圾收集器</span><br><span class="line"></span><br><span class="line">java -XX:+PrintFlagsFinal -version 打印jvm所有的默认的参数值；</span><br><span class="line"></span><br><span class="line">-XX:+ </span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"></span><br><span class="line">-Xloggc:d:&#x2F;dev&#x2F;gc.log</span><br><span class="line"></span><br><span class="line">Parallel Scavenge垃圾收集器中的Ergonomics负责自动的调节gc暂停时间和吞吐量之间的平衡，自动优化虚拟机的性能；</span><br></pre></td></tr></table></figure><h3 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h3><p>这里常用一下JVM参数打印JVM的log:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:d:&#x2F;dev&#x2F;gc.log</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/470dfa56725548239ab8499dea1414f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三、JVM垃圾回收机制&quot;&gt;&lt;a href=&quot;#三、JVM垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;三、JVM垃圾回收机制&quot;&gt;&lt;/a&gt;三、JVM垃圾回收机制&lt;/h1&gt;&lt;h2 id=&quot;3-1-堆为什么要分成年轻代和老年代？&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="JAVA虚拟机" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM【内存管理】</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-11-06T08:18:50.000Z</published>
    <updated>2021-11-06T08:27:55.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、深入剖析JVM内存管理"><a href="#二、深入剖析JVM内存管理" class="headerlink" title="二、深入剖析JVM内存管理"></a>二、深入剖析JVM内存管理</h1><h2 id="2-1-Java代码到底是如何运行起来的？"><a href="#2-1-Java代码到底是如何运行起来的？" class="headerlink" title="2.1 Java代码到底是如何运行起来的？"></a>2.1 Java代码到底是如何运行起来的？</h2><p>1、Mall.java –&gt;javac –&gt; Mall.class –&gt; java Mall (jvm进程，也就是一个jvm虚拟机)</p><p>2、Mall.java –&gt;javac–&gt;Mall.class –&gt;Mall.jar –&gt; java -jar Mall.jar</p><p>3、Mall.java –&gt; javac –&gt; Mall.class –&gt;Mall.war –&gt; Tomcat –&gt; startup.sh –&gt; org.apache.catalina.startup.Bootstrap (jvm进程，也就是一个jvm虚拟机)</p><p>其实运行起来一个Java程序，都是通过D:\dev\Java\jdk1.8.0_251\bin\java 启动一个JVM虚拟机，在虚拟机里面运行Mall.class字节码文件；</p><p><img src="https://img-blog.csdnimg.cn/ea7c556c03de419baba584e11e510a2c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>总结：</p><p>java源文件通过javac命令转成java字节码文件，再通过java命令运行起来，JVM是用于屏蔽掉底层操作系统之间的差异，这里不同操作系统所装载的jdk是不同的，jdk中包含jvm</p></blockquote><blockquote><p>这里面的其他语言，如Groovy、Scala、Kotlin也是编译后为字节码，再通过JVM虚拟机处理。</p></blockquote><h2 id="2-2画一下JVM整个运行原理图？☆"><a href="#2-2画一下JVM整个运行原理图？☆" class="headerlink" title="2.2画一下JVM整个运行原理图？☆"></a>2.2画一下JVM整个运行原理图？☆</h2><p><img src="https://img-blog.csdnimg.cn/10d2679aef014bd0a5e2b8b5f1feacf7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-3-请介绍一下JVM的内存结构划分？"><a href="#2-3-请介绍一下JVM的内存结构划分？" class="headerlink" title="2.3 请介绍一下JVM的内存结构划分？"></a>2.3 请介绍一下JVM的内存结构划分？</h2><p>加载进来的.class字节码文件、代码执行创建的对象、代码执行调用方法，方法中有变量等数据需要一个地方存放，所以JVM划分出了几个区域，用于存放这些信息；<strong>hotspot</strong></p><p><img src="https://img-blog.csdnimg.cn/466092a41d3c4dd2999cc6cb69532305.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在JDK1.8之前，元空间就是原来的方法区（永久代）；</p><p>比如new User(),那么User这个变量在虚拟机栈中存储为局部变量，但是其值是在堆中存储的</p><p>程序计数器：表明代码执行到哪一行</p><p>当类加载后，Class文件首先会存储在元空间中，然后运行时才会涉及其他几个空间部分</p><h2 id="2-4-JVM哪些区域是线程私有的，哪些区域是线程共享的？☆"><a href="#2-4-JVM哪些区域是线程私有的，哪些区域是线程共享的？☆" class="headerlink" title="2.4 JVM哪些区域是线程私有的，哪些区域是线程共享的？☆"></a>2.4 JVM哪些区域是线程私有的，哪些区域是线程共享的？☆</h2><p>1、堆、元空间（方法区）是线程共享的；</p><p>2、其他区域是线程私有的；</p><p><img src="https://img-blog.csdnimg.cn/228fe4ea721744d88c221a55e4e2abaf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>线程私有的区域如虚拟机栈、本地方法栈、程序计数器，这些就不存在线程安全的问题，每个线程之间这些区域是隔离的，不共享变量，就不会导致冲突，没有安全问题</p><p>举例：两个线程对应就有两个虚拟机栈，一一对应。无论有几个线程，堆和元空间都是公用的一个</p><h2 id="2-5-从JVM角度剖析如下程序代码如何执行？"><a href="#2-5-从JVM角度剖析如下程序代码如何执行？" class="headerlink" title="2.5 从JVM角度剖析如下程序代码如何执行？"></a>2.5 从JVM角度剖析如下程序代码如何执行？</h2><p><img src="https://img-blog.csdnimg.cn/1172c5acc584401a90768850e3949891.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bf9aba7b51174d7db44c430b12949155.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>Config类在new的时候，对象存在堆中，该类的信息是在元空间里的</p><h2 id="2-6-JVM运行时数据区-程序计数器-的特点及作用？"><a href="#2-6-JVM运行时数据区-程序计数器-的特点及作用？" class="headerlink" title="2.6 JVM运行时数据区 程序计数器 的特点及作用？"></a>2.6 JVM运行时数据区 程序计数器 的特点及作用？</h2><p>1、程序计数器是一块较小的内存空间，几乎可以忽略；</p><p>2、是当前线程所执行的字节码的行号指示器；</p><p>3、Java多线程执行时，每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响；</p><p>4、该区域是“线程私有”的内存，每个线程独立存储； </p><p>5、该区域不存在OutOfMemoryError；</p><p>6、无GC回收；</p><blockquote><p>总结：程序计数器是在线程产生的时候存在，在线程结束（销毁时候）消失，不需要垃圾回收（GC）</p></blockquote><h2 id="2-7-JVM运行时数据区-虚拟机栈的特点及作用？"><a href="#2-7-JVM运行时数据区-虚拟机栈的特点及作用？" class="headerlink" title="2.7 JVM运行时数据区 虚拟机栈的特点及作用？"></a>2.7 JVM运行时数据区 虚拟机栈的特点及作用？</h2><p>1、线程私有；</p><p>2、方法执行会创建栈帧，存储局部变量表等信息；</p><p>3、方法执行入虚拟机栈，方法执行完出虚拟机栈；（先进后出）</p><p>4、<strong>【深度过长】</strong> 栈深度大于虚拟机所允许StackOverflowError；</p><p>5、栈需扩展而无法申请空间OutOfMemoryError（比较少见）；hotspot虚拟机没有；</p><p>6、栈里面运行方法，存放方法的局部变量名，变量名所指向的值（常量值、对象值等）都存放到堆上的；</p><p>7、栈一般都不设置大小，栈所占的空间其实很小，可以通过-Xss1M进行设置，如果不设置默认为1M；</p><p>8、随线程而生，随线程而灭；</p><p>9、该区域不会有GC回收；</p><blockquote><p>解释：OutOfMemoryError一般少见，比如写个死循环不断的创建线程，当创建到一定程度，无法再继续给空间到新线程时，每个线程都会生成一个线程栈，每个线程栈会占用一定的内存区域，从而导致超出，会把会报此错误。</p></blockquote><p>如下，死循环中不断创建新的线程，而每个线程又不会结束，即不会销毁，从而导致大量内存占用。</p><p><img src="https://img-blog.csdnimg.cn/a8ca94b2a86543fb8012424b55060d55.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：递归调用时，有时会出现StackOverflowError，如下案例：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/174e439c54294adea990c98bfbde932a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输出结果：</p><p>解释栈大小设置：</p><p>一般1M足够大了，往往会将其设置小一点，在idea中添加JVM配置，默认是1M，也可以改为128k：</p><p><img src="https://img-blog.csdnimg.cn/14673c4fc962481b9436f76ea64bf89c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>改了栈大小之后，原来的栈深度35710就会减小，再报Stack Overflow：</p><p>相当于把栈变小了，压的栈就会相应变少。</p><p><img src="https://img-blog.csdnimg.cn/e43dc936d5ea4f598def559d401bf24f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>总结：实际项目中，一般也不会递归调用太多次，1M的话，调用个3w多次肯定是够用的！所以改小一点是有好处的，改小一点反而可以启动更多线程，比如原本10M的内存空间可以创建10个1M的线程，那么把栈大小改小后，线程所占用的内存空间就变小了，从而使得线程数量变多</p></blockquote><h2 id="2-8-JVM运行时数据区-本地方法栈的特点及作用？"><a href="#2-8-JVM运行时数据区-本地方法栈的特点及作用？" class="headerlink" title="2.8 JVM运行时数据区 本地方法栈的特点及作用？"></a>2.8 JVM运行时数据区 本地方法栈的特点及作用？</h2><p>1、与虚拟机栈基本类似；</p><p>2、区别在于本地方法栈为Native方法服务；</p><p>3、HotSpot虚拟机将虚拟机栈和本地方法栈合并；</p><p>4、有StackOverflowError和OutOfMemoryError（比较少见）；</p><p>5、随线程而生，随线程而灭；</p><p>6、GC不会回收该区域；</p><p><strong>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；</strong></p><p>解释：本地方法栈和虚拟机栈类似，只不过存储的是Native方法，也就是底层由C++写的方法；而HotSpot是把虚拟机栈和本地方法栈合并到一起了！</p><p><img src="https://img-blog.csdnimg.cn/0ec3e41627be41b5ab41cc45f81115da.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-9-JVM运行时数据区-Java堆的特点及作用？☆"><a href="#2-9-JVM运行时数据区-Java堆的特点及作用？☆" class="headerlink" title="2.9 JVM运行时数据区 Java堆的特点及作用？☆"></a>2.9 JVM运行时数据区 Java堆的特点及作用？☆</h2><p>1、线程共享的一块区域；</p><p>2、虚拟机启动时创建；</p><p>3、虚拟机所管理的内存中<strong>最大的一块区域</strong>；</p><p>4、存放所有实例<strong>对象或数组</strong>；</p><p>5、GC垃圾收集器的主要管理区域；</p><p>6、可分为新生代、老年代；</p><p>7、新生代更细化可分为Eden、From Survivor、To Survivor，Eden:Survivor = 8:1:1</p><p>8、可通过<strong>-Xmx、-Xms</strong>调节堆大小；</p><p>9、无法再扩展<strong>java.lang.OutOfMemoryError: Java heap space</strong></p><p>10、<strong>【TLAB】</strong> 如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率；</p><blockquote><p>解释：堆的年代划分</p></blockquote><p><img src="https://img-blog.csdnimg.cn/99db4806553041eeadea59a7c1e0f024.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：堆内存不足了，就会OOM，java.lang.OutOfMemoryError: Java heap space 堆溢出</p></blockquote><p><img src="https://img-blog.csdnimg.cn/11b3fa8d4f544029b771362463d76e2d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输出结果：</p><p><img src="https://img-blog.csdnimg.cn/62e1f4b03635406f8e4f1ab69e81b7dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果改一下堆大小：<br><img src="https://img-blog.csdnimg.cn/55c7019bb71d4f6fb6d34e3e6da04ba7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/56c5710d4e924a89be55af07bc438056.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：TLAB：</p><p>因为堆是共享区域，所以当多个线程往堆里面放内容时，会产生一个竞争关系、冲突问题，那么最朴素的想法就是用锁去解决这个线程安全问题，但是用锁呢，又会导致效率比较低，所以干脆给每个线程一个默认区域，区域不大，但是供每个线程各自去放内容，也就是给每个线程分配了一个较小的缓冲区，当把缓冲区放满后，再去公共区放数据！</p></blockquote><h2 id="2-10-JVM中对象如何在堆内存分配？"><a href="#2-10-JVM中对象如何在堆内存分配？" class="headerlink" title="2.10 JVM中对象如何在堆内存分配？"></a>2.10 JVM中对象如何在堆内存分配？</h2><p>1、<strong>指针碰撞（Bump The Pointer）</strong>：内存规整的情况下；</p><p>2、<strong>空闲列表（Free List）</strong>：内存不规整的情况下；</p><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定；</p><p>因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；</p><p>而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存；</p><p>3、<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB）：对象创建在虚拟机中频繁发生，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况；</p><p>那么解决方案有两种：</p><p>（1）同步锁定，JVM是采用CAS配上失败重试的方式保证更新操作的原子性； </p><p>（2）线程隔离，把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定，虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定； </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:TLABSize&#x3D;512k 设置大小；</span><br></pre></td></tr></table></figure><blockquote><p>解释：指针碰撞：</p><p>当内存排列规整的时候，指针不断向右遍历，依次排列对象</p></blockquote><p><img src="https://img-blog.csdnimg.cn/d7dbb10ca5f1438d9ae5fcf9b7f9ae56.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>空闲列表:<br>和指针碰撞不同，该方式的内存排列不规整，有一个空闲列表去记录哪些区域是空闲的，那么当存储时去找对应的空闲内存进行存储</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c4819cc4f5e644a1a47bf5b28f035f7d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：具体用哪种方式，这个是根据垃圾回收器的空，间压缩整理能力来决定的，如果GC每次回收完后，将空内存排列的规整，那么就用指针碰撞</p></blockquote><p>一些JVM可以配置的参数：<br><img src="https://img-blog.csdnimg.cn/c1323e7f99184687868394628184dd0b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-11-JVM堆内存中的对象布局？"><a href="#2-11-JVM堆内存中的对象布局？" class="headerlink" title="2.11 JVM堆内存中的对象布局？"></a>2.11 JVM堆内存中的对象布局？</h2><p>在 HotSpot 虚拟机中，一个对象的存储结构分为3块区域：</p><p>对象头(Header)、实例数据(Instance Data) 和 对齐填充(Padding)；</p><ul><li>对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit，官方称为 ‘Mark Word’；<br><img src="https://img-blog.csdnimg.cn/0d8739fc506f4542ad2ce640f76bdfc8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例，另外，如果是Java数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以；</li></ul><ul><li>实例数据(Instance Data)：程序代码中所定义的各种成员变量类型的字段内容(包含父类继承下来的和子类中定义的)；</li></ul><ul><li>对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍，HotSpot虚拟机，任何对象的大小都是8字节的整数倍；</li></ul><h2 id="2-12-JVM什么情况下会发生堆内存溢出？☆"><a href="#2-12-JVM什么情况下会发生堆内存溢出？☆" class="headerlink" title="2.12 JVM什么情况下会发生堆内存溢出？☆"></a>2.12 JVM什么情况下会发生堆内存溢出？☆</h2><p>Java堆中用于储存对象，只要不断地创建对象，并且保持<strong>GC Roots</strong>到对象之间有可达路径 </p><p>来避免垃圾回收机制清理这些对象，那么随着对象数量的增加，总容量达到最大堆的容量限制后就会产生内存溢出；</p><p>MAT工具分析xxx.hprof文件(相当于一个内存log)，排查溢出的原因；   </p><p>添加JVM参数 输出hprof文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath&#x3D;d:&#x2F;dev&#x2F;heapdump.hprof</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c59c2b4e6da54e2aac354e8fb56fab74.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b607a62acc6548faa40bcfa3a789a594.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>利用Eclipse的MAT工具来分析文件：</p><p>官网即可下载，open file，生成怀疑报告Leak suspects</p><p><img src="https://img-blog.csdnimg.cn/9560b3184aa747ae8e5a09b7e5e7e603.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-Xms3072M</span><br><span class="line"></span><br><span class="line">-Xmx3072M</span><br><span class="line"></span><br><span class="line">-Xmn1536M</span><br><span class="line"></span><br><span class="line">-Xss1M</span><br><span class="line"></span><br><span class="line">-XX:-UseCompressedClassPointers</span><br><span class="line"></span><br><span class="line">-XX:MetaspaceSize&#x3D;256M</span><br><span class="line"></span><br><span class="line">-XX:MaxMetaspaceSize&#x3D;256M</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio&#x3D;8</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;5</span><br><span class="line"></span><br><span class="line">-XX:PretenureSizeThreshold&#x3D;1M</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"></span><br><span class="line">-Xloggc:d:&#x2F;dev&#x2F;gc.log</span><br><span class="line"></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath&#x3D;d:&#x2F;dev&#x2F;heapdump.hprof</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/69ca5ae04bbb48f08da1850d89ffe88b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：Java堆中用于储存对象，只要不断地创建对象，并且保持<strong>GC Roots</strong>到对象之间有可达路径 </p><p>比如这里的orderList是一个GC root根，然后引用了new ArrayList<Order>()这个List对象地址，然后这个List对象又在循环中，不断的去引用到了order对象，由于对象一直在创建，所以就能保持GC Roots到对象之间有可达路径!</p><p>如果这个List对象引用断了，那么就会将剩余的进行垃圾回收，从而不会导致堆内存溢出，也就是说，该List对象不再被引用了，就可以销毁了(被GC回收)，从而就不会占用堆内存了</p></blockquote><p><img src="https://img-blog.csdnimg.cn/92b64722c1e3442d9ac310556327beed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>验证猜想：</p></blockquote><p>如果将order的引用注释掉：</p><p>这样一来，虽然orderList还是指向了堆内存中的List对象，但是List对象没有去引用新生成的order对象，导致order对象由于没有被引用，就会被GC回收，这样就不会导致堆内存溢出了.<br><img src="https://img-blog.csdnimg.cn/dcc1a44ff47a4892b9faf570372e05e4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以通过visualVM软件来可视化堆内存中对象的变化过程：</p><p>可以看出黄色的是每一个对象新生和销毁的过程，顶峰代表出生，下降到0代表销毁，所以就可以一直跑，不会堆溢出.<br><img src="https://img-blog.csdnimg.cn/248986e276794e50b98d0df6717a118c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对比溢出的情况：<br><img src="https://img-blog.csdnimg.cn/fdb13d45941348649229f5280c364b09.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>New区域不断的增加，到顶后，Old再累积</p><h2 id="2-13-JVM如何判断对象可以被回收？"><a href="#2-13-JVM如何判断对象可以被回收？" class="headerlink" title="2.13 JVM如何判断对象可以被回收？"></a>2.13 JVM如何判断对象可以被回收？</h2><p>在JVM堆里面存放着所有的Java对象，垃圾收集器在对堆进行回收前，首先要确定这些对象之中哪些还“存活”着，哪些已经“死去”；</p><p>Java通过 <strong>可达性分析（Reachability Analysis）</strong> 算法 来判定对象是否存活的；</p><p>该算法的基本思路：通过一系列称为“GC Roots”的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连（也称为不可达），则证明此对象是不可能再被使用的对象，就可以被垃圾回收器回收；<br><img src="https://img-blog.csdnimg.cn/e230558cf0b642d3a458ae89b8b7a670.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对象object 5、object 6、object 7虽然有关联，但它们到GC Roots是不可达的，所以它们将会被判定为可回收的对象；</p><p><strong>哪些对象可以作为GC Roots呢？</strong> </p><p>1、在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等所引用的对象；</p><p>2、方法区/元空间中的类静态属性引用的对象；</p><p>3、方法区/元空间中的常量引用的对象；</p><p>4、在本地方法栈中JNI（即通常所说的Native方法）引用的对象； </p><p>5、Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 </p><p>NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器；</p><p>6、所有被同步锁（synchronized关键字）持有的对象；</p><p>7、反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等； </p><p>8、其他可能临时性加入的对象；</p><blockquote><p>总结：一般我们最常见的就是虚拟机栈中的局部变量引用的对象、临时变量，作为GC Root。</p></blockquote><h2 id="2-14-谈谈Java中不同的引用类型？"><a href="#2-14-谈谈Java中不同的引用类型？" class="headerlink" title="2.14 谈谈Java中不同的引用类型？"></a>2.14 谈谈Java中不同的引用类型？</h2><p>Java里有不同的引用类型，分别是强引用、软引用、弱引用 和 虚引用；</p><p>强引用：Object object = new Object(）;</p><p>软引用：SoftReference 内存充足时不回收，内存不足时则回收；</p><p>弱引用：WeakReference 不管内存是否充足，只要GC一运行就会回收该引用对象；</p><p>虚引用：PhantomReference这个其实暂时忽略也行，因为很少用，它形同虚设，就像没有引用一样，其作用就是该引用对象被GC回收时候触发一个系统通知，或者触发进一步的处理；</p><blockquote><p>解释：</p><p>强引用【大多用】，因为有变量指向对象，只要引用没有释放，即便是内存不足、溢出了，也不能回收这个引用</p><p>软引用【缓存用】，要看内存足不足，弱引用，一般用于缓存领域(内存充足就缓存起来，内存不足就清空缓存，比如mybatis中就用到过)</p><p>弱引用【很少用】：比如类库ThreadLocal用到过</p><p>虚引用【很少用】</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">References</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//强引用</span></span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//软引用</span></span><br><span class="line">        SoftReference softReference = <span class="keyword">new</span> SoftReference(object);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//弱引用</span></span><br><span class="line">        WeakReference weakReference = <span class="keyword">new</span> WeakReference(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-15-JVM堆内存分代模型？"><a href="#2-15-JVM堆内存分代模型？" class="headerlink" title="2.15 JVM堆内存分代模型？"></a>2.15 JVM堆内存分代模型？</h2><p>JVM堆内存的分代模型：年轻代、老年代；</p><p>大部分对象朝生夕死，少数对象长期存活；</p><p><img src="https://img-blog.csdnimg.cn/6814a9e209ec4beebc5c7b4f595071d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>From Survivor区也叫S0区，To Survivor 也叫S1区</p><p>大小也可以通过参数去调整</p><h2 id="2-16-JVM堆中新生代的垃圾回收过程？☆☆☆☆"><a href="#2-16-JVM堆中新生代的垃圾回收过程？☆☆☆☆" class="headerlink" title="2.16 JVM堆中新生代的垃圾回收过程？☆☆☆☆"></a>2.16 JVM堆中新生代的垃圾回收过程？☆☆☆☆</h2><p><img src="https://img-blog.csdnimg.cn/bc2645bcf46742fe81a85eb407c70c24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>JVM里垃圾回收针对的是 <strong>新生代，老年代，还有元空间/方法区（永久代）</strong>，</p><p>不会针对方法的栈帧进行回收，方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存里清理掉，也就是<strong>虚拟机栈不存在垃圾回收</strong>；</p><p>代码里创建出来的对象，一般就是两种：</p><p>1、一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收；</p><p>2、一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停的去使用；</p><p>第一种短期存活的对象，是在Java堆内存的新生代里分配；</p><p>第二种长期存活的对象，通过在新生代S0区和S1区来回被垃圾回收15次后，进入Java堆内存的老年代中，这里的15次，我们也称为对象的年龄，即对象的年龄为15岁；</p><p>java -XX:+PrintFlagsFinal 打印jvm默认参数值；</p><blockquote><p>总结：<strong>垃圾回收针对的是堆和元空间</strong></p></blockquote><p><strong>过程详解：</strong></p><p>新创建的对象先进Eden空间，满了后，再就触发Minor GC就会去回收Eden区域里面的对象，这里面有些需要存活、有些需要回收，先把要存活的移到From Survivor区域，把要回收的对象清除掉。<br><img src="https://img-blog.csdnimg.cn/870f4346c35c43068d98a8f2ab22194b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第二轮：当Eden区域第二次再满的时候，这时又要出发Minor GC，这时候处理回收的就是Eden和S0两个区域的对象了</p><p>先将不能回收的对象移到S1区域，把要回收的对象清空掉，此时Eden区域空闲了。<br><img src="https://img-blog.csdnimg.cn/18ee3ee769424e268e2d65fa5ad9163a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后再处理S0区域中的对象，把要回收的清除，要存活的移到S1区域。<br><img src="https://img-blog.csdnimg.cn/1094d8f91e724c72b2bab0d1659a4d2b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3f6349966c7b44a6a71263e21297d05f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第三轮：当Eden区域再次满载状态时，再次触发Minor GC，这时处理的就是已满的Eden以及S1区域，先处理Eden：将回收的清除，需要存活的移至S0，针对S1区域做同理操作。<br><img src="https://img-blog.csdnimg.cn/7baf9572459f44568b4f5e697b067125.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4d5adeb8062b4b7eb384c5c2e5f883a2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后再回收S1区域的对象，其中不能回收的移到S0区域，要回收的清除掉。<br><img src="https://img-blog.csdnimg.cn/5cf03084c84740008af73897fa365c3f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">如此，循环往复，已存在于S0、S1的对象经过Minor GC后，要继续存活的就移到另一个区域(S0 or S1)，要回收的清除即可，要回收的对象就会在S0、S1两个区域中间来回移动，当移动的次数大于15次后，那之后就放进老年代，表示这个对象是需要长期存活的对象。</p><p>在中间每次清理S0、S1后，每次处理后都会有一个是空闲状态的，下一次把需要存活的移到空闲的区域</p><p><strong>年龄阈值</strong></p><p>关于年龄阈值，如果是并行GC，默认值是15，如果是CMS垃圾处理器的，就是6，详细可以看官方文档：</p><p>一般不指定垃圾处理器，那就是并行的，所以默认15次</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC</a></p><p><img src="https://img-blog.csdnimg.cn/656d20e0fc544965af0f785bf29deca9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以执行命令来看JVM的默认参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal 打印jvm默认参数值；</span><br></pre></td></tr></table></figure><h2 id="2-17-JVM对象动态年龄判断是怎么回事？☆☆☆"><a href="#2-17-JVM对象动态年龄判断是怎么回事？☆☆☆" class="headerlink" title="2.17 JVM对象动态年龄判断是怎么回事？☆☆☆"></a>2.17 JVM对象动态年龄判断是怎么回事？☆☆☆</h2><p>虚拟机<strong>并不是永远</strong>地要求对象的年龄必须达到了MaxTenuringThreshold=15才能晋升老年代；</p><p><strong>结论</strong><br>动态年龄判断：Survivor区的对象年龄从小到大进行累加，当累加到X年龄（某个年龄）时占用空间的总和大于50%（可以使用-XX:TargetSurvivorRatio=? 来设置保留多少空闲空间，默认值是50），那么比X年龄大的对象都会晋升到老年代；</p><p>1、Survivor区分布如下图：</p><p>这里是三轮后的的一个分布结果<br><img src="https://img-blog.csdnimg.cn/642f3d684c4f40f9b82a341303c2d2f1.png" alt="在这里插入图片描述"></p><blockquote><p>解释：也就是还有45%的对象还在存活，只要大于50%，才会触发动态年龄判断</p></blockquote><p>2、此时新生代GC后，有6%的对象进入Survivor区，Survivor区分布如下图：<br><img src="https://img-blog.csdnimg.cn/292de29e8215408a814dbad57aae85c0.png" alt="在这里插入图片描述"><br>这时从1岁加到4岁时,总和51% 大于50%，但此时没有大于四岁的对象，即没有对象晋升</p><blockquote><p>解释：动态年龄判断是在大于50%后触发，然后针对的是50%以后的大年龄对象，也就是4岁以后的，5岁 6岁…此处没有</p></blockquote><p>3、又经过一次新生代GC后，有40%的对象进入Survivor区，Survivor区分布如下图：<br><img src="https://img-blog.csdnimg.cn/05aab638f83447baa0ceaf497fa4b74c.png" alt="在这里插入图片描述"><br>Survivor区的对象年龄从小到大进行累加，当累加到 3 年龄时的总和大于50%，那么比3大的都会晋升到老年代，即<strong>4岁的20%、5岁的20%晋升到老年代</strong>；</p><blockquote><p>总结：并不是严格的到了15岁，就会到达老年代，也有动态年龄判断机制！</p></blockquote><h2 id="2-18-什么是老年代空间分配担保机制"><a href="#2-18-什么是老年代空间分配担保机制" class="headerlink" title="2.18 什么是老年代空间分配担保机制"></a>2.18 什么是老年代空间分配担保机制</h2><p><img src="https://img-blog.csdnimg.cn/016cc3b2804c45188544b456bfdb6ae7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>Eden：800m –&gt;300m</p><p>S0：100m</p><p>S1：100m</p><p>老年代：1000m，剩350m、200m</p><p>新生代Minor GC后剩余存活对象太多，无法放入Survivor区中，此时就必须将这些存活对象直接转移到老年代去，如果此时老年代空间也不够怎么办？</p><p>1、执行任何一次Minor GC之前，JVM会先检查一下老年代可用内存空间，是否大于新生代所有对象的总大小，因为在极端情况下，可能新生代Minor GC之后，新生代所有对象都需要存活，那就会造成新生代所有对象全部要进入老年代；</p><p>2、如果老年代的可用内存大于新生代所有对象总大小，此时就可以放心大胆的对新生代发起一次Minor GC，因为Minor GC之后即使所有对象都存活，Survivor区放不下了，也可以转移到老年代去； </p><p>3、如果执行Minor GC之前，检测发现老年代的可用空间已经小于新生代的全部对象总大小，那么就会进行下一个判断，判断老年代的可用空间大小，是否大于之前每一次Minor GC后进入<strong>老年代的对象的平均大小</strong>，如果判断发现老年代的内存大小，大于之前每一次Minor GC后进入老年代的对象的平均大小，那么就是说可以冒险<strong>尝试一下Minor GC</strong>，但是此时真的可能有风险，那就是Minor GC过后，剩余的存活对象的大小，大于Survivor空间的大小，也大于老年代可用空间的大小，老年代都放不下这些存活对象了，此时就会触发一次“Full GC”； </p><p>所以老年代空间分配担保机制的目的？也是为了<strong>避免频繁进行Full GC</strong>；</p><p>4、如果Full GC之后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致“OOM”内存溢出 ；</p><p>在JDK6的时候有一个参数-XX:+HandlePromotionFailure用于开启是否要进行空间担保;</p><blockquote><p>解释：</p><p>简单来说，就是往老年代放对象的时候，这个空间够不够，有一个担保机制。</p><p>当Eden新生代区域装满对象后，触发Minor GC，这里的核心在于做一个判断：</p><p>判断老年代的可用空间能不能大于新生代的对象大小总和，（这里相当于假设新生代对象全部都不可回收 并且S0 S1也不够，那么就得往老年代里面放，如果老年代可以全覆盖了，说明可以直接Minor GC，是没有OOM风险的）；如果老年代空间不足以覆盖全部新生代对象，那么就再作第二个判断：看历史往老年代放对象的平均大小和老年代的可用空间做比较(这里相当于是个评估，用历史平均去预算一下，但是也可能这一次比历史平均的都大，那么最终还得Full GC，Full GC指的是对老年代做回收，如果仍然不够则OOM)，这样的目的还是为了避免Full GC</p></blockquote><p><img src="https://img-blog.csdnimg.cn/034ec2ed49e84d10a32b1037e7e6172b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>核心关键：</strong><br>避免频繁的Full GC，所以每次判断都是先尽量走Minor GC，实在不行再Full GC。</p><h2 id="2-19-什么情况下对象会进入老年代？"><a href="#2-19-什么情况下对象会进入老年代？" class="headerlink" title="2.19 什么情况下对象会进入老年代？"></a>2.19 什么情况下对象会进入老年代？</h2><p>1、躲过15次GC之后进入老年代，可通过JVM参数“-XX:MaxTenuringThreshold”来设置年龄，默认为15岁；</p><p>2、动态对象年龄判断；</p><p>3、老年代空间担保机制；</p><p>4、<strong>大对象直接进入老年代</strong>；</p><p>大对象是指需要大量连续内存空间的Java对象，比如很长的字符串或者是<strong>很大的数组或者List集合</strong>，大对象在分配空间时，容易导致内存明明还有不少空间时就提前触发垃圾回收以获得足够的连续空间来存放它们，而当复制对象时，大对象又会引起<strong>高额的内存复制开销，</strong>为了避免新生代里出现那些大对象，然后屡次躲过GC而进行来回复制，此时JVM就直接把该大对象放入老年代，而不会经过新生代；</p><p>我们可以通过JVM参数“-XX:PretenureSizeThreshold”设置多大的对象直接进入老年代，该值为字节数，比如“1048576”字节就是1MB，该参数表示如果创建一个大于这个大小的对象，比如一个超大的数组或者List集合，此时就直接把该大对象放入老年代，而不会经过新生代； </p><p>-XX:PretenureSizeThreshold参数只对Serial和ParNew两款新生代收集器有效，其他新生代垃圾收集器不支持该参数，如果必须使用此参数进行调优，可考虑 ParNew+CMS的收集器组合；</p><blockquote><p>解释：对于大对象来说，一般大概率是不会被回收的，那么如果在S0和S1区域来回的移动，这样的内存开销是很大的，为了避免这一个巨大开销，就直接将过大的对象直接放入到老年代中存储</p></blockquote><h2 id="2-20-JVM运行时数据区-元空间的特点及作用？"><a href="#2-20-JVM运行时数据区-元空间的特点及作用？" class="headerlink" title="2.20 JVM运行时数据区 元空间的特点及作用？"></a>2.20 JVM运行时数据区 元空间的特点及作用？</h2><p>1、在JDK1.8开始才出现元空间的概念，之前叫方法区/永久代；</p><p>2、元空间与Java堆类似，是线程共享的内存区域；</p><p>3、<strong>存储被加载的类信息、常量、静态变量、常量池、即时编译后的代码等数据</strong>；</p><p>4、元空间采用的是本地内存，本地内存有多少剩余空间，它就能扩展到多大空间，也可以设置元空间大小；</p><p>-XX:MetaspaceSize=20M -XX:MaxMetaspaceSize=20m</p><p>5、元空间很少有GC垃圾收集，一般该区域回收条件苛刻，能回收的信息比较少，所以GC很少来回收；</p><p>6、元空间内存不足时，将抛出OutOfMemoryError；</p><blockquote><p>解释：</p><p>jdk1.8前都叫方法区，目前都叫元空间，这个区域和堆是并列的，也属于线程共享的内存区域，其存储的主要是类的信息，静态变量、常量等等一系列静态的量，比如下图，类加载后，类的信息就会存储在元空间中；</p><p>元空间的内存是不需要垃圾回收的，能回收的信息比较少</p><p>当元空间内存不足时候也会报OOM</p><p>元空间的大小占用的是本地内存，所以本地内存还剩多少，就可以给它扩展到多少，一般来说都是绝对足够的</p></blockquote><p> <img src="https://img-blog.csdnimg.cn/53665f46da0e434687e874ea7e83afe3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>测试元空间溢出</strong></p><p>这里采用了动态代理方式，来不断的创建类到元空间中</p><p>死循环，这里当超出了内存大小后就会溢出，如果不设置参数的话，就是根据机器剩余的内存来扩展，这时候需要等待很久才会溢出，如下图修改元空间大小参数，大小设置为20m，会马上内存溢出：</p><p><img src="https://img-blog.csdnimg.cn/e79ae98560b44d228a49e2e0a243f23a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/19ac30138e4d497089b0c551074be655.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元空间溢出测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaSpace</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);<span class="comment">//缓存</span></span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建动态代理类class</span></span><br><span class="line">            UserService userService = (UserService)enhancer.create();</span><br><span class="line">            userService.find();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"创建了"</span> + (++counter) + <span class="string">"个动态代理对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService类加载......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"find......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-21-JVM本机直接内存的特点及作用？"><a href="#2-21-JVM本机直接内存的特点及作用？" class="headerlink" title="2.21 JVM本机直接内存的特点及作用？"></a>2.21 JVM本机直接内存的特点及作用？</h2><p>1、直接内存（Direct Memory）不属于JVM运行时数据区，是本机直接物理内存；</p><p>2、像在JDK 1.4中新加入了NIO（New Input/Output）类，一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的 DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据；</p><p>3、可能导致OutOfMemoryError异常出现； netty</p><h2 id="2-22-JVM本机直接内存溢出问题？"><a href="#2-22-JVM本机直接内存溢出问题？" class="headerlink" title="2.22 JVM本机直接内存溢出问题？"></a>2.22 JVM本机直接内存溢出问题？</h2><p><strong>直接内存（Direct Memory）</strong> 的容量大小可通过-XX:MaxDirectMemorySize参数来指定，该参数表示设置新I / O（java.nio程序包）直接缓冲区分配的最大总大小（以字节为单位）;默认情况下，大小设置为0，这意味着JVM自动为NIO直接缓冲区分配选择大小；</p><p>由直接内存导致的内存溢出，<strong>无法生成Heap Dump文件</strong>，如果程序中直接或间接使用了NIO技术，那就可以重点考虑检查一下直接内存方面的原因；</p><p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dev/heapdump.hprof</p><blockquote><p>解释</p><ol><li><p>如果想输出原因文件，则要输入JVM参数XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dev/heapdump.hprof</p></li><li><p>测试NIO的直接内存溢出：</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectBufferOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        List&lt;ByteBuffer&gt; buffers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</span><br><span class="line">            buffers.add(byteBuffer);</span><br><span class="line">            System.out.println(count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报直接内存溢出(物理内存)</p><p> <img src="https://img-blog.csdnimg.cn/38e79a5bd5ca40aeba133f00e707e012.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>修改直接内存参数<br><img src="https://img-blog.csdnimg.cn/1eadedc438334164bf0b84758a0fd24e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4728feee8d2f4b81acd1bd3d3918cc0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>如果想输出原因文件，则要输入JVM参数XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dev/heapdump.hprof</p><ol><li>先配置</li><li>运行程序，报Direct buffer memory错误</li><li>发现在D:/dev/下没有生成heapdump.hprof文件</li></ol><p>这个步骤可以用来<strong>排查出是直接内存</strong>溢出，再进一步考虑是否直接或者间接的使用到了NIO技术</p><h2 id="2-23-几个与JVM内存相关的核心参数？"><a href="#2-23-几个与JVM内存相关的核心参数？" class="headerlink" title="2.23 几个与JVM内存相关的核心参数？"></a>2.23 几个与JVM内存相关的核心参数？</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-Xms Java堆内存的大小；</span><br><span class="line">-Xmx Java堆内存的最大大小；</span><br><span class="line"></span><br><span class="line">-Xmn Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小；</span><br><span class="line"></span><br><span class="line">-XX:MetaspaceSize 元空间大小；</span><br><span class="line"></span><br><span class="line">-XX:MaxMetaspaceSize 元空间最大大小；</span><br><span class="line"></span><br><span class="line">-Xss 每个线程的栈内存大小；</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio&#x3D;8 设置eden区 和survivor 区大小的比例，默认是8:1:1；</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;5 年龄阈值；</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC 指定CMS垃圾收集器；</span><br><span class="line"></span><br><span class="line">-XX:+UseG1GC 指定使用G1垃圾回收器</span><br></pre></td></tr></table></figure><p>–查看默认的堆大小及默认的垃圾收集器</p><p>java -XX:+PrintCommandLineFlags -version</p><h2 id="2-24-查看一个对象的大小"><a href="#2-24-查看一个对象的大小" class="headerlink" title="2.24 查看一个对象的大小"></a>2.24 查看一个对象的大小</h2><p>导入Lucene库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//1024kb = 1m</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      Order order = <span class="keyword">new</span> Order();</span><br><span class="line">      <span class="comment">//计算指定对象及其引用树上所有对象的综合大小，单位字节</span></span><br><span class="line">      <span class="keyword">long</span> size = RamUsageEstimator.sizeOf(order);</span><br><span class="line">      <span class="comment">//计算指定对象及其引用树上所有对象的综合大小，返回可读的结果，如：2KB</span></span><br><span class="line">      String humanSize = RamUsageEstimator.humanSizeOf(order);</span><br><span class="line">      </span><br><span class="line">      System.out.println(size);</span><br><span class="line">      System.out.println(humansize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e5b64d5d802d489ca62aeb2e03760e28.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、深入剖析JVM内存管理&quot;&gt;&lt;a href=&quot;#二、深入剖析JVM内存管理&quot; class=&quot;headerlink&quot; title=&quot;二、深入剖析JVM内存管理&quot;&gt;&lt;/a&gt;二、深入剖析JVM内存管理&lt;/h1&gt;&lt;h2 id=&quot;2-1-Java代码到底是如何运行起来的？</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="JAVA虚拟机" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM【JVM类加载机制】</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM/</id>
    <published>2021-11-06T07:55:12.000Z</published>
    <updated>2021-11-06T08:22:24.123Z</updated>
    
    <content type="html"><![CDATA[<p>概述：</p><ul><li>JVM类加载机制</li><li>深入剖析JVM内存管理</li><li>JVM垃圾回收机制</li><li>JVM故障诊断性能调优</li></ul><h1 id="一、JVM类加载机制"><a href="#一、JVM类加载机制" class="headerlink" title="一、JVM类加载机制"></a>一、JVM类加载机制</h1><h2 id="1-1-Java运行时一个类是什么时候被加载的？"><a href="#1-1-Java运行时一个类是什么时候被加载的？" class="headerlink" title="1.1 Java运行时一个类是什么时候被加载的？"></a>1.1 Java运行时一个类是什么时候被加载的？</h2><p>一个类在什么时候开始被加载，《Java虚拟机规范》中并没有进行强制约束，交给了虚拟机自己去自由实现，HotSpot虚拟机是按需加载，在需要用到该类的时候加载这个类；</p><p>1、Sun公司最早的 Classic虚拟机；</p><p>2、Sun/Oracle公司的HotSpot虚拟机；</p><p>3、BEA公司的JRockit虚拟机；</p><p>4、IBM公司的IBM J9虚拟机；</p><p>官方：<a href="https://docs.oracle.com/javase/8/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/</a> </p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>-XX:+TraceClassLoading</p><p>测试类的详细载入：</p><p> <img src="https://img-blog.csdnimg.cn/5bd24ce438114ca6931b59bb58529a42.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/2e6b46a24d774bd1bdc32c2d084e0dd3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d43ad7b91ce94a3ebfb0e9137c23ee83.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-2-JVM一个类的加载过程？"><a href="#1-2-JVM一个类的加载过程？" class="headerlink" title="1.2 JVM一个类的加载过程？"></a>1.2 JVM一个类的加载过程？</h2><p>一个类从加载到jvm内存，到从jvm内存卸载，它的整个生命周期会经历7个阶段：</p><p>1、加载（Loading）</p><p>2、验证（Verification）</p><p>3、准备（Preparation）</p><p>4、解析（Resolution）</p><p>5、初始化（Initialization）</p><p>6、使用（Using）</p><p>7、卸载（Unloading）</p><p>其中验证、准备、解析三个阶段统称为连接（Linking）；<br><img src="https://img-blog.csdnimg.cn/13fa5bffb22047db8449f3846761b42e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>加载：</strong> classpath、jar包、网络、某个磁盘位置下的类的class二进制字节流读进来，在内存中生成一个代表这个类的java.lang.Class对象放入元空间，此阶段我们程序员可以干预，我们可以自定义类加载器来实现类的加载；</p><p><strong>验证：</strong> 验证Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证虚拟机的安全；</p><p><strong>准备：</strong> 类变量赋默认初始值，int为0，long为0L，boolean为false，引用类型为null；常量赋正式值；</p><p><strong>解析：</strong> 把符号引用翻译为直接引用；</p><p><strong>初始化：</strong> 当我们new一个类的对象，访问一个类的静态属性，修改一个类的静态属性，调用一个类的静态方法，用反射API对一个类进行调用，<strong>初始化当前类，其父类也会被初始化</strong>…… 那么这些都会触发类的初始化；</p><p><strong>使用：</strong> 使用这个类；</p><p><strong>卸载：</strong></p><p>1.该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例；</p><p>2.加载该类的ClassLoader已经被GC； （ClassLoader：类加载器，用于加载class）</p><p>3.该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法；</p><p><strong>准备阶段：</strong></p><p>​    对于final常量来说，准备阶段直接赋值a为123，对于类变量，是在类初始化（new）的时候才会进行赋值，所以先赋0，而对于实例变量abc来说，也是先赋0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123; <span class="comment">// java.lang.Class</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">222</span>;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"sdfsdf"</span>; <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> abc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -XX:+TraceClassLoading 监控类的加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.working();</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解析阶段：</p><p>把一个类的class文件读进来之后，变成java.lang.class对象，在元空间里面</p></blockquote><h2 id="1-3一个类被初始化的过程？☆☆☆"><a href="#1-3一个类被初始化的过程？☆☆☆" class="headerlink" title="1.3一个类被初始化的过程？☆☆☆"></a>1.3一个类被初始化的过程？☆☆☆</h2><p><img src="https://img-blog.csdnimg.cn/b81a91c6b2e745eba65d3991c8d1eef5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>类的初始化阶段，Java虚拟机才真正开始执行类中编写<strong>Java程序代码</strong>；</p><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，</p><p>而在初始化阶段，才真正初始化类变量和其他资源；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态常量  ==准备</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String staticConstantField = <span class="string">"静态常量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量 ==准备阶段赋值为 null，初始化阶段赋值为 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量 == 创建对象的时候赋值</span></span><br><span class="line">    <span class="keyword">public</span> String field = <span class="string">"变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块 ==初始化阶段执行</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(staticConstantField);</span><br><span class="line">        System.out.println(staticField);</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块 == 创建对象的时候执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">"初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器 == 创建对象的时候执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java Test02</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test02();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、rt.jar charset.jar</span></span><br><span class="line">        <span class="comment">// 2、InitialOrderTest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证初始化：</p><ol><li>当main方法中new对象时，执行空：<br><img src="https://img-blog.csdnimg.cn/b904b3f0c0ac458da6908208327572f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>此时会执行静态代码块中的语句，同时静态常量、静态变量都得到了初始化，所以main方法执行后，会初始化Test02类中的静态常量、静态变量、静态代码块</li></ol><ol start="2"><li>main中new Test02对象时：<br><img src="https://img-blog.csdnimg.cn/cf00cf501e374fa9bf1a8c9af9501425.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>同样也会先初始化Test02中的静态常量、静态变量、静态代码块，和第一个验证一致，其次再去初始化类的成员变量、代码块、构造方法</li></ol><h2 id="1-4-继承时父子类的初始化顺序是怎样的？"><a href="#1-4-继承时父子类的初始化顺序是怎样的？" class="headerlink" title="1.4 继承时父子类的初始化顺序是怎样的？"></a>1.4 继承时父子类的初始化顺序是怎样的？</h2><p>父类–静态变量</p><p>父类–静态初始化块</p><p>子类–静态变量</p><p>子类–静态初始化块</p><p>父类–变量</p><p>父类–初始化块</p><p>父类–构造器</p><p>子类–变量</p><p>子类–初始化块</p><p>子类–构造器</p><p>父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String p_StaticField = <span class="string">"父类--静态变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">public</span> String p_Field = <span class="string">"父类--变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(p_StaticField);</span><br><span class="line">        System.out.println(<span class="string">"父类--静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(p_Field);</span><br><span class="line">        System.out.println(<span class="string">"父类--初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"父类--构造器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">", j="</span> + j);</span><br><span class="line">        i = <span class="number">1</span>; j = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s_StaticField = <span class="string">"子类--静态变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">public</span> String s_Field = <span class="string">"子类--变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(s_StaticField);</span><br><span class="line">        System.out.println(<span class="string">"子类--静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s_Field);</span><br><span class="line">        System.out.println(<span class="string">"子类--初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"子类--构造器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序入口 java ChildClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChildClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试验证：</p><ol><li><p>main方法中不执行任何语句：<br><img src="https://img-blog.csdnimg.cn/85865c3977de490c9c7d1144bb0fcc10.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当在子类的main中执行时，会先初始化父类的静态变量+静态代码块，然后再初始化子类的静态变量+静态代码块</p></li><li><p>main方法中new子类对象时：<br><img src="https://img-blog.csdnimg.cn/da506d9c8bd349e9bcc61a301ffde44d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>前面的依旧，先初始化父类子类的静态变量、静态代码块，然后由于new了子类，所以还会先执行父类的成员变量、代码块、构造器，再执行子类的成员变量、代码块、构造器。</p></li><li><p>如果在子类main中new父类对象<br><img src="https://img-blog.csdnimg.cn/003ee5bee17c42ca9300c6b2addc1d85.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>结果可想而知，由于是子类的main，会先初始化父类子类静态变量、静态代码块，然后由于new了父类，所以还会初始化父类的成员变量、代码块、构造器</p></li></ol><h2 id="1-5-究竟什么是类加载器？"><a href="#1-5-究竟什么是类加载器？" class="headerlink" title="1.5 究竟什么是类加载器？"></a>1.5 究竟什么是类加载器？</h2><p><img src="https://img-blog.csdnimg.cn/ebe3963d9cb549828b27307c07336cdf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在类“加载”阶段，通过一个类的全限定名来获取描述该类的二进制字节流的这个动作的“代码”被称为“类加载器”（Class Loader），这个 <strong>动作是可以自定义实现</strong> 的；</p><p>类加载器可以由C++、Java语言实现</p><p><strong>简单来说，就是把.class文件以二进制形式读进来</strong></p><h2 id="1-6-JVM有哪些类加载器？"><a href="#1-6-JVM有哪些类加载器？" class="headerlink" title="1.6 JVM有哪些类加载器？"></a>1.6 JVM有哪些类加载器？</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：</p><p>1、启动类加载器（Bootstrap ClassLoader），使用C++语言实现，是虚拟机自身的一部分；</p><p>2、其他所有的类加载器，由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader；</p><p>站在Java开发者的角度来看，自JDK 1.2开始，Java一直保持着三层类加载器架构；<br><img src="https://img-blog.csdnimg.cn/30454650ccfb4aeb9bad631755a2d745.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-7-JVM中不同的类加载器加载哪些文件？"><a href="#1-7-JVM中不同的类加载器加载哪些文件？" class="headerlink" title="1.7 JVM中不同的类加载器加载哪些文件？"></a>1.7 JVM中不同的类加载器加载哪些文件？</h2><p>1、启动类加载器（Bootstrap ClassLoader）：（根的类加载器）C++语言实现的，在java中通过getClassLoader方法是获取不到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;JAVA_HOME&gt;\jre\lib\rt.jar，resources.jar、charsets.jar</span><br><span class="line"></span><br><span class="line">被-Xbootclasspath参数所指定的路径中存放的类库；</span><br></pre></td></tr></table></figure><p>2、扩展类加载器（Extension ClassLoader）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sun.misc.Launcher$ExtClassLoader，</span><br><span class="line"></span><br><span class="line">&lt;JAVA_HOME&gt;\jre\lib\ext，</span><br><span class="line"></span><br><span class="line">被java.ext.dirs系统变量所指定的路径中所有的类库；</span><br></pre></td></tr></table></figure><p>3、应用程序类加载器（Application ClassLoader）：系统的类加载器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line"></span><br><span class="line">加载用户类路径（ClassPath）上所有的类库；</span><br></pre></td></tr></table></figure><blockquote><p>测试验证：</p></blockquote><p>比如在</p><ul><li><p><JAVA_HOME>\jre\lib\rt.jar下找到一个类BufferReader类，查看其classLoader，为空，由于是c++语言编写的，所以Java中获取不到，是正常的；</p><p>输出为null则表明<strong>根的类加载器</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/38a1011b414d4e08a616e481e7cb6f79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>AppClassLoader，包括自己写的代码以及项目中涉及到的第三方jar包（如Springboot）<br><img src="https://img-blog.csdnimg.cn/84656823250941ce9128e7b206304cbc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>继承结构：<br><img src="https://img-blog.csdnimg.cn/b935dacc92ad46c49fc9a53da03119b6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="1-8-JVM三层类加载器之间的关系是继承吗？"><a href="#1-8-JVM三层类加载器之间的关系是继承吗？" class="headerlink" title="1.8 JVM三层类加载器之间的关系是继承吗？"></a>1.8 JVM三层类加载器之间的关系是继承吗？</h2><img src="https://img-blog.csdnimg.cn/89bda791bb7e4bd08962b8042fc80e3b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>不是继承关系。</li></ul><p>解释：<br><img src="https://img-blog.csdnimg.cn/2bccbcf820094c25a44338b7f9da2292.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b1c78fa1a84f44038119bdb37527e16b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7f9a344f09134651b3e479ca0b70a9ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2f33361c23e04775b0519a8fb63d9156.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>换个角度思考这个问题，前面提到过BootstrapClassLoader是C++语言实现的，ExtClassLoader是Java实现的，怎么可能继承呢？</p><p>如果我们自定义一个类加载器，那么则是继承共同的父类ClassLoader(抽象类)</p><h2 id="1-9-JVM类加载的双亲委派模型-☆☆☆"><a href="#1-9-JVM类加载的双亲委派模型-☆☆☆" class="headerlink" title="1.9 JVM类加载的双亲委派模型 ☆☆☆"></a>1.9 JVM类加载的双亲委派模型 ☆☆☆</h2><p><img src="https://img-blog.csdnimg.cn/9ff291a01cf941ef812669baa1d7a41f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>官方描述：</strong></p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当上一层类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到这个类）时，下一层类加载器才会尝试自己去加载；</p><blockquote><p><strong>过程分析：</strong></p><p>如：我要加载String这个类，来自rt.jar,首先让App ClassLoader去加载，但它自己不加载，委派给上一层加载，ExtClassLoader也不去加载，再继续委派给Bootstrap ClassLoader，再往上就没有了，那么此时BootstrapClassLoader就要去尝试加载，它主要是加载jre下内部库的jar包，而String这个类正好在rt.jar中，所以就return了，从而把String这个类加载到JVM内存中了。</p></blockquote><blockquote><p>当BootstrapClassLoader加载内库后，找不到所要加载的类，那么就让第二层ExtClassLoader去尝试加载，找得到就return，找不到就继续让AppClassLoader去加载后找。</p><p>当这个类几个类加载器都找不到时，报ClassNotFoundException</p><p>解释一下为啥叫双亲：因为AppClassLoader上面有两层，所以叫双亲</p><p>总结：先自底向上委派，再自顶向下去尝试加载</p></blockquote><h2 id="1-10-JDK为什么要设计双亲委派模型，有什么好处？"><a href="#1-10-JDK为什么要设计双亲委派模型，有什么好处？" class="headerlink" title="1.10 JDK为什么要设计双亲委派模型，有什么好处？"></a>1.10 JDK为什么要设计双亲委派模型，有什么好处？</h2><p>1、确保安全，避免Java核心类库被修改；</p><p>2、避免重复加载；</p><p>3、保证类的唯一性；</p><p>如果你写一个jaa.lang.String的类去运行，发现会抛出如下异常；</p><p>解释：</p><p> 比如即使自己写了个String类，也不会被加载，因为最先会加载rt.jar下的String，能够避免核心内库被修改，要保证安全。<br> <img src="https://img-blog.csdnimg.cn/fb14a61393854f4fa0828b5f99db626f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/01b32ddb909044a88ca3e70d7ad9999a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>自定义的包理论上是最终被APPClassLoader去加载的，但是这里为啥会报错，是因为包和核心内库重名了，所以报安全异常</p><h2 id="1-11-可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？"><a href="#1-11-可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？" class="headerlink" title="1.11 可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？"></a>1.11 可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？</h2><p>可以；</p><p>想要打破这种模型，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可；</p><h2 id="1-12-如何自定义自己的类加载器？"><a href="#1-12-如何自定义自己的类加载器？" class="headerlink" title="1.12 如何自定义自己的类加载器？"></a>1.12 如何自定义自己的类加载器？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、继承ClassLoader</span><br><span class="line">2、覆盖findClass(String name)方法 或者 loadClass() 方法；</span><br></pre></td></tr></table></figure><p>findClass(String name)方法 不会打破双亲委派；</p><p>loadClass() 方法 可以打破双亲委派（如何去加载可以自己去实现）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义ClassLoader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span></span><br><span class="line">        <span class="comment">//name = 包名 + 类名</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// User.class</span></span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line"></span><br><span class="line">        Class clazz = myClassLoader.findClass(<span class="string">"com.bjpowernode.loader.User"</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line"></span><br><span class="line">        System.out.println(User<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        Class claz2 = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Object o2 = claz2.newInstance();</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来com.bjpowernode.loader.User应该去AppClassLoader中加载的，但由于自定义了myClassLoader，并调用了findClass方法，所以会使用自定义的方法去加载。</p><p><img src="https://img-blog.csdnimg.cn/0b3754f67b0c4c15a6f33ed513605403.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-13-ClassLoader中的loadClass-、findClass-、defineClass-区别？"><a href="#1-13-ClassLoader中的loadClass-、findClass-、defineClass-区别？" class="headerlink" title="1.13 ClassLoader中的loadClass()、findClass()、defineClass()区别？"></a>1.13 ClassLoader中的loadClass()、findClass()、defineClass()区别？</h2><p>loadClass() 就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中；</p><p>findClass() 根据名称或位置加载.class字节码；</p><p>definclass() 把字节码转化为java.lang.Class；</p><p>1、当我们想要自定义一个类加载器的时候，并且想破坏双亲委派模型时，我们会重写loadClass()方法；</p><p>2、如果我们想定义一个类加载器，但是不想破坏双亲委派模型的时候呢？可以可以重写findClass方法()，findClass()方法是JDK1.2之后的ClassLoader新添加的一个方法，这个方法只抛出了一个异常，没有默认实现；</p><p>JDK1.2之后已不再提倡用户直接覆盖loadClass()方法，而是建议把自己的类加载逻辑实现到findClass()方法中；</p><p>因为覆盖即打破双亲委派，所以建议改findClass</p><p>所以，如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass()中实现你自己的加载逻辑即可；</p><blockquote><p>经典案例：Tomcat就打破了双亲委派机制</p></blockquote><h2 id="1-14-加载一个类采用Class-forName-和ClassLoader有什么区别"><a href="#1-14-加载一个类采用Class-forName-和ClassLoader有什么区别" class="headerlink" title="1.14 加载一个类采用Class.forName()和ClassLoader有什么区别"></a>1.14 加载一个类采用Class.forName()和ClassLoader有什么区别</h2><p><img src="https://img-blog.csdnimg.cn/f13857d9007a481b8a80a13c63409d6a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> Class.forName(<span class="string">"com.jvm.demo.loader.ChildClass"</span>)</span><br><span class="line">       </span><br><span class="line">     Class clazz = Test05.class.getClassLoader().loadClass("com.jvm.demo.loader.ChildClass")</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7f6d9e55388c40669dbb6cae7585ee94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/91d105129ccf47e893c53bfe3220b152.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>分析区别：<br>由此可见，ClassLoader这种方式，只经过了加载-&gt;链接，但是没有初始化，但是forName方式会初始化<br>如果继续对类实例化，则会初始化，并会创建对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">     Class clazz = Test05.class.getClassLoader().loadClass("com.jvm.demo.loader.ChildClass");</span><br><span class="line">    clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/bcca71557c23441dbf196a7344a96128.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>看看两个方法底层实现：</p><p>forName底层会初始化类：</p><p>调用了一个本地C++方法<br><img src="https://img-blog.csdnimg.cn/21090b3adde84d84ab47d39e7ceffafb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>ClassLoader底层：</p><p>双亲委派类加载，没有对类进行初始化<br><img src="https://img-blog.csdnimg.cn/6446910b0afa4f88b61c9ee328a53227.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-15-了解Tomcat-的类加载机制"><a href="#1-15-了解Tomcat-的类加载机制" class="headerlink" title="1.15 了解Tomcat 的类加载机制"></a>1.15 了解Tomcat 的类加载机制</h2><p><img src="https://img-blog.csdnimg.cn/ec833dac95374d2bacc77b42dec35f0e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以看到，在原来的Java的类加载机制基础上，Tomcat新增了3个基础类加载器和每个Web应用的类加载器+JSP类加载器；</p><p>3个基础类加载器在 conf/catalina.properties 中进行配置：</p><p>common.loader=”${catalina.base}/lib”,”${catalina.base}/lib/<em>.jar”,”${catalina.home}/lib”,”${catalina.home}/lib/</em>.jar”<br> server.loader=<br> shared.loader=</p><p>Tomcat自定义了WebAppClassLoader类加载器，打破了双亲委派的机制，即如果收到类加载的请求，首先会尝试自己去加载，如果找不到再交给父加载器去加载，目的就是为了优先加载Web应用自己定义的类，我们知道ClassLoader默认的loadClass方法是以双亲委派的模型进行加载类的，那么Tomcat打破了这个规则，重写了loadClass方法，我们可以看到WebAppClassLoader类中重写了loadClass方法；</p><h2 id="1-16-有没有听说过热加载和热部署，如何自己实现一个热加载？"><a href="#1-16-有没有听说过热加载和热部署，如何自己实现一个热加载？" class="headerlink" title="1.16 有没有听说过热加载和热部署，如何自己实现一个热加载？"></a>1.16 有没有听说过热加载和热部署，如何自己实现一个热加载？</h2><p><strong>热加载</strong> 是指可以在不重启服务的情况下让更改的代码生效，热加载可以显著的提升开发以及调试的效率，它是基于Java的类加载器实现的，但是由于热加载的不安全性，一般不会用于正式的生产环境；</p><p><strong>热部署</strong> 是指可以在不重启服务的情况下重新部署整个项目，比如Tomcat热部署就是在程序运行时，如果我们修改了War包中的内容，那么Tomcat就会删除之前的War包解压的文件夹，重新解压新的War包生成新的文件夹；</p><p>1、热加载是在运行时重新加载class，后台会启动一个线程不断检测你的class是否发生改变；</p><p>2、热部署是在运行时重新部署整个项目，耗时相对较高；</p><p>如何实现热加载呢？</p><p>在程序代码更改且重新编译后，让运行的进程可以实时获取到新编译后的class文件，然后重新进行加载；</p><p><strong>重点步骤</strong></p><p>1、实现自己的类加载器；</p><p>2、从自己的类加载器中加载要热加载的类；</p><p>3、不断轮训要热加载的类class文件是否有更新，如果有更新，重新加载；</p><p>类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义一个类加载器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * bootstrap ClassLoader jdk/jre/目录下的jar包加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ext ClassLoader  jdk/ext/目录下的jar包加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * App ClassLoader --我们应用的ClassLoader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File classPathFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Class&gt; clazzCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="comment">//缓存 保存加载的类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String classPath = MyClassLoader.class.getResource("").getPath();</span><br><span class="line">        <span class="keyword">this</span>.classPathFile = <span class="keyword">new</span> File(classPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.findClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name, <span class="keyword">boolean</span> force) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//force是否强制加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//之前有没有加载过这个class</span></span><br><span class="line">        Class cls = clazzCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (force) &#123;</span><br><span class="line">            <span class="comment">//如果强制加载 则缓存值值为空，后面重新加载一遍</span></span><br><span class="line">            cls = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String className = MyClassLoader.class.getPackage().getName() + "." + name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个cls不为空则直接return了</span></span><br><span class="line">        <span class="keyword">if</span> (cls == <span class="keyword">null</span> &amp;&amp; classPathFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File classFile = <span class="keyword">new</span> File(classPathFile + <span class="string">"\\"</span> + name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>) + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">if</span> (classFile.exists()) &#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">                ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                    bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cls = defineClass(className, bos.toByteArray(), <span class="number">0</span>, bos.size());</span><br><span class="line">                    clazzCache.put(name, cls);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            fis.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(bos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            bos.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazzCache.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个定时任务去轮询：</p><p>观察狗 线程：</p><blockquote><p>思路：遍历文件，去拿到每个文件的时间，判断是否被修改，如果修改则重新触发加载类(自定义类加载器)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察狗</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchDog</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, FileDefine&gt; fileDefineMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchDog</span><span class="params">(Map&lt;String, FileDefine&gt; fileDefineMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileDefineMap = fileDefineMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.getClass().getResource(<span class="string">""</span>).getPath());</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File watchFile : files) &#123;</span><br><span class="line">            <span class="keyword">long</span> newTime = watchFile.lastModified();</span><br><span class="line">            FileDefine fileDefine = fileDefineMap.get(watchFile.getPath());</span><br><span class="line">            <span class="keyword">long</span> oldTime = fileDefine.getLastDefine();</span><br><span class="line">            <span class="comment">//如果文件被修改了,那么重新生成累加载器加载新文件</span></span><br><span class="line">            <span class="keyword">if</span> (newTime != oldTime) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件被修改......"</span>);</span><br><span class="line">                fileDefine.setLastDefine(newTime);</span><br><span class="line">                <span class="comment">//重新触发类加载</span></span><br><span class="line">                loadMyClass(watchFile.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadMyClass</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">            myClassLoader.findClass(className.replace(<span class="string">".class"</span>, <span class="string">""</span>), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, FileDefine&gt; fileDefineMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File file = new File(Test.class.getResource("").getPath());</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File watchFile : files) &#123;</span><br><span class="line">            FileDefine fileDefine = <span class="keyword">new</span> FileDefine();</span><br><span class="line">            fileDefine.setLastDefine(watchFile.lastModified());</span><br><span class="line">            fileDefineMap.put(watchFile.getPath(), fileDefine);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定时任务</span></span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> WatchDog(fileDefineMap), <span class="number">3</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        MyClassLoader w = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Class clazz = w.findClass(<span class="string">"MyLog"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ILog myLog = (ILog) clazz.newInstance();</span><br><span class="line">                myLog.log();</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试其中一个修改类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLog</span> <span class="keyword">implements</span> <span class="title">ILog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"log, version 1.0"</span>); 、</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处修改 System.out.println(“log, version 1.0”);为 System.out.println(“log, version 2.0”); 文件发生修改，但是要编译一下，点击build-&gt;Recompile ‘’MyLog.java’，那么轮询时就会发现文件的修改</p><p><img src="https://img-blog.csdnimg.cn/9fb916ae1aff4c37b5dba37591bd7dea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM类加载机制&lt;/li&gt;
&lt;li&gt;深入剖析JVM内存管理&lt;/li&gt;
&lt;li&gt;JVM垃圾回收机制&lt;/li&gt;
&lt;li&gt;JVM故障诊断性能调优&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一、JVM类加载机制&quot;&gt;&lt;a href=&quot;#一、JVM类加载机</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="JAVA虚拟机" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂云计算精髓MapReduce</title>
    <link href="https://ericzikun.github.io/2021/08/05/deep10-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%BA%91%E8%AE%A1%E7%AE%97%E7%B2%BE%E9%AB%93MapReduce/"/>
    <id>https://ericzikun.github.io/2021/08/05/deep10-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%BA%91%E8%AE%A1%E7%AE%97%E7%B2%BE%E9%AB%93MapReduce/</id>
    <published>2021-08-05T03:06:47.000Z</published>
    <updated>2021-09-28T06:07:09.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MapReduce-简介"><a href="#MapReduce-简介" class="headerlink" title="MapReduce 简介"></a>MapReduce 简介</h1><p>核心思想：“分而治之”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce思想在生活中处处可见。或多或少都曾接触过这种思想。MapReduce的思想核心 是“分而治之”，适用于大量复杂的任务处理场景(大规模数据处理场景)。</p><ul><li>Map负责——<strong>分</strong>，把复杂的任务分解为若干个“简单的任务”来并行处理。可以进行拆分的 前提是这些小任务可以并行计算，彼此间几乎没有<strong>依赖关系。</strong></li><li>Reduce负责——<strong>合</strong>，对map阶段的结果进行全局汇总。 MapReduce运行在yarn集群</li></ul><p>有两个阶段：</p><ol><li>ResourceManager</li><li>NodeManager</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这两个阶段合起来正是MapReduce思想的体现。后面再细说这两个阶段。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce的执行流程用下面这张图一目了然：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简而言之：首先将一个文件分成n片小文件，对每个小部分做map处理，最后再reduce汇总计算结果到一起<br><img src="https://img-blog.csdnimg.cn/5e3af54cd8bd441b83d6973bada83f0f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中的Reduce操作这里画了两个，可能是在汇总计算操作时对不同类型的数据做汇总处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有一个比较形象的语言解释MapReduce: 我们要数图书馆中的所有书。你数1号书架，我数2号书架。这就是“Map”。我们人越多，数书<br>就更快。 现在我们到一起，把所有人的统计数加在一起。这就是“Reduce”。</p><h1 id="MapReduce-设计构思"><a href="#MapReduce-设计构思" class="headerlink" title="MapReduce 设计构思"></a>MapReduce 设计构思</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce是一个分布式运算程序的编程框架，核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在Hadoop集群上。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。 为程序员提供一个抽象和高层的编程接口和框架。程序员<strong>仅需要关心其应用层的具体计算问题</strong>，仅需编写少量的处理应用本身计算问题的程序代码。如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来,交给计算框架去处理:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map和Reduce为程序员提供了一个清晰的操作接口抽象描述。MapReduce中定义了如下的Map 和Reduce两个抽象的编程接口，由用户去编程实现.Map和Reduce,MapReduce处理的数据类型是&lt;key,value&gt;键值对。</p><p>Map: (k1; v1) → [(k2; v2)]<br>Reduce: (k2; [v2]) → [(k3; v3)]</p><p>这里以wordcount来举例：</p><img src="https://img-blog.csdnimg.cn/e869575151bc4750a0b9c66664dd4158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>一个完整的mapreduce程序在分布式运行时有三类实例进程:</p><ol><li>MRAppMaster 负责整个程序的过程调度及状态协调 </li><li>MapTask 负责map阶段的整个数据处理流程</li><li>ReduceTask 负责reduce阶段的整个数据处理流程</li></ol><img src="https://img-blog.csdnimg.cn/b44ab181fd084ebe9fe72ebb01f75140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>总结：记住两点：必须由ResourceManager来接受计算任务并资源分配，由App Master来执行具体任务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MapReduce-简介&quot;&gt;&lt;a href=&quot;#MapReduce-简介&quot; class=&quot;headerlink&quot; title=&quot;MapReduce 简介&quot;&gt;&lt;/a&gt;MapReduce 简介&lt;/h1&gt;&lt;p&gt;核心思想：“分而治之”&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nb</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="云计算" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://ericzikun.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="MapReduce" scheme="https://ericzikun.github.io/tags/MapReduce/"/>
    
    <category term="hadoop" scheme="https://ericzikun.github.io/tags/hadoop/"/>
    
    <category term="分布式" scheme="https://ericzikun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>弄懂服务端、客户端【手写一个socket聊天室】</title>
    <link href="https://ericzikun.github.io/2021/08/02/deep9-%E5%BC%84%E6%87%82%E6%9C%8D%E5%8A%A1%E7%AB%AF%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%90%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAsocket%E8%81%8A%E5%A4%A9%E5%AE%A4%E3%80%91/"/>
    <id>https://ericzikun.github.io/2021/08/02/deep9-%E5%BC%84%E6%87%82%E6%9C%8D%E5%8A%A1%E7%AB%AF%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%90%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAsocket%E8%81%8A%E5%A4%A9%E5%AE%A4%E3%80%91/</id>
    <published>2021-08-02T08:15:50.000Z</published>
    <updated>2021-08-02T09:36:17.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见架构："><a href="#常见架构：" class="headerlink" title="常见架构："></a>常见架构：</h2><p>C/S架构：Client/Server(客户端/服务器)结构<img src="https://img-blog.csdnimg.cn/4eb987112f954ccfacc5390c87394ea3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>B/S架构：Browser/Server(浏览器/服务器)结构<br><img src="https://img-blog.csdnimg.cn/3ddc8a3513924c2dbca0b5c8f740f1a9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="服务端和客户端"><a href="#服务端和客户端" class="headerlink" title="服务端和客户端"></a>服务端和客户端</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简单地说：一般客户端负责和用户的交互，也就是屏幕显示(UI/UE)，服务端负责数据存储，也就是你的用户数据，而计算能力，客户端和服务端一般各负责一部分。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 微信、qq这种聊天功能一般在用户之间通信时，用户的数据先是发送到服务器上的，然后通过服务器进行转发给指定用户，从而完成一次用户间的通信，那么如何证明这一点呢？比如一下几种场景：</p><ol><li>当A用户不在线时，B用户给A发送，A是接收不到的，当A一上线，信息会立马发送给他，可推理出B用户发送的数据会保存在服务器中。</li><li>当A用户给B传输文件时，上传完后，B需要下载才可传输到本地，说明下载之前已经上传到服务器了，如果清空本地的该文件，在一定时间范围内仍然可以重新下载回来，说明服务器上文件还在。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于一个简单的群聊功能，实现的基本原理就是，客户端给服务器发送数据，服务器再将请求发送给其他客户端，从而完成转发，单聊那就是在客户端传服务器的过程中加入了目标用户识别码。</li></ol><h2 id="TCP-IP、UDP？"><a href="#TCP-IP、UDP？" class="headerlink" title="TCP/IP、UDP？"></a>TCP/IP、UDP？</h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里有一张图，表明了这些协议的关系。   <strong>TCP/IP协议族包括运输层、网络层、链路层。</strong><br><img src="https://img-blog.csdnimg.cn/3f62427555804da288d52f933babf2f1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h2 id="Socket技术"><a href="#Socket技术" class="headerlink" title="Socket技术"></a>Socket技术</h2><img src="https://img-blog.csdnimg.cn/e43ecb011edf4531883da487a41db724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简单来说，socket就是对tcp/ip协议的封装，在java中是一个类，方便用户去完成通信。</p><img src="https://img-blog.csdnimg.cn/6541003ddc4843e7a5ed40cac608c162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h3 id="Socket建立通信的流程："><a href="#Socket建立通信的流程：" class="headerlink" title="Socket建立通信的流程："></a>Socket建立通信的流程：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 服务端的ServerSocket通过绑定ip和port，从而完成初始化，以保证在port下监听待接入的客户端,accept()函数使得监听到接入的客户端，这里可以采用死循环【建立新的线程】保持服务端一直在监听并接受新的客户端的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">Socket socket = ss.accept();</span><br></pre></td></tr></table></figure><p>客户端：<br>同样通过绑定ip port建立Socket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket = <span class="keyword">new</span> Socket(host, port);</span><br></pre></td></tr></table></figure><p>服务端accept得到的Socket相当于是在客户端自建的Socket基础之上构建的新的Socket</p><p>服务端得到了与客户端连接的Socket之后便可以拿到该Socket的输入、输出流；<br>对于客户端也是一样，需要通过Socket拿到输入输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream is= socket.getInputStream();</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br></pre></td></tr></table></figure><h2 id="群聊代码："><a href="#群聊代码：" class="headerlink" title="群聊代码："></a>群聊代码：</h2><p>思路：<br><img src="https://img-blog.csdnimg.cn/83a0c801c17448c3a6acc2351603f43f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 服务端和客户端通信必须构建一个管道，管道的两端分别是InputStream、OutputStream，当服务端输出时用OutputStream，某一个客户端对应的就是InputStream来接受服务端的输出，即每个管道的输入输出一一对应。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么对于服务端来说，他的输入流，应该是客户端的输出流，有多少个客户端，就应该有多少个线程来维护这个管道，所以每连接一个客户端，就应该启动一个输入流给服务端。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么，服务端的输出流（输出的线程）应该有多少个呢，如果要实现转发 群发功能，那么服务端的输出流线程只能是一个 里面有多个输出流，因为它要给每一个客户端去发消息，消息可以存在消息列表里面，每次从msgQueue里面拿出第一个消息，然后发送给每一个客户端，所以对于服务端的输出线程，它理应包含一个list去装载每一个客户端的socket，这样才能在群发时 遍历每一个客户端的socket 并且拿到socket对应的输出流，将消息群发出去。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于1个客户端来说，比服务端简单很多，输入流（输入线程）就只用构建一个，用于接受客户端输出的数据，输出流（输出线程）也是构建一个，用于发送给服务端。具体的代码架构如下图所示，将客户端和服务端代码分离，便于维护和后期拓展功能</p><img src="https://img-blog.csdnimg.cn/28bbdcce6692413599f38399e62be2bf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.client.InputThread;</span><br><span class="line"><span class="keyword">import</span> chatroom.client.OutputThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 10:42 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Socket对象</span></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//服务器的Ip地址和服务器所使用的端口号</span></span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">8082</span>;</span><br><span class="line">    <span class="keyword">private</span> String label = <span class="string">"客户端"</span>;</span><br><span class="line">    <span class="keyword">private</span> String clientName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">        createCient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createCient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">            createInput(socket,label);</span><br><span class="line">            createOutput(socket,label);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createOutput</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        OutputThread outputThread = <span class="keyword">new</span> OutputThread(socket,label);</span><br><span class="line">        outputThread.setClientName(clientName);</span><br><span class="line">        <span class="keyword">new</span> Thread(outputThread).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createInput</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        InputThread inputThread = <span class="keyword">new</span> InputThread(socket,label);</span><br><span class="line">        <span class="keyword">new</span> Thread(inputThread).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"客户端1"</span>);</span><br><span class="line">        Client client2 = <span class="keyword">new</span> Client(<span class="string">"客户端2"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:24 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputThread</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = is.read(b);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//客户端输入：接受服务端的输出</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:26 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String label; <span class="comment">// 记录是客户端 or 服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String clientName; <span class="comment">//记录客户端的名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputThread</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientName</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//客户端 接受用户的输入 发送到服务端</span></span><br><span class="line">            System.out.println(<span class="string">"请输入要发送的内容"</span>);</span><br><span class="line">            Scanner ss = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String ans = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> curTime = System.currentTimeMillis();</span><br><span class="line">                curTime = curTime;</span><br><span class="line">                ans = clientName + <span class="string">"："</span> + ss.nextLine();</span><br><span class="line"></span><br><span class="line">                os.write(ans.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (</span><br><span class="line">                IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.client.Client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 3:42 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：客户端1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"客户端1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.client.Client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 3:42 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"客户端2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.server.InputThread;</span><br><span class="line"><span class="keyword">import</span> chatroom.server.OutputThread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 10:43 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">8082</span>;</span><br><span class="line">    <span class="keyword">private</span> String label = <span class="string">"服务端"</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> LinkedBlockingDeque&lt;String&gt; msgQueue;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Socket&gt; sockets;<span class="comment">//维护每一个与客户端连接的socket</span></span><br><span class="line">    <span class="keyword">public</span> Integer clientNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        createServer();</span><br><span class="line">        <span class="keyword">this</span>.clientNum = sockets.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务器套接字</span></span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println((<span class="string">"服务器已经启动,监听端口为"</span> + port));</span><br><span class="line">            <span class="comment">//初始化一个msgQueue用于存放客户端传来的数据</span></span><br><span class="line">            <span class="keyword">this</span>.msgQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">            <span class="keyword">this</span>.sockets = <span class="keyword">new</span> ArrayList&lt;Socket&gt;();</span><br><span class="line"></span><br><span class="line">            createOutput(sockets, msgQueue);</span><br><span class="line">            <span class="comment">// 给客户端发送信息 只需要维护一个OutputThread即可 以保证每次从msgQueue里取一次msg</span></span><br><span class="line">            <span class="comment">// 都能将该msg群发个多个客户端</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                Socket socket = ss.accept();</span><br><span class="line">                sockets.add(socket);</span><br><span class="line">                createInput(socket, msgQueue);<span class="comment">//每一个与客户端之间的socket都需要建立一个inputThread去接收</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//服务器套接字等待一个客服端socket连入，如果连接成功的话，就会创建一个套接字，不然在这里一直等待</span></span><br><span class="line">                System.out.println(<span class="string">"已经接受连接"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程 OutputThread：服务端输出到客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOutput</span><span class="params">(ArrayList&lt;Socket&gt; sockets, LinkedBlockingDeque&lt;String&gt; msgQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        OutputThread outputThread = <span class="keyword">new</span> OutputThread(msgQueue, sockets);</span><br><span class="line">        <span class="keyword">new</span> Thread(outputThread).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程 InputThread：服务端接受客户端的输入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createInput</span><span class="params">(Socket socket, LinkedBlockingDeque&lt;String&gt; msgQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputThread inputThread = <span class="keyword">new</span> InputThread(socket, msgQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(inputThread).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:24 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">public</span>   LinkedBlockingDeque&lt;String&gt; msgQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputThread</span><span class="params">(Socket socket,LinkedBlockingDeque&lt;String&gt; msgQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgQueue</span><span class="params">(LinkedBlockingDeque&lt;String&gt; msgQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is= socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = is.read(b);</span><br><span class="line">                <span class="comment">//接受客户端传来的信息</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(b , <span class="number">0</span>, len));</span><br><span class="line">                <span class="comment">//再把信息传到集合中去，再在outputThread中输出给其他客户端</span></span><br><span class="line">                msgQueue.add(<span class="keyword">new</span> String(b , <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:26 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Socket&gt; sockets;</span><br><span class="line">    <span class="keyword">public</span> LinkedBlockingDeque&lt;String&gt; msgQueue;</span><br><span class="line">    <span class="keyword">private</span> String label; <span class="comment">// 记录是客户端 or 服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputThread</span><span class="params">(LinkedBlockingDeque&lt;String&gt; msgQueue, ArrayList&lt;Socket&gt; sockets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sockets = sockets;</span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgQueue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    String poll = msgQueue.poll();</span><br><span class="line">                    <span class="comment">//群发给所有客户端</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sockets.size(); i++) &#123;</span><br><span class="line">                        Socket curSocket = sockets.get(i);</span><br><span class="line">                        os = curSocket.getOutputStream();</span><br><span class="line">                        os.write(poll.getBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见架构：&quot;&gt;&lt;a href=&quot;#常见架构：&quot; class=&quot;headerlink&quot; title=&quot;常见架构：&quot;&gt;&lt;/a&gt;常见架构：&lt;/h2&gt;&lt;p&gt;C/S架构：Client/Server(客户端/服务器)结构&lt;img src=&quot;https://img-blog.c</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="socket" scheme="https://ericzikun.github.io/tags/socket/"/>
    
    <category term="服务端" scheme="https://ericzikun.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    <category term="客户端" scheme="https://ericzikun.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>深入线程池【手写线程池！阿里弃用之辨析】</title>
    <link href="https://ericzikun.github.io/2021/07/01/deep8-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://ericzikun.github.io/2021/07/01/deep8-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-07-01T05:40:40.000Z</published>
    <updated>2021-07-01T05:44:23.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 线程池和<strong>数据库连接池</strong>非常类似，可以统一管理和维护线程，减少没有必要的开销。 </p><h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为频繁的开启线程或者停止线程，线程需要从新被 cpu 从就绪到运行状态调度，需要发生<br>cpu 的上下文切换，效率非常低。<br><img src="https://img-blog.csdnimg.cn/20210630105323135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><blockquote><p>当线程从run中sleep后，会到达阻塞状态，这时候要想再回到run状态，得先就绪再到run状态，成本极高；</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 分析：如果这里有100个线程，则会新建100个newThread，100次start，100次的就绪，100次的CPU调度，才能被运行，必然也有100次的销毁，整个的成本非常高！<br>所以我们提前创建好100个线程，都在<strong>运行状态</strong>，只要有请求过来了，直接再run方法中进行执行就行了！而不是又经过创建-&gt;就绪-&gt;运行 这个耗时的过程！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p><h1 id="哪里使用到线程池"><a href="#哪里使用到线程池" class="headerlink" title="哪里使用到线程池"></a>哪里使用到线程池</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实际开发项目中 禁止自己 new 线程。必须使用线程池来维护和创建线程。<br><img src="https://img-blog.csdnimg.cn/20210630111710128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际企业开发中，如果像这样去new线程，那一定会被开除！！</p><blockquote><p>如果别人找到了这个bug，比如你这个接口有每次创建线程的bug，那么别人可以通过这个bug给你服务器攻击！造成CPU飙高，线程池就可以很好的管理，管理线程创建的数量，而不是无限制的创建！</p></blockquote><h1 id="线程池有哪些作用"><a href="#线程池有哪些作用" class="headerlink" title="线程池有哪些作用"></a>线程池有哪些作用</h1><p>核心点：复用机制 提前创建好固定的线程一直在运行状态 实现复用 限制线程创建数量。<br>1.<strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。<br>2.<strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。<br>3.<strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。<br>4.<strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池 ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</p><p>总结：<strong>统一维护管理</strong></p><h1 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h1><p>Executors.newCachedThreadPool(); 可缓存线程池<br>Executors.newFixedThreadPool()；可定长度 限制最大线程数<br>Executors.newScheduledThreadPool() ； 可定时<br>Executors.newSingleThreadExecutor(); 单例<br>底层都是基于 ThreadPoolExecutor 构造函数封装</p><blockquote><p>前面四个基本上实际生产不会去用，阿里巴巴不推荐，因为底层都是由ThreadPoolExecutor 构造封装的，而构造函数中是一个无界的队列（后面解释）</p></blockquote><h3 id="Executors-newCachedThreadPool-："><a href="#Executors-newCachedThreadPool-：" class="headerlink" title="Executors.newCachedThreadPool()："></a>Executors.newCachedThreadPool()：</h3> <img src="https://img-blog.csdnimg.cn/2021063011395861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" />下面是它的源码部分<img src="https://img-blog.csdnimg.cn/20210630114057781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" />核心线程数传的0，最大是无限，没有界限，如果用这个无限的去创建，而不是复用机制，故不去用！这个api实际开发不用！ 可以改成可定长度线程池，这样即使for循环有10个线程创建，但是会被传入的nThread所限制。<img src="https://img-blog.csdnimg.cn/20210630114422898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /># 线程池底层是如何实现复用的本质思想：创建一个线程，不会立马停止或者销毁而是一直实现复用。1. 提前创建固定大小的线程一直保持在正在运行状态；（可能会非常消耗 cpu 的资源）2. 当需要线程执行任务，将该任务提交缓存在并发队列中；如果缓存队列满了，则会执行拒绝策略；3. 正在运行的线程从并发队列中获取任务执行从而实现多线程复用问题；<p><img src="https://img-blog.csdnimg.cn/2021063011505721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>线程的核心点：复用机制——</p><ol><li>提前创建好固定的线程一直在运行状态—-死循环实现</li><li>提交的线程任务缓存到一个并发队列集合中，交给我们正在运行的线程执行</li><li>正在运行的线程就从队列中获取该任务执行</li></ol><p>如何保证线程一直在运行，而不会停掉被销毁呢？———加一个<strong>while死循环</strong>即可</p><img src="https://img-blog.csdnimg.cn/2021063011531157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h1 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h1><p>思路：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先线程池得定义一系列线程，并且构造的时候让这些线程都处于一个运行状态，用workThreads代替，构造的时候可以给定限制的工作线程数量以及任务集合中的size上限，运行状态通过改写每一个工作线程的run方法即可，利用死循环让其处于一直运行的状态！具体每一个工作线程要做的任务是什么，就通过拿取runnableDeque这个队列中的每一个任务即可，poll方法拿取后便删除该任务。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想控制线程池使得结束，可以通过控制工作线程中while循环的条件，设置一个isRun的Boolean变量，并且当任务队列中没有任务了之后线程池才停止工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExecutors</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WorkThread&gt; workThreads;</span><br><span class="line">    <span class="comment">// 缓存我们线程任务</span></span><br><span class="line">    <span class="keyword">private</span> BlockingDeque&lt;Runnable&gt; runnableDeque;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRun = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大线程数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxThreadCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExecutors</span><span class="params">(<span class="keyword">int</span> maxThreadCount, <span class="keyword">int</span> dequeSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.限制队列容量缓存</span></span><br><span class="line">        runnableDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(dequeSize);</span><br><span class="line">        <span class="comment">//2.提前创建好固定的线程一直在运行状态----死循环实现</span></span><br><span class="line">        workThreads = <span class="keyword">new</span> ArrayList&lt;WorkThread&gt;(maxThreadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxThreadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> WorkThread().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (isRun||runnableDeque.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                Runnable runnable = runnableDeque.poll();</span><br><span class="line">                <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runnableDeque.offer(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyExecutors myExecutors = <span class="keyword">new</span> MyExecutors(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            myExecutors.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">","</span> + finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        myExecutors.isRun = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadPoolExecutor核心参数"><a href="#ThreadPoolExecutor核心参数" class="headerlink" title="ThreadPoolExecutor核心参数"></a>ThreadPoolExecutor核心参数</h1><p>corePoolSize：核心线程数量 一直正在保持运行的线程<br>maximumPoolSize：最大线程数，线程池允许创建的最大线程数。<br>keepAliveTime：超出 corePoolSize 后创建的线程的存活时间。<br>unit：keepAliveTime 的时间单位。<br>workQueue：任务队列，用于保存待执行的任务。<br>threadFactory：线程池内部创建线程所用的工厂。<br>handler：任务无法执行时的处理器。</p><h2 id="线程池创建的线程会一直在运行状态吗？"><a href="#线程池创建的线程会一直在运行状态吗？" class="headerlink" title="线程池创建的线程会一直在运行状态吗？"></a>线程池创建的线程会一直在运行状态吗？</h2><p>不会<br>例如：配置核心线程数 corePoolSize 为 2 、最大线程数 maximumPoolSize 为 5<br>我们可以通过配置超出 corePoolSize 核心线程数后创建的线程的存活时间例如为 60s，在 60s 内非核心线程一直没有任务执行，则会停止该线程。<br>总结：核心线程数是一直在运行的，但最大线程数是不一定的，看具体任务，如果任务的情况下补给到最大线程范围内更多的线程进来工作，最大线程减去核心线程的这部分线程在工作完后再销毁。<br>目的：为了节约服务器资源</p><h2 id="为什么阿里巴巴不建议使用-Executors"><a href="#为什么阿里巴巴不建议使用-Executors" class="headerlink" title="为什么阿里巴巴不建议使用 Executors"></a>为什么阿里巴巴不建议使用 Executors</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为默认的 Executors 线程池底层是基于 ThreadPoolExecutor构造函数封装的，采用<strong>无界队列存放缓存任务</strong>，会无限缓存任务容易发生内存溢出，会导致我们最大线程数会失效。<br><img src="https://img-blog.csdnimg.cn/20210630151105463.png"  style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，</span><br><span class="line">这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </span><br><span class="line">说明：Executors各个方法的弊端：</span><br><span class="line"><span class="number">1</span>）newFixedThreadPool和newSingleThreadExecutor:</span><br><span class="line">  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至<span class="number">1</span>OOM。</span><br><span class="line"><span class="number">2</span>）newCachedThreadPool和newScheduledThreadPool:</span><br><span class="line">  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至<span class="number">1</span>OOM。</span><br></pre></td></tr></table></figure><h2 id="线程池底层-ThreadPoolExecutor-底层实现原理"><a href="#线程池底层-ThreadPoolExecutor-底层实现原理" class="headerlink" title="线程池底层 ThreadPoolExecutor 底层实现原理"></a>线程池底层 ThreadPoolExecutor 底层实现原理</h2><p>1.当线程数小于核心线程数时，创建线程。<br>2.当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。<br>3.当线程数大于等于核心线程数，且任务队列已满<br>3.1 若线程数小于最大线程数，创建线程<br>3.2 若线程数等于最大线程数，抛出异常，拒绝任务<br>看例子：<br>分析：首先创建了一个线程池，有2个核心线程，4个最大线程，并且blockingQueue的容量为5（用于缓存任务队列），然后我们再for中提交了10个任务进行执行，第一个和第二个任务直接被2个核心线程来执行，3、4、5、6、7就被缓存到容量为5的blockingQueue队列中了，然后遍历到第八个新任务的时候，当前的线程数已经大于了核心线程数，并且任务队列已经装满了，那就再创建（最大线程数-核心线程数）个线程，这里也就是2个新的工作线程被创建去执行第8、第9个任务，当遍历到第10个任务的时候，就已经没有工作线程来执行了，并且任务队列之前也装满了，从而拒绝任务！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.提交的线程任务数&lt;核心线程数  （核心线程数任务复用）</span></span><br><span class="line">        <span class="comment">//2.提交的线程任务数&gt;核心线程数 且我们队列容量没有满 将该任务缓存到我们队列中</span></span><br><span class="line">        <span class="comment">// 循环3 4 5 6 7 缓存到我们队列中</span></span><br><span class="line">        <span class="comment">//3.提交的线程任务数&gt;核心线程数 且我们队列容量满了</span></span><br><span class="line">        <span class="comment">//8,9，10</span></span><br><span class="line">        <span class="comment">// 最多在额外创建两个线程 4-2 2个线程</span></span><br><span class="line">        <span class="comment">// 2个线程 8 ,9</span></span><br><span class="line">        <span class="comment">// 10个任务----拒绝</span></span><br><span class="line">        ExecutorService executorService = MyThreadPoolExecutor.newFixedThreadPool(<span class="number">2</span>, <span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">","</span> + finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实际上最多执行多少个任务 核心线程数+缓存队列的容量+最大线程数-核心线程数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己重写的一个ExecutorService，限制了传入的核心线程数、最大线程数、以及任务队列的容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">int</span> blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(blockingQueue), (RejectedExecutionHandler) <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池队列满了，任务会丢失吗"><a href="#线程池队列满了，任务会丢失吗" class="headerlink" title="线程池队列满了，任务会丢失吗"></a>线程池队列满了，任务会丢失吗</h2><p>如果队列满了，且任务总数&gt;最大线程数则当前线程走拒绝策略。<br>可以自定义异拒绝异常，将该任务缓存到 redis、本地文件、mysql 中后期项目启动实现补偿。<br>1.AbortPolicy 丢弃任务，抛运行时异常<br>2.CallerRunsPolicy 执行任务<br>3.DiscardPolicy 忽视，什么都不会发生<br>4.DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务</p><h2 id="线程池拒绝策略类型有哪些呢"><a href="#线程池拒绝策略类型有哪些呢" class="headerlink" title="线程池拒绝策略类型有哪些呢"></a>线程池拒绝策略类型有哪些呢</h2><p>1.AbortPolicy 丢弃任务，抛运行时异常<br>2.CallerRunsPolicy 执行任务<br>3.DiscardPolicy 忽视，什么都不会发生<br>4.DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务<br>5.实现 RejectedExecutionHandler 接口，可自定义处理器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是线程池&quot;&gt;&lt;a href=&quot;#什么是线程池&quot; class=&quot;headerlink&quot; title=&quot;什么是线程池&quot;&gt;&lt;/a&gt;什么是线程池&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 线程池和&lt;strong</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="线程池" scheme="https://ericzikun.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>别再问我字符串了！彻底理解Java中的字符串（==、equals、堆内存、常量池）</title>
    <link href="https://ericzikun.github.io/2021/06/29/deep7-%E6%B7%B1%E5%85%A5Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://ericzikun.github.io/2021/06/29/deep7-%E6%B7%B1%E5%85%A5Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-06-29T03:41:40.000Z</published>
    <updated>2021-07-01T05:41:52.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="equals、"><a href="#equals、" class="headerlink" title="equals、=="></a>equals、==</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先明确一点，==比较的是引用，equals比较的是内容，在类库没有定义equals方法重写的情况下，自然继承的是Object类的equals方法，上源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么对于String类来说，官方已封装了复写之后的equals方法，比较的是具体内容，判断：如果是引用相同，也就是堆内的地址相同，那么就是同一个对象，直接返回true，否则就遍历字符串中的每一个字符进行比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，字符串还有个常量池，也就是说如果先定义了一个”ABC”字符串，再定义一个相同字符串的时候，会首先去常量池里面找之前有没有定义，如果有，则直接指向常量池的同一地址。</p><h2 id="常量池介绍"><a href="#常量池介绍" class="headerlink" title="常量池介绍"></a>常量池介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化</p><ul><li><p>为字符串开辟一个字符串常量池，类似于缓存区</p></li><li><p>创建字符串常量时，首先坚持字符串常量池是否存在该字符串</p></li><li><p>存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了以上的铺垫，后面几个问题就好解释了：</p><h1 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"ABC"</span>);</span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">        System.out.println(str2 == str3);<span class="comment">// flase</span></span><br><span class="line">        System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2.equals(str3)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str1与str2都指向的是常量池中同一个字符串的地址，所以==为true，而str3是new了一个新的对象，会在堆中新建一个内存地址，所以比较str3和str3的地址时则为flase，equals就简单了，比较的均为字符串内容，故均为true。<br><img src="https://img-blog.csdnimg.cn/20210629134246186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h1 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"ABC"</span>);</span><br><span class="line">        String str3_1=str3.intern();</span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">        System.out.println(str2 == str3);<span class="comment">// flase</span></span><br><span class="line">        System.out.println(str3_1 == str1);<span class="comment">// true</span></span><br><span class="line">        System.out.println(str3_1 == str3);<span class="comment">// flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们新定义一个str3_1变量，让他取str3的intern()方法，此方法是这样定义的：</p><blockquote><p>这是一个native的方法，书上是这样描述它的作用的：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回常量池池中这个字符串的String对象；否则，将此String对象包含的字符添加到常量池中，并返回此String对象的引用。</p></blockquote><p>所以str3_1拿到的是常量池中的”ABC“地址，和str1、str2的地址肯定是相同的，</p><h1 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        str1 +=<span class="string">"D"</span>;</span><br><span class="line">        String str5 = <span class="string">"ABCD"</span>;<span class="comment">// 肯定在常量池中生成一个</span></span><br><span class="line">        System.out.println(str5 == str1);<span class="comment">//flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里如果给str1拼接了一个D字符串，这里通过javap命令查看字节码文件，会发现+=操作在String源码中调用的其实是apped方法，生成的是一个新的对象堆地址，str5指向的常量池的地址与str1指向的堆对象地址不一，如果我在str1拼接之后加上str1 = str1.intern(); 这时候由于str1指向的是常量池中的ABCD，==就为true了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        str1 +=<span class="string">"D"</span>;</span><br><span class="line">        str1 = str1.intern();</span><br><span class="line">        String str5 = <span class="string">"ABCD"</span>;<span class="comment">// 肯定在常量池中生成一个</span></span><br><span class="line">        System.out.println(str5 == str1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里intern调用之后，如果常量池中没有”ABCD“，则会在常量池生成，如果有则直接指向它。所以此处的str1指向的是常量池中的”ABCD“，后面定义的str5在构造时则会直接指向常量池中的”ABCD“</p><p>如果这里把str1 += ”D“修改一下成常量与常量的拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        str1 =<span class="string">"ABC"</span> +<span class="string">"D"</span>;</span><br><span class="line">        String str5 = <span class="string">"ABCD"</span>;<span class="comment">// 肯定在常量池中生成一个</span></span><br><span class="line">        System.out.println(str5 == str1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果两个常量进行拼接，编译器会自动优化成”ABCD”，也就是存到了常量池中去了，str5指向的也是常量池中的值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>原则：</p><p>（1）常量+常量：结果是常量池</p><p>（2）常量与变量 或 变量与变量：结果是堆</p><p>（3）拼接后调用intern方法：结果在常量池</p><p>new 出来的是在堆空间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;equals、&quot;&gt;&lt;a href=&quot;#equals、&quot; class=&quot;headerlink&quot; title=&quot;equ</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="字符串" scheme="https://ericzikun.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="堆内存" scheme="https://ericzikun.github.io/tags/%E5%A0%86%E5%86%85%E5%AD%98/"/>
    
    <category term="常量池" scheme="https://ericzikun.github.io/tags/%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mac Alfred 工作流 Python开发，可自定义任何接口，全自动化办公</title>
    <link href="https://ericzikun.github.io/2021/06/29/Mac-Alfred-%E5%B7%A5%E4%BD%9C%E6%B5%81-Python%E5%BC%80%E5%8F%91%EF%BC%8C%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E4%BD%95%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/"/>
    <id>https://ericzikun.github.io/2021/06/29/Mac-Alfred-%E5%B7%A5%E4%BD%9C%E6%B5%81-Python%E5%BC%80%E5%8F%91%EF%BC%8C%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E4%BD%95%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/</id>
    <published>2021-06-29T03:40:49.000Z</published>
    <updated>2021-06-29T06:10:41.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用Mac的人应该大多都知道这个，但是workflow工作流，应该是很多人没自己写过，得知支持Python脚本后，自己花了几个小时研究了一下如何把接口融合到Alfred快捷方式中，这里给大家提供一个模板，以这样的形式，无论是免费api还是自己封装的工具接口，均可集成到Alfred中！</p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="https://img-blog.csdnimg.cn/20210629100429404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210629100454129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="申请接口"><a href="#申请接口" class="headerlink" title="申请接口"></a>申请接口</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 市面上有很多免费接口，这里以聚合数据的头条新闻api为例，链接：<a href="https://www.juhe.cn/docs/api/id/235，在官网注册申请api即可，得到一个key，发送请求参数时带上key和其他参数即可。" target="_blank" rel="noopener">https://www.juhe.cn/docs/api/id/235，在官网注册申请api即可，得到一个key，发送请求参数时带上key和其他参数即可。</a></p><h1 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h1><h2 id="建立空白workflow"><a href="#建立空白workflow" class="headerlink" title="建立空白workflow"></a>建立空白workflow</h2><p><img src="https://img-blog.csdnimg.cn/20210629092138388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210629092200330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>填上基本信息即可，也可以设置一个图标<br>再在里面空白处右键选择script filter<br><img src="https://img-blog.csdnimg.cn/20210629092344177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210629100110687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在script filter里面，我们去运行Python脚本，接受的参数就是”{query}”可以进行传参，这里采用了一个免费的头条新闻api，只要接口能测成功即可，不赘述:<br><img src="https://img-blog.csdnimg.cn/20210629095727194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Python代码，整体思路就是，定义好获取接口数据的方法，并将结果返回给workflow的具体字段即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">Project Name: alfredProjects</span></span><br><span class="line"><span class="string">File Name: alfredTest.py</span></span><br><span class="line"><span class="string">Author: apple</span></span><br><span class="line"><span class="string">Create Date: 2021/6/28</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> workflow <span class="keyword">import</span> Workflow, web, ICON_WEB</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line"></span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">query_map = dict(</span><br><span class="line">    inner=<span class="string">u"输入in搜索头条国内新闻"</span>,</span><br><span class="line">    outter=<span class="string">'输入out搜索头条国际新闻'</span>,</span><br><span class="line">    top=<span class="string">u'输入top搜索热点新闻'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_recent_news</span><span class="params">(query)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> query == <span class="string">"in"</span>:</span><br><span class="line">        url = <span class="string">"http://v.juhe.cn/toutiao/index?"</span></span><br><span class="line">        params = &#123;<span class="string">"key"</span>: <span class="string">"dd0fb509ac5407213bc6a0fddd48f234"</span>,</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"guonei"</span>&#125;</span><br><span class="line">    <span class="keyword">elif</span> query == <span class="string">"out"</span>:</span><br><span class="line">        url = <span class="string">"http://v.juhe.cn/toutiao/index?"</span></span><br><span class="line">        params = &#123;<span class="string">"key"</span>: <span class="string">"dd0fb509ac5407213bc6a0fddd48f234"</span>,</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"guoji"</span>&#125;</span><br><span class="line">    <span class="keyword">elif</span> query == <span class="string">"top"</span>:</span><br><span class="line">        url = <span class="string">"http://v.juhe.cn/toutiao/index?"</span></span><br><span class="line">        params = &#123;<span class="string">"key"</span>: <span class="string">"dd0fb509ac5407213bc6a0fddd48f234"</span>,</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"top"</span>&#125;</span><br><span class="line"></span><br><span class="line">    r = web.post(url, data=params)</span><br><span class="line">    print(r)</span><br><span class="line">    <span class="comment"># throw an error if request failed, Workflow will catch this and show</span></span><br><span class="line">    <span class="comment"># it to the user</span></span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    <span class="comment"># result = r.json()</span></span><br><span class="line">    <span class="keyword">return</span> r.json()[<span class="string">"result"</span>][<span class="string">'data'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(wf)</span>:</span></span><br><span class="line">    query = wf.args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> query:</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">"inner"</span>, <span class="string">"outter"</span>, <span class="string">"top"</span>]:</span><br><span class="line">            wf.add_item(</span><br><span class="line">                title=query_map[key],</span><br><span class="line">                valid=<span class="literal">True</span>,</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> get_recent_news(query)</span><br><span class="line"></span><br><span class="line">        news = wf.cached_data(query, wrapper, max_age=<span class="number">300</span>)</span><br><span class="line">        <span class="comment"># news = get_recent_news(query)</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> news:</span><br><span class="line">            wf.add_item(title=<span class="string">u"【&#123;&#125;】&#123;&#125;"</span>.format(r[<span class="string">"author_name"</span>], r[<span class="string">'title'</span>]),</span><br><span class="line">                        arg=r[<span class="string">'url'</span>],</span><br><span class="line">                        valid=<span class="literal">True</span>,</span><br><span class="line">                        icon=ICON_WEB)</span><br><span class="line">    <span class="comment"># Send output to Alfred. You can only call this once.</span></span><br><span class="line">    <span class="comment"># Well, you *can* call it multiple times, but Alfred won't be listening</span></span><br><span class="line">    <span class="comment"># any more...</span></span><br><span class="line">    wf.send_feedback()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    wf = Workflow()</span><br><span class="line">    sys.exit(wf.run(main))</span><br></pre></td></tr></table></figure><p>最后说一下脚本和相关库放在哪里：<br> <img src="https://img-blog.csdnimg.cn/20210629100050804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击后，会在finder显示该工作流的文件夹，将workflow库以及Python脚本放在此下即可：<br><img src="https://img-blog.csdnimg.cn/20210629100136563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="跳转页面"><a href="#跳转页面" class="headerlink" title="跳转页面"></a>跳转页面</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于返回的json数据里面，每个新闻有个url，我们将url设为workflow的item args即可，代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wf.add_item(title=<span class="string">u"【&#123;&#125;】&#123;&#125;"</span>.format(r[<span class="string">"author_name"</span>], r[<span class="string">'title'</span>]),</span><br><span class="line">                       arg=r[<span class="string">'url'</span>],</span><br><span class="line">                       valid=<span class="literal">True</span>,</span><br><span class="line">                       icon=ICON_WEB)</span><br></pre></td></tr></table></figure><p>再在script filter之后接一个url即可：<br><img src="https://img-blog.csdnimg.cn/20210629100833240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Alfred&quot;&gt;&lt;a href=&quot;#Alfred&quot; class=&quot;headerlink&quot; title=&quot;Alfred&quot;&gt;&lt;/a&gt;Alfred&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用Mac的人应该大多都</summary>
      
    
    
    
    <category term="技巧" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="提升效率" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E5%B7%A7/%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87/"/>
    
    
    <category term="效率" scheme="https://ericzikun.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="学术" scheme="https://ericzikun.github.io/tags/%E5%AD%A6%E6%9C%AF/"/>
    
    <category term="Mac" scheme="https://ericzikun.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>多线程中的wait与sleep ,synchronize与lock有啥子区别?死锁辨析</title>
    <link href="https://ericzikun.github.io/2021/06/26/deep6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84wait%E4%B8%8Esleep-synchronize%E4%B8%8Elock%E6%9C%89%E5%95%A5%E5%AD%90%E5%8C%BA%E5%88%AB-%E6%AD%BB%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81%E8%BE%A8%E6%9E%90/"/>
    <id>https://ericzikun.github.io/2021/06/26/deep6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84wait%E4%B8%8Esleep-synchronize%E4%B8%8Elock%E6%9C%89%E5%95%A5%E5%AD%90%E5%8C%BA%E5%88%AB-%E6%AD%BB%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81%E8%BE%A8%E6%9E%90/</id>
    <published>2021-06-26T13:55:47.000Z</published>
    <updated>2021-06-29T06:01:58.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wait与sleep"><a href="#wait与sleep" class="headerlink" title="wait与sleep"></a>wait与sleep</h1><ol><li>来自不同的类<br>首先，wait和sleep都不是一个类下的方法：<br>wait来自：Object<br>sleep来自：Thread<img src="https://img-blog.csdnimg.cn/20210626221030902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210626221053496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></li></ol><p>因为java中所有的类都是继承自object的，所以所有类都可以调用wait方法，这是一个final的方法，同时不是一个静态方法，所以调用该方法需要先实例化一个Object对象才可以</p><ol start="2"><li>释放锁的不同<br>wait 会释放锁，sleep 睡觉了，抱着锁睡觉，不会释放!  也就是说，如果有两个线程，其中一个锁住了某个对象时，中间sleep了，这时候另一个线程时拿不到该对象的锁的，得等第一个线程sleep完并释放锁才可。<br>wait会释放这个锁，并把这个wait的线程加入到这个锁的等待队列中去</li><li>使用的范围不同<br>wait必须在同步代码块中使用</li><li>使用sleep不需要被唤醒，但是wait是需要notify()或者notifyAll()去唤醒的，除了wait(1000)这种形式.</li></ol><p>举例说明问题：</p><h1 id="synchronized与lock"><a href="#synchronized与lock" class="headerlink" title="synchronized与lock"></a>synchronized与lock</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized如果加在了非静态方法上，表示的是synchronized(调用方法的类的对象) {}，如果加在了静态方法上，表示的是synchronized(类.class) {}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferSynchronizedAndLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123; ticket.sale();</span><br><span class="line">            &#125; &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性、方法</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">        <span class="comment">// 卖票的方式</span></span><br><span class="line">        <span class="comment">// synchronized 本质: 队列，锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"卖出了"</span>+(number--)+<span class="string">"票,剩余:"</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210627101008598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>此处如果不对方法加synchronized修饰（不加锁）：<br><img src="https://img-blog.csdnimg.cn/20210627101419402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>Lock是一个接口，实现类有一下几个：<br><img src="https://img-blog.csdnimg.cn/20210627102346313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>先看可重入锁（ReentrantLock）：<br><img src="https://img-blog.csdnimg.cn/20210627102525603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>这里的可重入锁构造时候除非传入fair公平，否则默认为不公平锁。<br>公平锁：十分公平:可以先来后到<br>非公平锁：十分不公平:可以插队 (默认)<a href="https://blog.csdn.net/lsgqjh/article/details/63685058" target="_blank" rel="noopener">深入剖析ReentrantLock公平锁与非公平锁源码实现</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferSynchronizedAndLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123; ticket.sale();</span><br><span class="line">            &#125; &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性、方法</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 卖票的方式</span></span><br><span class="line">        <span class="comment">// synchronized 本质: 队列，锁</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"卖出了"</span>+(number--)+<span class="string">"票,剩余:"</span>+number);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized-与-lock区别"><a href="#synchronized-与-lock区别" class="headerlink" title="synchronized 与 lock区别"></a>synchronized 与 lock区别</h2><ol><li>synchronized 内置的Java关键字， Lock 是一个Java类</li><li>synchronized无法判断获取锁的状态，Lock 可以判断是否获取到了锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread提供了holdLock()方法检测当前线程是否持有锁，注意，是当前线程</span><br></pre></td></tr></table></figure></li><li>synchronized 会自动释放锁，lock 必须要手动释放锁!如果不释放锁，死锁</li><li>synchronized 线程 1(获得锁，阻塞)、线程2(只能等待);Lock锁就不一定会等待下去了，这里有个<strong>lock.tryLock()方法，尝试获取锁，可以做个判断让其尝试不到锁时不等待！！</strong></li><li>synchronized 可重入锁，不可以中断的，非公平;Lock ，可重入锁，可以 判断锁，非公平(可以在构造ReentrantLock()中自行设置boolean fair，true为公平，默认flase非公平</li><li>synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码!<h1 id="生产消费模型"><a href="#生产消费模型" class="headerlink" title="生产消费模型"></a>生产消费模型</h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 说白了就是多线程之间的通信，场景如下：有两个线程分别负责同一个资源类里变量的增加和减少，即生产与消费，对于增加和减少的逻辑：当资源中为0的时候，减少的方法就应该等待，不能再减少了；那么当资源不等于0 或者大于某个值时，增加方法就应该不再继续增加了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 具体方法总结：判断等待–&gt;业务–&gt;通知<h2 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a>synchronized实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题！  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A   B 操作同一个变量   num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210627120837300.png"  style="zoom:50%;" /></li></ol><h3 id="此处存在的问题"><a href="#此处存在的问题" class="headerlink" title="此处存在的问题"></a>此处存在的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 案例这样，如果只是两个线程通信，一个增加一个减少，必然不会出错，如果再增加几个呢？那notify之后，哪个线程来抢占呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/2021062714180563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过结果可以看出，有个值变成了2，也就是两个加法被唤醒了，且使得值均加了1。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于这里的资源类中增加和减少的方法使用的是if判断，所以也就只有一次判断，而wait之后，重新被唤醒要执行的是wait之后的语句，所以必须让他反复的判断一下值，这样才能保证线程安全！！将if改成while即可！！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if在官方文档中存在一个<strong>虚假唤醒的问题</strong><br><img src="https://img-blog.csdnimg.cn/20210627142330902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h2 id="lock锁实现"><a href="#lock锁实现" class="headerlink" title="lock锁实现"></a>lock锁实现</h2><p>Lock提供了condition.await(); 来替换等待，condition.signalAll(); 来替换唤醒全部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span></span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//condition.await(); // 等待</span></span><br><span class="line">    <span class="comment">//condition.signalAll(); // 唤醒全部</span></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务代码</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前面实现的都是随机的状态，也就是没有人为的去控制线程执行顺序，<strong>Condition可以精准的通知和唤醒！！</strong><br>这里提供一个场景：<strong>A 执行完调用B，B执行完调用C，C执行完调用A</strong>！！<br>这里如果num为1时，让A执行，num=2–&gt;B, num=3–&gt;C</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data3 data = <span class="keyword">new</span> Data3();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span></span>&#123; <span class="comment">// 资源类 Lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>; <span class="comment">// 1A  2B  3C</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;AAAAAAA"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，B</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;BBBBBBBBB"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，c</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;BBBBBBBBB"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，c</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210627144412929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70#pic_center =200x400"  style="zoom:50%;" /><p>输出结果即：A执行完通知B执行，B执行完通知C……..</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h2><p>多线程操作共享资源，存在同时对资源的读写 ，会导致资源的原子性遭到不一致处理 </p><p>需要锁操作来控制多个线程对象资源操作的原子性（安全性）</p><h2 id="锁的工作模式："><a href="#锁的工作模式：" class="headerlink" title="锁的工作模式："></a>锁的工作模式：</h2><p> 对于一个共享资源，我们有 lock 与 unlock 两个原子操作 </p><p>在一个线程对于一个资源进行操作的时候，实行lock 操作 ，这个时候其他线程就不能再操作这个资源对象了进入阻塞状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">有两个资源对象</span></span><br><span class="line"><span class="comment">一个是碗  一个是米饭</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有两个线程  T1  T2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">T1 拿了一个碗 想去盛饭 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">T2 拿了一份米饭  想拿这个碗来装</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">T1 可以拿到饭吗？ 不能 </span></span><br><span class="line"><span class="comment">T2 可以拿到碗吗？ 不能</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">package</span> com.thread0622;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str1 = <span class="string">"米饭"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str2 = <span class="string">"碗"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程1 持有米饭的监视器锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 持有 "</span> + str1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 想持有 "</span> + str2);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T1 End...."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 持有 "</span> + str2);</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁 的情况下想获取 米饭的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 想持有 "</span> + str1);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T2 End...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决死锁的办法"><a href="#解决死锁的办法" class="headerlink" title="解决死锁的办法"></a>解决死锁的办法</h1><p>1、在申请一个对象资源锁的时候  加入一个时间判断，释放手头所有的资源锁 </p><p>2、写代码时候，尽量避免这种情况的写法 ，嵌套资源锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread0622;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str1 = <span class="string">"米饭"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str2 = <span class="string">"碗"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程1 持有米饭的监视器锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 持有 "</span> + str1);</span><br><span class="line">&#125;<span class="comment">// 使用完一个资源之后就立即释放锁 </span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 想持有 "</span> + str2);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T1 End...."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 持有 "</span> + str2);</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁 的情况下想获取 米饭的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 想持有 "</span> + str1);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T2 End...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、finally 关键字  能够保证 finally 块中的代码   执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;wait与sleep&quot;&gt;&lt;a href=&quot;#wait与sleep&quot; class=&quot;headerlink&quot; title=&quot;wait与sleep&quot;&gt;&lt;/a&gt;wait与sleep&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;来自不同的类&lt;br&gt;首先，wait和sleep都不是一个类下的方</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="https://ericzikun.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Springboot项目docker部署配置文件外挂载</title>
    <link href="https://ericzikun.github.io/2021/06/26/Springboot%E9%A1%B9%E7%9B%AEdocker%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%96%E6%8C%82%E8%BD%BD/"/>
    <id>https://ericzikun.github.io/2021/06/26/Springboot%E9%A1%B9%E7%9B%AEdocker%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%96%E6%8C%82%E8%BD%BD/</id>
    <published>2021-06-26T13:49:57.000Z</published>
    <updated>2021-06-26T13:53:27.106Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 利用docker对一个Springboot打包时会遇到要及时更改相关数据库或者外部接口的ip及port，如果每次都进到容器内部修改，那一定非常麻烦，这里我想到了两种解决方案，并最终使用了后者。两种方法类似，无论哪种，都必须经过外挂载的步骤，也就是要把配置文件放到一个和宿主机映射的目录下：如图，这里采用的是docker-compose.yaml容器编排方式，不赘述：<br><img src="https://img-blog.csdnimg.cn/20210626214430420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将配置文件放在宿主机目录的config下，代码中写到“/usr/app_file/config/config/json”即可被容器访问到!</p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p>容器内运行jar包的CMD采用指定外部application.yml的命令：<br>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup jdk1<span class="number">.8</span><span class="number">.0_131</span>/bin/java -jar -Dspring.config.location=tmp/springboottmp/xxx.yaml tmp/service.jar --spring.profiles.active=test &gt; logs/xxxlog.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h2><p>不使用application.yml，用最原始的方式读取一个json文件的键值对，并替换代码变量即可,在Springboot config下定义一个JsonConfig类即可，代码简单，关键是要把地址写到容器内的与宿主机映射的<strong>外挂载目录下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String json_file = <span class="string">"/usr/app_file/config/es.json"</span>;</span><br><span class="line">        JSONObject configJ = <span class="keyword">this</span>.readJsonFile(json_file);</span><br><span class="line">        <span class="keyword">if</span>(configJ.containsKey(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> configJ.getString(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">readJsonFile</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        String readJson = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">            InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(fileInputStream, <span class="string">"UTF-8"</span>);</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">            String tempString = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((tempString = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                readJson += tempString;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="comment">// 获取json</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jsonObject = JSONObject.parseObject(readJson);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JSONException e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 利用docker对一个Springboot打包时会遇到要及时更改相关数据库或者外部接口的ip及port，如果每次都进到容器内部修改，那一定非常麻烦，这里我想到了两种解决方案，并最终使用了后</summary>
      
    
    
    
    <category term="技术栈" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="Springboot" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/Springboot/"/>
    
    
    <category term="Springboot" scheme="https://ericzikun.github.io/tags/Springboot/"/>
    
    <category term="Docker" scheme="https://ericzikun.github.io/tags/Docker/"/>
    
    <category term="JSON" scheme="https://ericzikun.github.io/tags/JSON/"/>
    
  </entry>
  
</feed>
