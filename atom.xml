<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EricKun</title>
  
  
  <link href="https://ericzikun.github.io/atom.xml" rel="self"/>
  
  <link href="https://ericzikun.github.io/"/>
  <updated>2022-01-27T15:18:05.595Z</updated>
  <id>https://ericzikun.github.io/</id>
  
  <author>
    <name>Eric kun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL底层采用B+ tree的原因剖析【哈希、平衡二叉、B树为啥不行？】</title>
    <link href="https://ericzikun.github.io/2022/01/27/deep14-MySQL%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8B-tree%E7%9A%84%E5%8E%9F%E5%9B%A0/"/>
    <id>https://ericzikun.github.io/2022/01/27/deep14-MySQL%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8B-tree%E7%9A%84%E5%8E%9F%E5%9B%A0/</id>
    <published>2022-01-27T15:12:04.000Z</published>
    <updated>2022-01-27T15:18:05.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引底层采用B-tree的原因"><a href="#MySQL索引底层采用B-tree的原因" class="headerlink" title="MySQL索引底层采用B+ tree的原因"></a>MySQL索引底层采用B+ tree的原因</h1><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/ClosedHash.html</a></p><p>通过 哈希 函数计算和类似取余运算，可以将元素插入到对应的bucket中，find的过程是o(1)时间复杂度，那find速度这么快，为啥Mysql底层不用呢？</p><p> <img src="https://img-blog.csdnimg.cn/df8153bbe6144c2fa2ea631bf22dac01.gif" alt="在这里插入图片描述"></p><p>因为Mysql的查询涉及大量的范围查询，Hash索引这个无序集合，是不支持范围查询的，再比如mysql的排序查询（order by），而哈希是无序的，也无法支持！就像我们的uuid是无序的，不可能用他来做主键。</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</a></p><p>平衡二叉树的左右子树的高度差不会大于1。</p><p>无论怎么插，高度差都会维持，</p><p>随着树的高度增加，他的查询速度也会逐渐变慢，</p><p>比如这里找8，一次就找到了，但是找10找了三次。</p><p>还有一个致命缺点，如果我们去查5，通过三次定位找到了5，如果要找大于5的数据，就要从5这个节点往回查找，找到6，7，再回到更上一层的8，往下再9、10，这样才把大于5的数据找出来了，想象一下，如果大于5的数据特别多，那么回旋查询的次数就会增多，在这种范围查找上的效率很低。</p><p>这就是平衡二叉树的缺点：</p><ul><li><p>高度越高，查询速度越慢</p></li><li><p>范围查找需要回旋的次数很大，效率低</p><p><img src="https://img-blog.csdnimg.cn/de7ce7d8c3814a3a955733f229b84e38.gif" alt="在这里插入图片描述"></p></li></ul><p><img src="https://img-blog.csdnimg.cn/8497978b36c145cca37c16a127c4617b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p><p> <img src="https://img-blog.csdnimg.cn/77e9a5963064495a8ad671671201ab37.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1c2b6713610e4b15bd504a2830e8a375.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>B树最大的特点就是一个节点可以存两个值</p><p>这样存储有什么好处呢？</p><p>对比平衡二叉树，同时存10个数字的情况下，平衡二叉树有4层，而B树只有三层。</p><p>树的高度上面，B树更优（毕竟一个节点存放的数字更多了，更紧凑）</p><p>变矮之后的好处就在于：查询的效率变高了，查数字的速度更快了</p><p>样例：之前平衡树找10需要找3次，而B树只用了2次。</p><p>所以，<strong>从平衡二叉树-&gt;B树，解决了树的高度的问题，树越矮，查询的效率越高。</strong></p><p>那么，B树存在回旋查找的问题吗？答案是肯定的：</p><p>比如要查找大于5的数，一样需要回旋到上一层的6、8…，所以B树的范围查找仍然不太理想。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+ Tree"></a>B+ Tree</h2><p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p><p> <img src="https://img-blog.csdnimg.cn/6eb238e2215348c082328ca82630ecf5.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3e8f3c6e346942e2a52b2ca4a35a1647.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>B+树彻底解决了回旋查找的问题</p><p>它和B树的共同特点是一个节点可以存两个值，B+树和B树的明显区别就在叶子节点，B+树用了一个链表去解决了回旋查找的问题（比如查找大于5的数，找到5之后，通过链表直接把后面的数字全拿出来了），所以范围查找的效率极高。</p><p><strong>这也解释了为什么排序的时候要用索引去排序，因为B+树已经帮我们排好序了！我们按照索引排序的话，就不会触发文件内排序了！</strong></p><p>上面的树和叶子节点的关系：</p><ul><li><p>凡是非叶子结点出现的数组都会出现的叶子节点</p></li><li><p>非叶子节点只存储key，不存储value，这里的key就是这些数字索引，而叶子节点存储的除了key之外，还有value（数字的地址）</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL索引底层采用B-tree的原因&quot;&gt;&lt;a href=&quot;#MySQL索引底层采用B-tree的原因&quot; class=&quot;headerlink&quot; title=&quot;MySQL索引底层采用B+ tree的原因&quot;&gt;&lt;/a&gt;MySQL索引底层采用B+ tree的原因&lt;/h1</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="数据库" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://ericzikun.github.io/tags/MySQL/"/>
    
    <category term="B+树" scheme="https://ericzikun.github.io/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL如何通过索引找到一条真实的数据？</title>
    <link href="https://ericzikun.github.io/2022/01/27/deep15-MySQL%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E6%89%BE%E5%88%B0%E4%B8%80%E6%9D%A1%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>https://ericzikun.github.io/2022/01/27/deep15-MySQL%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E6%89%BE%E5%88%B0%E4%B8%80%E6%9D%A1%E7%9C%9F%E5%AE%9E%E7%9A%84%E6%95%B0%E6%8D%AE/</id>
    <published>2022-01-27T15:10:58.000Z</published>
    <updated>2022-01-27T15:16:27.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL如何通过索引找到一条真实的数据"><a href="#MySQL如何通过索引找到一条真实的数据" class="headerlink" title="MySQL如何通过索引找到一条真实的数据"></a>MySQL如何通过索引找到一条真实的数据</h1><h2 id="Mylsan和-InnoDB常见区别"><a href="#Mylsan和-InnoDB常见区别" class="headerlink" title="Mylsan和 InnoDB常见区别"></a>Mylsan和 InnoDB常见区别</h2><h3 id="事务方面"><a href="#事务方面" class="headerlink" title="事务方面"></a>事务方面</h3><p>noDB支持事务, MyISAM不支持事务。这是 MySQL将默认存储引擎从 MyISAM变成 innoDB的重要原因之</p><h3 id="外键方面"><a href="#外键方面" class="headerlink" title="外键方面"></a>外键方面</h3><p>nnoDB支持外键,而 MyISAM不支持。对一个包含外键的 innoDB表转为 MYISAM会失败。</p><h3 id="索引层面"><a href="#索引层面" class="headerlink" title="索引层面"></a>索引层面</h3><p>innoDB是<strong>聚集(聚簇)索引</strong>, MyISAM是非聚集(非聚簇)索引。后面会重点讲解这两种索引的区别<br>MyISAM支持 FULLTEXT类型的<strong>全文索引,</strong><br>innoDB不支持 FULLTEXT类型的全文索引,但是 innoDB可以使用 sphinx插件支持全文索引,并且效果更好。</p><h3 id="锁粒度方面"><a href="#锁粒度方面" class="headerlink" title="锁粒度方面"></a>锁粒度方面</h3><p>innoDB最小的锁粒度是行锁, MyISAM最小的锁粒度是表锁。<br>一个更新语句会锁住整张表,导致其他查询和更新都会被阻塞,因此并发访问受限</p><p>这也是MySQL将默认存储引擎从MyISAM变成InnoDB的重要原因之一。</p><h3 id="硬盘存储结构"><a href="#硬盘存储结构" class="headerlink" title="硬盘存储结构"></a>硬盘存储结构</h3><p>MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。</p><ul><li>frm文件存储表的定义</li><li>数据文件的扩展名为.MND( MYData)</li><li>素引文件的扩展名是,MYr( MYIndex)</li></ul><p>Innodb存储引擎存储数据库数据，一共有两个文件（没有专门保存数据的文件）：</p><ul><li>frm文件存储表的定义</li><li>Ibd文件：数据和索引存储文件。数据以主键进行聚集存储，把真正的数据保存在叶子节点中。</li></ul><h3 id="聚簇索引-和非聚簇索引"><a href="#聚簇索引-和非聚簇索引" class="headerlink" title="聚簇索引 和非聚簇索引"></a>聚簇索引 和非聚簇索引</h3><h4 id="聚簇索引-InnoDB"><a href="#聚簇索引-InnoDB" class="headerlink" title="聚簇索引( InnoDB)"></a>聚簇索引( InnoDB)</h4><p>将<strong>数据存储</strong>与<strong>素引</strong>放到了一块,索引结构的<strong>叶子节点保存了数据</strong>（B+ tree）<br>表数据按照索引的顺序来存储的,也就是说索引项的顺序与表中记录的物理顺序一致。<br>InnoDB中,在聚簇索引之上创建的索引称之为辅助索引,像复合索引、前缀索引、唯一索引等等。</p><ul><li>聚簇索引默认是主键</li><li>如果表中没有定义主键, InnoDB会选择一个<strong>唯一的非空索引代替</strong>。【唯一非空索引】</li><li>如果没有这样的索引, InnoDB会在内部生成一个名为GEN_ CLUST INDEX的隐式的聚簇索引。</li></ul><h4 id="非聚簇索引-MyISAM"><a href="#非聚簇索引-MyISAM" class="headerlink" title="非聚簇索引( MyISAM)"></a>非聚簇索引( MyISAM)</h4><p>将数据与索引分开存储,表数据存储顺序与索引顺序无关。</p><h2 id="MyISAM索引查询数据过程"><a href="#MyISAM索引查询数据过程" class="headerlink" title="MyISAM索引查询数据过程"></a>MyISAM索引查询数据过程</h2><p><img src="https://img-blog.csdnimg.cn/8b845237939f4e40bc068520efd7c781.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>该图的左边是索引文件，右边是数据文件。</p><p>索引文件和数据文件是分开存储的。</p><p>之前提到过，索引是B+ tree存储的，左图的非叶子节点就是主键id，叶子结点存储的除了id外，还有每一行数据的物理存储地址，通过B+ tree找到id对应的地址，再通过右边的地址映射找到数据。</p><h2 id="InnoDB索引结构"><a href="#InnoDB索引结构" class="headerlink" title="InnoDB索引结构"></a>InnoDB索引结构</h2><p><img src="https://img-blog.csdnimg.cn/9cf035b3883946a5ae135935a6137ee2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p> 对于InnoDB来说，它的索引和数据是存储到同一个文件里面去的，</p><ul><li>左图叫聚簇索引：InnoDB中以主键id为索引key</li><li>右图是辅助索引：别的字段为索引</li></ul><p>InnoDB同样是B+ tree，而这里和MyISAM引擎不同的是，叶子节点储存的不再是物理地址，而是真实的数据！</p><p>比如找id为15的数据，通过左图的B+ tree找到它对应的叶子结点，直接就把它整行的数据都拿出来了，不用再去找物理地址了！【和MyISAM区分开】</p><p>右图：辅助索引的叶子节点存储的是辅助索引key和它对应的id主键，而不是整行的数据！所以如果要如果user_name这个辅助索引找整行的数据，比如找user_name = Eric的整行数据，先要通过右图辅助索引找到它对应的id，然后再通过左图的聚簇索引找到它对应的叶子节点，从而才能拿到整行的数据！</p><p>这样就解释了，为什么 select的时候，尽量使用<strong>覆盖索引</strong>，也就是和后面检索条件中的索引尽可能一致或者是查它id，这样一次查到，而不用再去左图聚簇索引中查了！</p><h2 id="对比MyISAM和InnoDB"><a href="#对比MyISAM和InnoDB" class="headerlink" title="对比MyISAM和InnoDB"></a>对比MyISAM和InnoDB</h2><ul><li><p>MyISAM：无论是主键索引还是普通索引，查找数据的流程都是一样的，都会先去B+ tree找到对应叶子节点，再去物理地址取数据。【<strong>先找地址，再通过地址找数据</strong>】</p></li><li><p>InnDB，查找数据的流程分为两种类型</p><ul><li>聚簇索引：通过主键id能够直接取出全部数据（叶子节点中存放真实数据）</li><li>辅助索引：通过索引找到对应id，再通过聚簇索引的B+ tree找到真实数据，要找两次！</li></ul></li><li><p>InnoDB在<strong>聚簇索引</strong>的查询过程中比MyISAM快一些；InnoDB辅助索引的查询过程在一定程度上比MyISAM慢一些</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL如何通过索引找到一条真实的数据&quot;&gt;&lt;a href=&quot;#MySQL如何通过索引找到一条真实的数据&quot; class=&quot;headerlink&quot; title=&quot;MySQL如何通过索引找到一条真实的数据&quot;&gt;&lt;/a&gt;MySQL如何通过索引找到一条真实的数据&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="数据库" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://ericzikun.github.io/tags/MySQL/"/>
    
    <category term="B+树" scheme="https://ericzikun.github.io/tags/B-%E6%A0%91/"/>
    
    <category term="索引" scheme="https://ericzikun.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
    <category term="InnoDB" scheme="https://ericzikun.github.io/tags/InnoDB/"/>
    
    <category term="MyISAM" scheme="https://ericzikun.github.io/tags/MyISAM/"/>
    
  </entry>
  
  <entry>
    <title>还不了解lambda？还再用迭代遍历操作集合？赶紧上Stream流！</title>
    <link href="https://ericzikun.github.io/2021/11/28/deep13-%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86Java-lambda-Stream-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://ericzikun.github.io/2021/11/28/deep13-%E7%B3%BB%E7%BB%9F%E6%A2%B3%E7%90%86Java-lambda-Stream-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-11-28T02:18:50.000Z</published>
    <updated>2021-11-28T02:33:33.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数式编程（Lambda-amp-amp-Stream）"><a href="#函数式编程（Lambda-amp-amp-Stream）" class="headerlink" title="函数式编程（Lambda &amp;&amp; Stream）"></a>函数式编程（Lambda &amp;&amp; Stream）</h1><p>参考：《Java8实战》+《B站三更草堂》</p><h1 id="以sort引入"><a href="#以sort引入" class="headerlink" title="以sort引入"></a>以sort引入</h1><p>匿名内部类-&gt;lambda</p><p>​    我们常常用传入Comparator来完成排序行为的传入，这里我们传进去的实际上是如何排序这个行为，lambda实际上就是让我们尽可能的去关注这个行为本身，至于Comparator这个接口里面要覆盖重写的方法叫啥，我们其实没必要过多的关心，关注一下返回类型就够了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line">        Collections.sort(integers, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(integers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个简单例子很容易转换为lambda，这里刚开始不熟悉，可以直接使用IDEA的自动转换功能</p><p> <img src="https://img-blog.csdnimg.cn/c314e2b31afe4399b7ff22f750f4b8e3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; integers = Arrays.asList(<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">10</span>);</span><br><span class="line">       Collections.sort(integers, (o1, o2) -&gt; o1-o2);</span><br><span class="line">       System.out.println(integers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="几个官方提供的接口"><a href="#几个官方提供的接口" class="headerlink" title="几个官方提供的接口"></a>几个官方提供的接口</h1><h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p>​    再来几个官方提供的常用接口，其实接口叫什么名字并不重要，具体的行为是我们程序员去设计的，我们只需要关注它的返回值类型就行了，比如Predicate这个接口</p><p>​    比如我们要对一组数做相同的判定操作，这个判定操作返回的就是布尔类型，每个数字是或否，那么官方提供的IntPredicate这个接口的test方法就能满足我们这个需求，我们只需要在调用printNum方法时，传入判定的具体内容，就可以灵活改变判定行为了，这个在《Java8实战》中聊的比较多，主要是为了方法的扩展性，当需求不断变更时，我们只需要去改变传入的行为即可，而不是整篇代码大幅度修改，那么显得并不那么优雅！<br><img src="https://img-blog.csdnimg.cn/51b61fd839a94533a53bc7daba18f5fd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       printNum(<span class="keyword">new</span> IntPredicate() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">           </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> value%<span class="number">2</span>==<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           &#125; &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(IntPredicate predicate)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">           <span class="keyword">if</span>(predicate.test(i))&#123; System.out.println(i);</span><br><span class="line">           &#125; &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>​    Function函数简单来说，就是传入一个类型T，返回一个类型R，具体怎么操作T这个传入，自己来定行为即可！</p><p>这样就大大扩展了我们实际想去传入的这个行为，因为这个行为的扩展还包括了我们想灵活定制的传入传出类型！比如这里我们将字符串接受，返回Integer类型：<br><img src="https://img-blog.csdnimg.cn/ceb47129de1f41649027f79fb6bfa07e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer result = typeConver(<span class="keyword">new</span> Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">apply</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.valueOf(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">typeConver</span><span class="params">(Function&lt;String, R&gt; function)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"1235"</span>;</span><br><span class="line">        R result = function.apply(str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c256eaf7438b450097306cd7cfb7cd50.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>还可以对输出类型做改变，比如改成双层List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = typeConver(<span class="keyword">new</span> Function&lt;String, List&lt;List&lt;Integer&gt;&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; apply(String s) &#123;</span><br><span class="line"></span><br><span class="line">                List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                integers.add(Integer.valueOf(s));</span><br><span class="line">                List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(integers);</span><br><span class="line">                <span class="keyword">return</span> list;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R&gt; <span class="function">R <span class="title">typeConver</span><span class="params">(Function&lt;String, R&gt; function)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"1235"</span>;</span><br><span class="line">        R result = function.apply(str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/1865897b7c4b4e5ab1b32a3f66c0c27a.png" alt="在这里插入图片描述"></p><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>​    这个接口返回的类型最简单，因为它没有返回，比如这个IntConsumer，接受的Int类型，啥也不返回，一般我们主要用于打印语句上：</p><p>​    当然还有Consumer<T>，void accept(T t)接受泛型输入</p><p> <img src="https://img-blog.csdnimg.cn/979d6217e97a4b8ab6d818ac4038d57b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       foreachArr(<span class="keyword">new</span> IntConsumer() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">               System.out.println(value);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foreachArr</span><span class="params">(IntConsumer consumer)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">           consumer.accept(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h2><p>生产型接口</p><p>根据其中抽象方法的参数列表和返回值类型知道，我们可以在方法中创建对象，把创建好的对象返回</p><p><img src="https://img-blog.csdnimg.cn/daea3d4c566743bd97fb570a08f2a8c0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="流Stream"><a href="#流Stream" class="headerlink" title="流Stream"></a>流Stream</h1><p>​    流的操作主要分为创建、中间操作、终结操作：</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>​    创建很简单，分为集合单列对象、数组、双列集合（Map-&gt;entrySet）</p><p>集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line">Stream&lt;Author&gt; stream = authors.stream();</span><br></pre></td></tr></table></figure><p>数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(arr); </span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.of(arr);</span><br></pre></td></tr></table></figure><p>双列集合：</p><p>本质上还是将Map转化为单列集合entrySet 再做流操作，和前面一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">map.put(<span class="string">"蜡笔小新"</span>,<span class="number">19</span>);</span><br><span class="line">map.put(<span class="string">"黑子"</span>,<span class="number">17</span>);</span><br><span class="line">map.put(<span class="string">"日向翔阳"</span>,<span class="number">16</span>);</span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = map.entrySet().stream();</span><br></pre></td></tr></table></figure><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="流式debug"><a href="#流式debug" class="headerlink" title="流式debug"></a>流式debug</h3><p> <img src="https://img-blog.csdnimg.cn/fc7644b506234c1e9e16e7c4a413569c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>​    过滤操作，简单来说就是对集合中的元素根据每个判定条件筛选过滤，比如年龄都大于18、名字长度都小于3…<br>​    前面调到了Predicate，返回一个布尔类型判定, 这里的filter传入的就是该匿名内部类，可以对集合里面的元素对象的属性做任何值的判定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">       authors.stream()<span class="comment">//把集合转换成流</span></span><br><span class="line">               .distinct()<span class="comment">//先去除重复的作家</span></span><br><span class="line">               .filter(<span class="keyword">new</span> Predicate&lt;Author&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">                       <span class="keyword">return</span>  author.getAge() &lt; <span class="number">18</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;)<span class="comment">//筛选年龄小于18的</span></span><br><span class="line">               .forEach(author -&gt; System.out.println(author.getName()));<span class="comment">//遍历打印名字</span></span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()<span class="comment">//把集合转换成流</span></span><br><span class="line">                .distinct()<span class="comment">//先去除重复的作家</span></span><br><span class="line">                .filter(<span class="keyword">new</span> Predicate&lt;Author&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span>  author.getAge() &lt; <span class="number">18</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)<span class="comment">//筛选年龄小于18的</span></span><br><span class="line">                .forEach(author -&gt; System.out.println(author.getName()));<span class="comment">//遍历打印名字</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>​    map操作相当于是将集合里面的对象一一映射到另一个对象上去，比如我想拿到作者集合中的所有人名，类型为List&lt;String&gt;而不是List&lt;Author&gt;，这里就已经改变了集合中的元素类型了，按传统方法不用流的话，就要再new一个List&lt;String&gt;，遍历一遍List&lt;Author&gt;，不断的add，相当不优雅！这里直接用map操作得到想要的映射对象。</p><p>​    那么此处传入的接口应该是啥呢？很明显是前后类型不一致，传入的就是Function接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.map(<span class="keyword">new</span> Function&lt;Author, String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Author author)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> author.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()<span class="comment">//把集合转换成流</span></span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .forEach(authorName -&gt; System.out.println(authorName));<span class="comment">//遍历打印名字</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b3051af8557d4d4aa349337663a351cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>​    这个很简单，就是<strong>去重</strong>操作，基于对象的equals重写方法，一般默认去比较对象的属性值是否相等，如果作者的名字、年龄等其他属性都相等的情况下，说明是同一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line">authors.stream()</span><br><span class="line">       .distinct()</span><br><span class="line">.forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>​    这个排序操作，本文一开始就引入了，这里就不赘述了，直接上代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Author&gt; authors = getAuthors(); 对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。</span><br><span class="line">authors.stream() </span><br><span class="line">  .distinct()</span><br><span class="line">    .sorted((o1, o2) -&gt; o2.getAge()-o1.getAge()) </span><br><span class="line">  .forEach(author -&gt;System.out.println(author.getAge()));</span><br></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>​    flatMap，翻译过来就是平铺下去，和map的区别在于，map是一个对象对应一个值做映射，而flatMap中一个对象可以对应多个值，比如这里每个作者有一个Book集合，我们想把所有Book都放在一个集合中，这里相当于把每个对象所对应关联的那个属性值拼接在一个集合里面，就可以这样做：</p><p>​    这里Function第二个参数是Stream，要记得转换一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//     打印所有书籍的名字。要求对重复的元素进行去重。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()</span><br><span class="line">                .flatMap(<span class="keyword">new</span> Function&lt;Author, Stream&lt;? extends Book&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Stream&lt;? extends Book&gt; apply(Author author) &#123;</span><br><span class="line">                        <span class="keyword">return</span> author.getBooks().stream();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;) .distinct()</span><br><span class="line">                .forEach(book -&gt; System.out.println(book.getName()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//     打印所有书籍的名字。要求对重复的元素进行去重。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()</span><br><span class="line">                .flatMap(author -&gt; author.getBooks().stream()) .distinct()</span><br><span class="line">                .forEach(book -&gt; System.out.println(book.getName()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>​    设置一个返回的长度限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line">authors.stream()</span><br><span class="line">.distinct()</span><br><span class="line">.sorted()</span><br><span class="line">.limit(<span class="number">2</span>)</span><br><span class="line">.forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h3><p>​    跳过几个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line">authors.stream()</span><br><span class="line">.distinct()</span><br><span class="line">.sorted()</span><br><span class="line">.skip(<span class="number">1</span>)</span><br><span class="line">.forEach(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h2 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h2><p>​    在前面流已经经过了一些列中间操作，对元素中的对象比如做了筛选过滤、去重、后者映射等等，现在已经有这些元素了，下面要对这些元素进行最终的输出，可以采用以下几种方式，最简单的遍历foreach（最常用的就是打印输出每个元素），count统计个数、max&amp;min计算值的最值、collect用于将元素转化为List输出或者合并字符串等等。</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印所有年龄小于18的作家的名字，并且要注意去重</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        authors.stream()<span class="comment">//把集合转换成流</span></span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .forEach(authorName -&gt; System.out.println(authorName));<span class="comment">//遍历打印名字</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="max-amp-min"><a href="#max-amp-min" class="headerlink" title="max&amp;min"></a>max&amp;min</h3><p>​    可以用来或者流中的最值。 例子:</p><p>分别获取这些作家的所出书籍的最高分和最低分并打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">       Optional&lt;Integer&gt; max = authors.stream()</span><br><span class="line">               .flatMap(author -&gt; author.getBooks().stream()).map(book -&gt; book.getScore())</span><br><span class="line">               .max((score1, score2) -&gt; score1 - score2);</span><br><span class="line">       Optional&lt;Integer&gt; min = authors.stream().flatMap(author -&gt; author.getBooks().stream()).map(book -&gt; book.getScore())</span><br><span class="line">               .min((score1, score2) -&gt; score1 - score2);</span><br><span class="line">       System.out.println(max.get());</span><br><span class="line">       System.out.println(min.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p>把当前流转换成一个集合。 例子:</p><p>获取一个存放所有作者名字的List集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        List&lt;String&gt; nameList = authors.stream()</span><br><span class="line">                .map(author -&gt; author.getName())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        System.out.println(nameList);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/edbbcd8252624fdb8d9deeabe964b722.png" alt="在这里插入图片描述"></p><p>这里还有个骚操作，可以转化为Map，设定好key和value分别是什么即可，类型可以自定义，依旧还是Function接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="comment">//        Map&lt;String, List&lt;Book&gt;&gt; map = authors.stream().distinct()</span></span><br><span class="line"><span class="comment">//                .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getBooks()));</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = authors.stream().distinct()</span><br><span class="line">                .collect(Collectors.toMap(author -&gt; author.getName(), author -&gt; author.getAge()));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>查找与匹配</p><h3 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h3><p>可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。</p><p>例子: 判断是否有年龄在29以上的作家</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 判断是否有年龄在29以上的作家 </span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line"><span class="keyword">boolean</span> flag = authors.stream()</span><br><span class="line">.anyMatch(author -&gt; author.getAge() &gt; <span class="number">29</span>); </span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure><h3 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h3><p>可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。 例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 判断是否所有的作家都是成年人 </span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors(); </span><br><span class="line"><span class="keyword">boolean</span> flag = authors.stream()</span><br><span class="line">.allMatch(author -&gt; author.getAge() &gt;= <span class="number">18</span>); </span><br><span class="line">System.out.println(flag);</span><br></pre></td></tr></table></figure><h3 id="noneMatch"><a href="#noneMatch" class="headerlink" title="noneMatch"></a>noneMatch</h3><p>可以判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则结果为false 例子:</p><p>判断作家是否都没有超过100岁的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">// 判断作家是否都没有超过100岁的。 </span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line"><span class="keyword">boolean</span> b = authors.stream()</span><br><span class="line">.noneMatch(author -&gt; author.getAge() &gt; <span class="number">100</span>);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure><h3 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h3><p>​    获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。</p><p>例子：</p><p>​    获取任意一个年龄大于18的作家，如果存在就输出他的名字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        获取任意一个年龄大于18的作家，如果存在就输出他的名字</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Optional&lt;Author&gt; optionalAuthor = authors.stream()</span><br><span class="line">                .filter(author -&gt; author.getAge()&gt;<span class="number">18</span>)</span><br><span class="line">                .findAny();</span><br><span class="line"></span><br><span class="line">        optionalAuthor.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h3><p>​    获取流中的第一个元素。</p><p>例子：</p><p>​    获取一个年龄最小的作家，并输出他的姓名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        获取一个年龄最小的作家，并输出他的姓名。</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Optional&lt;Author&gt; first = authors.stream()</span><br><span class="line">                .sorted((o1, o2) -&gt; o1.getAge() - o2.getAge())</span><br><span class="line">                .findFirst();</span><br><span class="line"></span><br><span class="line">        first.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="reduce归并"><a href="#reduce归并" class="headerlink" title="reduce归并"></a>reduce归并</h3><p>​    对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）</p><p>​    reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。</p><p>​    reduce两个参数的重载形式内部的计算方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T result = identity;</span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">result = accumulator.apply(result, element)</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>​    其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。</p><p>例子：</p><p>​    使用reduce求所有作者年龄的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者年龄的和</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Integer sum = authors.stream()</span><br><span class="line">                .distinct()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .reduce(<span class="number">0</span>, (result, element) -&gt; result + element);</span><br><span class="line">        System.out.println(sum);</span><br></pre></td></tr></table></figure><p>​    使用reduce求所有作者中年龄的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最大值</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Integer max = authors.stream()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .reduce(Integer.MIN_VALUE, (result, element) -&gt; result &lt; element ? element : result);</span><br><span class="line"></span><br><span class="line">        System.out.println(max);</span><br></pre></td></tr></table></figure><p>​    使用reduce求所有作者中年龄的最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最小值</span></span><br><span class="line">        List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">        Integer min = authors.stream()</span><br><span class="line">                .map(author -&gt; author.getAge())</span><br><span class="line">                .reduce(Integer.MAX_VALUE, (result, element) -&gt; result &gt; element ? element : result);</span><br><span class="line">        System.out.println(min);</span><br></pre></td></tr></table></figure><p>​    reduce一个参数的重载形式内部的计算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> foundAny = <span class="keyword">false</span>;</span><br><span class="line">  T result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (T element : <span class="keyword">this</span> stream) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">          foundAny = <span class="keyword">true</span>;</span><br><span class="line">          result = element;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          result = accumulator.apply(result, element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br></pre></td></tr></table></figure><p>​    如果用一个参数的重载方法去求最小值代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        使用reduce求所有作者中年龄的最小值</span></span><br><span class="line">List&lt;Author&gt; authors = getAuthors();</span><br><span class="line">Optional&lt;Integer&gt; minOptional = authors.stream()</span><br><span class="line">        .map(author -&gt; author.getAge())</span><br><span class="line">        .reduce((result, element) -&gt; result &gt; element ? element : result);</span><br><span class="line">minOptional.ifPresent(age-&gt; System.out.println(age));</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）</li><li>流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用）</li><li>不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）</li></ul><h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><p>​    我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。</p><p>​    例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Author author = getAuthor();</span><br><span class="line"><span class="keyword">if</span>(author!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(author.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    尤其是对象中的属性还是一个对象的情况下。这种判断会更多。    </p><p>​    而过多的判断语句会让我们的代码显得臃肿不堪。</p><p>​    所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。</p><p>​    并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>​    Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。</p><p>​    我们一般使用<strong>Optional</strong>的<strong>静态方法ofNullable</strong>来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Author author = getAuthor();</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(author);</span><br></pre></td></tr></table></figure><p>​    你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果改造下getAuthor方法，让其的返回值就是封装好的Optional的话，我们在使用时就会方便很多。</p><p>​    而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。</p><p>​    如果你<strong>确定一个对象不是空</strong>的则可以使用<strong>Optional</strong>的<strong>静态方法of</strong>来把数据封装成Optional对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Author author = <span class="keyword">new</span> Author();</span><br><span class="line">Optional&lt;Author&gt; authorOptional = Optional.of(author);</span><br></pre></td></tr></table></figure><p>​    但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果）</p><p>​    如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用<strong>Optional</strong>的<strong>静态方法empty</strong>来进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.empty()</span><br></pre></td></tr></table></figure><p>​    </p><p>​    所以最后你觉得哪种方式会更方便呢？<strong>ofNullable</strong></p><h3 id="安全消费值"><a href="#安全消费值" class="headerlink" title="安全消费值"></a>安全消费值</h3><p>​    我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其<strong>ifPresent</strong>方法对来消费其中的值。</p><p>​    这个方法会判断其内封装的数据是否为空，不为空时才会执行具体的消费代码。这样使用起来就更加安全了。</p><p>​    例如,以下写法就优雅的避免了空指针异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"></span><br><span class="line">authorOptional.ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h3><p>​    如果我们想获取值自己进行处理可以使用get方法获取，但是不推荐。因为当Optional内部的数据为空的时候会出现异常。</p><h3 id="安全获取值"><a href="#安全获取值" class="headerlink" title="安全获取值"></a>安全获取值</h3><p>​    如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。</p><ul><li><p>orElseGet</p><p>获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line">Author author1 = authorOptional.orElseGet(() -&gt; <span class="keyword">new</span> Author());</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>orElseThrow</p><p>获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Author author = authorOptional.orElseThrow((Supplier&lt;Throwable&gt;) () -&gt; <span class="keyword">new</span> RuntimeException(<span class="string">"author为空"</span>));</span><br><span class="line">    System.out.println(author.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">    throwable.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>​    我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line">authorOptional.filter(author -&gt; author.getAge()&gt;<span class="number">100</span>).ifPresent(author -&gt; System.out.println(author.getName()));</span><br></pre></td></tr></table></figure><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>​    我们可以使用isPresent方法进行是否存在数据的判断。如果为空返回值为false,如果不为空，返回值为true。但是这种方式并不能体现Optional的好处，<strong>更推荐使用ifPresent方法</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Author&gt; authorOptional = Optional.ofNullable(getAuthor());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (authorOptional.isPresent()) &#123;</span><br><span class="line">    System.out.println(authorOptional.get().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>​    Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。</p><p>例如我们想获取作家的书籍集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Optional&lt;Author&gt; authorOptional = getAuthorOptional();</span><br><span class="line">    Optional&lt;List&lt;Book&gt;&gt; optionalBooks = authorOptional.map(author -&gt; author.getBooks());</span><br><span class="line">    optionalBooks.ifPresent(books -&gt; System.out.println(books));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数式编程（Lambda-amp-amp-Stream）&quot;&gt;&lt;a href=&quot;#函数式编程（Lambda-amp-amp-Stream）&quot; class=&quot;headerlink&quot; title=&quot;函数式编程（Lambda &amp;amp;&amp;amp; Stream）&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="lambda" scheme="https://ericzikun.github.io/tags/lambda/"/>
    
    <category term="Stream" scheme="https://ericzikun.github.io/tags/Stream/"/>
    
    <category term="函数式编程" scheme="https://ericzikun.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="匿名内部类" scheme="https://ericzikun.github.io/tags/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java方法传参/值传递/引用传递</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep12-Java%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82-%E5%80%BC%E4%BC%A0%E9%80%92-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep12-Java%E6%96%B9%E6%B3%95%E4%BC%A0%E5%8F%82-%E5%80%BC%E4%BC%A0%E9%80%92-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</id>
    <published>2021-11-06T09:53:48.000Z</published>
    <updated>2021-11-28T02:21:15.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文主要讲解Java方法传参、值传递、引用传递，其中涉及到JVM的相关知识，最近弥补了这一块，发现理解很多问题都变得豁然开朗了，知其所以然！（JVM在我其他博客中有详细辨析）<br><img src="https://img-blog.csdnimg.cn/c67559137da140af82c20d0920c3864e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在刷力扣题目时，遇到这样一个问题，当我把一个变量传进dfs方法后，无论递归中如何对该变量赋值，最终都没有生效，今来探究其原因，说到底还是Java值传递、引用传递的问题：</p><h2 id="方法传参"><a href="#方法传参" class="headerlink" title="方法传参"></a>方法传参</h2><p>Java的方法传值，有基本数据类型以及引用类型两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;   <span class="comment">//基本类型</span></span><br><span class="line">String str = <span class="string">"hello"</span>;  <span class="comment">//引用类型</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/24ed132a8be844cfa527b15150f670fe.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>这里num是基本类型，str是引用类型，str是引用类型，对于引用类型来说，它本质上保存的是一个地址，指向了 “hello”这个字符串。</p><p>再还要来理解一下赋值操作(=)的具体含义：</p><p>基本类型的赋值，是直接对其保存的值进行修改的，而引用类型的赋值，本质上是改变了它指向的对象而已，原来指向的对象并没有改变：</p><p><img src="https://img-blog.csdnimg.cn/21d8d07cb8e14ffaa2280222193241bb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>继续看方法的调用：</p><p>在方法中传参数时，实际上是进行了赋值操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">作者：Intopass</span><br><span class="line">链接：https:<span class="comment">//www.zhihu.com/question/31203609/answer/50992895</span></span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line">第一个例子：基本类型</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(num); <span class="comment">// num 没有被改变</span></span><br><span class="line"></span><br><span class="line">第二个例子：没有提供改变自身方法的引用类型</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    text = <span class="string">"windows"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(str); <span class="comment">// str 也没有被改变</span></span><br><span class="line"></span><br><span class="line">第三个例子：提供了改变自身方法的引用类型</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder.append(<span class="string">"4"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 被改变了，变成了"iphone4"。</span></span><br><span class="line"></span><br><span class="line">第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder = <span class="keyword">new</span> StringBuilder(<span class="string">"ipad"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 没有被改变，还是 "iphone"。</span></span><br></pre></td></tr></table></figure><p>从JVM视角来看，所有的线程共享的区域是堆、元空间；每一个线程有独占的虚拟机栈、本地方法栈、程序计数器。那么对于传进参数的的这个方法，自然会加载到当前线程的虚拟机栈中，所以呢，对于每个方法的局部变量来说，是绝对无法被其他方法，甚至其他线程的同一方法所访问到的，更不用谈修改了。</p><p>当我们在方法内部去声明变量时(int i =0, Object obj = null)，仅仅是在栈(Stack)中加入了局部变量，并没有影响到堆(共享区域)。当我们外部new Object() 对象时，会在堆中开辟一段内存空间并初始化该对象实例，如果给这个对象赋值给方法内的obj局部变量时，仅仅只是把栈中的这个obj局部变量的地址指向改变了到了新new的Object而已。</p><p>总结：</p><ol><li>如果参数是<strong>基本类型</strong>，Java方法参数传递的是<strong>基本类型值的拷贝</strong>。</li><li>如果参数是<strong>引用类型</strong>，Java传递的是所引用的对象在堆中<strong>地址值的拷贝</strong></li></ol><p>所以如果想把某个对象传进方法，并且还想在方法内部修改它，则必须得调用这个对象自己的成员方法去修改，才能对堆上这个对象做实际的修改，如果只是赋值操作(=)，那么仅仅改变的是方法内局部变量的指向而已，并没有真正改变原来的对象值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;本文主要讲解Java方法传参、值传递、引用传递，其中涉及到JVM的相关知识，最近弥补了这一块，发现理解很多问题都变得豁然开朗了，知其所以然！</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
    <category term="值传递" scheme="https://ericzikun.github.io/tags/%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    
    <category term="引用传递" scheme="https://ericzikun.github.io/tags/%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM【垃圾回收机制】</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-11-06T08:20:51.000Z</published>
    <updated>2021-11-06T08:22:58.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、JVM垃圾回收机制"><a href="#三、JVM垃圾回收机制" class="headerlink" title="三、JVM垃圾回收机制"></a>三、JVM垃圾回收机制</h1><h2 id="3-1-堆为什么要分成年轻代和老年代？"><a href="#3-1-堆为什么要分成年轻代和老年代？" class="headerlink" title="3.1 堆为什么要分成年轻代和老年代？"></a>3.1 堆为什么要分成年轻代和老年代？</h2><p><img src="https://img-blog.csdnimg.cn/90318ff2219b4046a6872637405b5965.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>因为年轻代和老年代不同的特点，需要采用不同的垃圾回收算法；</p><p>年轻代的对象，它的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法；</p><p>老年代的对象，它的特点是需要长期存活，所以需要另外一种垃圾回收算法 ；</p><p>所以需要分成两个区域来放不同的对象；</p><p><strong>1、绝大多数对象都是朝生夕灭的；</strong></p><p>如果一个区域中大多数对象都是朝生夕灭，那么把它们集中放在一起，每次回收时只关注如何保留少量存活对象，而不是去标记那些大量将要被回收的对象，就能以较低的代价回收到大量的空间；</p><p><strong>2、熬过越多次垃圾收集的对象就越难以回收；</strong></p><p>如果是需要长期存活的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用；</p><p><strong>3、JVM划分出新生代、老年代之后，垃圾收集器可以每次只回收其中某一个或者某些部分的区域 ，同时也有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；</strong></p><p>Minor GC/Young GC ：新生代收集 </p><p>Major GC/Old GC：老年代收集</p><p>Full GC：整堆收集，收集整个Java堆和元空间/方法区的垃圾收集；</p><p>Mixed GC：混合收集，收集整个新生代以及部分老年代的垃圾收集，目前只有G1收集器会有这种行为； </p><p>4、针对不同的区域对象存亡特征采用不同的垃圾收集算法：</p><p>（1）复制算法</p><p>（2）标记-清除算法</p><p>（3）标记-整理算法</p><h2 id="3-2-JVM堆的年轻代为什么要有两个Survivor区？"><a href="#3-2-JVM堆的年轻代为什么要有两个Survivor区？" class="headerlink" title="3.2 JVM堆的年轻代为什么要有两个Survivor区？"></a>3.2 JVM堆的年轻代为什么要有两个Survivor区？</h2><p><strong>1、如果没有Survivor区会怎么样？</strong></p><p>此时每触发一次Minor GC，就会把Eden区的对象复制到老年代，这样当老年代满了之后会触发Major Gc/Full GC(通常伴随着MinorGC)，比较耗时，所以必须有Survivor区；</p><blockquote><p>解释：</p><p>会比较频繁的出发Full GC，开销太大</p></blockquote><p><strong>2、如果只有1个Survivor区会怎么样？</strong>【导致内存碎片】</p><p>刚刚创建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中存活的对象就会被移动到Survivor区，下一次Eden满了的时候，此时进行Minor GC，Eden和Survivor各有一些存活对象，因为只有一个Survivor，所以Eden区第二次GC发现的存活对象也是放入唯一的一个Survivor区域中，但此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化问题，并且由于不连续的空间会导致再分配大对象的时候，由于没有连续的空间来分配，会导致提前垃圾回收；</p><p>如果将Survivor中的所有存活对象进行整理消除碎片，然后将所有的存活对象放入其中，这样做会降低效率；</p><p>如果把两个区域中的所有存活对象都复制转移到一个完全独立的空间中，也就是第二块Survivor中，这样就可以留出一块完全空着的Eden和Survivor了，下次GC的时候再重复这个流程，所以我们便要有两个Survivor区；</p><p><img src="https://img-blog.csdnimg.cn/8e18f9530d264d51868277c612a3c25f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：</p><p>如果只有一个Survivor区域，触发Minor GC后会有内存碎片问题的产生(内存不连续)，大大降低了效率</p><p>所以得有第二个Survivor区域来装要存活的对象，从而使得第一个Survivor空闲、Eden也空闲，保证了内存空间的连续性——需要2个Survivor区域的原因解析</p></blockquote><h2 id="3-3-Eden区与Survivor区的空间大小比值为什么默认是8-1-1？"><a href="#3-3-Eden区与Survivor区的空间大小比值为什么默认是8-1-1？" class="headerlink" title="3.3 Eden区与Survivor区的空间大小比值为什么默认是8:1:1？"></a>3.3 Eden区与Survivor区的空间大小比值为什么默认是8:1:1？</h2><p>一个eden区 ，新生代对象出生的地方；</p><p>两个survivor区，一个用来保存上次新生代GC存活下来的对象，还有一个空着，在新生代GC时把eden+survivor中存活对象复制到这个空的survivor中；</p><p>统计和经验表明，<strong>90%的对象朝生夕死存活时间极短</strong> ，每次gc会有90%对象被回收，剩下的10%要预留一个survivor空间去保存； </p><blockquote><p>解释</p><p>8：1：1原因在于每次gc会有90%的对象被回收 ，这是个统计的结果</p></blockquote><h2 id="3-4-请介绍下JVM中的垃圾回收算法？"><a href="#3-4-请介绍下JVM中的垃圾回收算法？" class="headerlink" title="3.4 请介绍下JVM中的垃圾回收算法？"></a>3.4 请介绍下JVM中的垃圾回收算法？</h2><p><img src="https://img-blog.csdnimg.cn/457179f481b940119c2e236eaed29b5b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-4-1-标记-清除算法"><a href="#3-4-1-标记-清除算法" class="headerlink" title="3.4.1 标记-清除算法"></a>3.4.1 标记-清除算法</h3><p>标记-清除算法是最基础的收集算法，后续的很多垃圾回收算法是基于该算法而发展出来的，它分为‘ 标记 ’和‘ 清除 ’两个阶段；</p><p><strong>1、标记</strong></p><p>标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记出所有存活的对象，在标记完成后，统一回收所有未被标记的对象，标记过程就是对象是否属于垃圾的判定过程，基于可达性分析算法判断对象是否可以回收；</p><p><strong>2、清除</strong></p><p>标记后，对所有被标记的对象进行回收；</p><p>该算法如下图所示：</p><p>会发现回收后，内存空间就不连续了，有内存碎片<br><img src="https://img-blog.csdnimg.cn/28fa94791cfc4ff18e7a928008ef8243.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>优点：</strong></p><p>基于最基础的可达性分析算法，实现简单，后续的收集算法都是基于这种思想实现的；</p><p><strong>缺点：</strong></p><p>1、执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</p><p>2、内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集；</p><h3 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2 复制算法"></a>3.4.2 复制算法</h3><p>复制算法是标记-复制算法的简称，将可用内存按容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活的对象复制到另外一块内存上，然后再把已使用过的内存空间一次清理掉；</p><p><img src="https://img-blog.csdnimg.cn/4cc321ebb7484b3d8d35e09eba1e4b7c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>优点：</strong></p><p>实现简单，效率高，解决了标记-清除算法<strong>导致的内存碎片问题</strong>；</p><p><strong>缺点：</strong></p><p>1、代价太大，将可分配内存缩小了一半，<strong>空间浪费太多</strong>了；</p><p>2、对象存活率较高时就要进行较多的复制操作，效率将会降低；</p><h3 id="3-4-3-标记-整理算法"><a href="#3-4-3-标记-整理算法" class="headerlink" title="3.4.3 标记-整理算法"></a>3.4.3 标记-整理算法</h3><p>标记-整理算法是根据<strong>老年代</strong>的特点而产生的； </p><p><strong>1、标记</strong></p><p>标记过程与上面的标记-清理算法一致，也是基于可达性分析算法进行标记；</p><p><strong>2、整理</strong></p><p>和标记-清理不同的是，该算法不是针对可回收对象进行清理，而是根据存活对象进行整理，让存活对象都向一端移动，然后直接清理掉边界以外的内存；</p><p>而<strong>标记-清除算法</strong>不移动存活对象，导致有大量不连续空间，即内存碎片，而老年代这种每次回收都有大量存活对象的区域，移动存活对象并更新所有引用这些对象的引用，这是一种比较耗时的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，像这样的停顿我们也称为“Stop The World”即STW；</p><p>但是即便是移动存活对象是耗时的操作，但是如果不这么做，那么在充满内存碎片的空间中分配对象，又影响了对象的分配和访问的效率，所以JVM权衡两者之后，还是采用了<strong>移动存活对象的方式，也就是对内存进行了整理</strong>；</p><p>另外像cms垃圾收集器，平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间，所以像基于标记-清除算法的CMS收集器面临空间碎片过多时就会进行一次整理； </p><p><strong>优点：</strong></p><p>1、不会像复制算法那样划分两个区域，提高了空间利用率；</p><p>2、不会产生不连续的内存碎片；</p><p><strong>缺点：</strong></p><p>效率问题，除了像标记-清除算法的标记过程外，还多了一步整理过程，效率变低；</p><p>如下图所示：<br><img src="https://img-blog.csdnimg.cn/a551f71a551a48a9acd916a83ce47c39.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-4-4-分代收集算法"><a href="#3-4-4-分代收集算法" class="headerlink" title="3.4.4 分代收集算法"></a>3.4.4 分代收集算法</h3><p>现在一般虚拟机的垃圾收集都是采用“ <strong>分代收集</strong> ”算法；</p><p>根据对象存活周期的不同将内存划分为几块，一般把java堆分为<strong>新生代和老年代</strong>，JVM根据各个年代的特点采用不同的收集算法；</p><p>新生代中，每次进行垃圾回收都会发现大量对象死去，只有少量存活，因此采用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集；——只需要复制少于10%的对象，效率很高！</p><p>老年代中，因为对象存活率较高，采用<strong>标记-清理、标记-整理</strong>算法来进行回收；</p><h2 id="3-5-请介绍一下JVM垃圾收集器？"><a href="#3-5-请介绍一下JVM垃圾收集器？" class="headerlink" title="3.5 请介绍一下JVM垃圾收集器？"></a>3.5 请介绍一下JVM垃圾收集器？</h2><p><img src="https://img-blog.csdnimg.cn/083fe79ca2af48a9a0ff6d3df1576daf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如上图，一共有7种作用于不同分代的垃圾收集器，如果两个收集器之间存在连线，则说明它们可以搭配使用，垃圾收集器所处区域表示它是属于新生代收集器还是老年代收集器；</p><p>新生代收集器：Serial、ParNew、Parallel Scavenge [ˈpærəlel] [ˈskævɪndʒ] </p><p>老年代收集器：CMS、Serial Old、Parallel Old</p><p>整堆收集器： G1</p><p>垃圾收集器的最前沿成果：ZGC（Jdk11中引入了） 和 Shenandoah（Open JDK12，Oracle没引入，很前沿 ）</p><blockquote><p>解释：</p><p>目前在生产环境中，G1是比较先进的垃圾收集器了</p></blockquote><h3 id="3-5-1-Serial收集器-新生代、单线程"><a href="#3-5-1-Serial收集器-新生代、单线程" class="headerlink" title="3.5.1 Serial收集器[新生代、单线程]"></a>3.5.1 Serial收集器[新生代、单线程]</h3><p>新生代收集器，最早的收集器，单线程的，收集时需暂停用户线程的工作，所以有卡顿现象，效率不高，致使java语言的开发团队一直在改进垃圾收集器的算法和实现，但Serial收集器<strong>简单</strong>，不会有线程切换的开销，是Client模式下默认的垃圾收集器，-client， -server；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数： -XX:+UseSerialGC</span><br><span class="line"></span><br><span class="line">java -XX:+PrintFlagsFinal -version 打印jvm默认的参数值；</span><br></pre></td></tr></table></figure><p>垃圾收集时间线如下：</p><p>所有线程卡住（停下来），进行垃圾收集，收集完毕，然后再继续…<br><img src="https://img-blog.csdnimg.cn/e5e1db8a41cd4a6798c87112495fb211.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-5-2-ParNew收集器-新生代、多线程"><a href="#3-5-2-ParNew收集器-新生代、多线程" class="headerlink" title="3.5.2 ParNew收集器[新生代、多线程]"></a>3.5.2 ParNew收集器[新生代、多线程]</h3><p>它是新生代收集器，就是<strong>Serial收集器的多线程版本</strong>，大部分基本一样，单CPU下，ParNew还需要切换线程，可能还不如Serial；</p><p>Serial和ParNew收集器可以配合CMS收集器，前者收集新生代，后者CMS收集老年代，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;-XX:+UseConcMarkSweepGC&quot;：指定使用CMS后，会默认使用ParNew作为新生代垃圾收集器；</span><br><span class="line">&quot;-XX:+UseParNewGC&quot;：强制指定使用ParNew；</span><br><span class="line">&quot;-XX:ParallelGCThreads&#x3D;2&quot;：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b9fab178b75e4d64ae51fdf65ee5874b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-5-3-Parallel-Scavenge收集器【新生代、多线程】"><a href="#3-5-3-Parallel-Scavenge收集器【新生代、多线程】" class="headerlink" title="3.5.3 Parallel Scavenge收集器【新生代、多线程】"></a>3.5.3 Parallel Scavenge收集器【新生代、多线程】</h3><p> <img src="https://img-blog.csdnimg.cn/628f0c5d16144edb9bdffc4296e5da31.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>简称Parallel，它是新生代收集器，基于<strong>复制算法</strong>，并行的多线程收集器（与ParNew收集器类似），侧重于达到一个可控的吞吐量，虚拟机运行100分钟，垃圾收集花1分钟，则吞吐量为99%，有时候我们也把该垃圾收集器叫吞吐量垃圾收集器或者是吞吐量优先的垃圾收集器；而且这个垃圾收集器是jvm默认的新生代的垃圾收集器；</p><p>它提供一个<strong>参数设置吞吐量：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis 该参数设置大于0的毫秒数，每次GC的时间将尽量保持不超过设置的值，但是这个值也不是设置得越小就越好，GC暂停时间越短，那么GC的次数会变得更频繁；</span><br><span class="line"></span><br><span class="line">-XX:+UseAdaptiveSizePolicy 自适应新生代大小策略，默认这个参数是开启的，当这个参数被开启之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间获得最大的吞吐量，这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）；</span><br></pre></td></tr></table></figure><p>如果我们不知道怎么对jvm调优，我们可以使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用-XX:MaxGCPauseMillis参数（最大停顿时间）给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成，自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">参数：-XX:+UseParallelGC 指定使用Parallel Scavenge垃圾收集器</span><br><span class="line"></span><br><span class="line">java -XX:+PrintCommandLineFlags -version 打印jvm默认初始堆和最大堆大小以及垃圾收集器</span><br><span class="line"></span><br><span class="line">java -XX:+PrintFlagsFinal -version 打印jvm所有的默认的参数值；</span><br><span class="line"></span><br><span class="line">-XX:+ </span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"></span><br><span class="line">-Xloggc:d:&#x2F;dev&#x2F;gc.log</span><br><span class="line"></span><br><span class="line">Parallel Scavenge垃圾收集器中的Ergonomics负责自动的调节gc暂停时间和吞吐量之间的平衡，自动优化虚拟机的性能；</span><br></pre></td></tr></table></figure><h3 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h3><p>这里常用一下JVM参数打印JVM的log:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:d:&#x2F;dev&#x2F;gc.log</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/470dfa56725548239ab8499dea1414f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三、JVM垃圾回收机制&quot;&gt;&lt;a href=&quot;#三、JVM垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;三、JVM垃圾回收机制&quot;&gt;&lt;/a&gt;三、JVM垃圾回收机制&lt;/h1&gt;&lt;h2 id=&quot;3-1-堆为什么要分成年轻代和老年代？&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="JAVA虚拟机" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM【内存管理】</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-11-06T08:18:50.000Z</published>
    <updated>2021-11-06T08:27:55.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、深入剖析JVM内存管理"><a href="#二、深入剖析JVM内存管理" class="headerlink" title="二、深入剖析JVM内存管理"></a>二、深入剖析JVM内存管理</h1><h2 id="2-1-Java代码到底是如何运行起来的？"><a href="#2-1-Java代码到底是如何运行起来的？" class="headerlink" title="2.1 Java代码到底是如何运行起来的？"></a>2.1 Java代码到底是如何运行起来的？</h2><p>1、Mall.java –&gt;javac –&gt; Mall.class –&gt; java Mall (jvm进程，也就是一个jvm虚拟机)</p><p>2、Mall.java –&gt;javac–&gt;Mall.class –&gt;Mall.jar –&gt; java -jar Mall.jar</p><p>3、Mall.java –&gt; javac –&gt; Mall.class –&gt;Mall.war –&gt; Tomcat –&gt; startup.sh –&gt; org.apache.catalina.startup.Bootstrap (jvm进程，也就是一个jvm虚拟机)</p><p>其实运行起来一个Java程序，都是通过D:\dev\Java\jdk1.8.0_251\bin\java 启动一个JVM虚拟机，在虚拟机里面运行Mall.class字节码文件；</p><p><img src="https://img-blog.csdnimg.cn/ea7c556c03de419baba584e11e510a2c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>总结：</p><p>java源文件通过javac命令转成java字节码文件，再通过java命令运行起来，JVM是用于屏蔽掉底层操作系统之间的差异，这里不同操作系统所装载的jdk是不同的，jdk中包含jvm</p></blockquote><blockquote><p>这里面的其他语言，如Groovy、Scala、Kotlin也是编译后为字节码，再通过JVM虚拟机处理。</p></blockquote><h2 id="2-2画一下JVM整个运行原理图？☆"><a href="#2-2画一下JVM整个运行原理图？☆" class="headerlink" title="2.2画一下JVM整个运行原理图？☆"></a>2.2画一下JVM整个运行原理图？☆</h2><p><img src="https://img-blog.csdnimg.cn/10d2679aef014bd0a5e2b8b5f1feacf7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-3-请介绍一下JVM的内存结构划分？"><a href="#2-3-请介绍一下JVM的内存结构划分？" class="headerlink" title="2.3 请介绍一下JVM的内存结构划分？"></a>2.3 请介绍一下JVM的内存结构划分？</h2><p>加载进来的.class字节码文件、代码执行创建的对象、代码执行调用方法，方法中有变量等数据需要一个地方存放，所以JVM划分出了几个区域，用于存放这些信息；<strong>hotspot</strong></p><p><img src="https://img-blog.csdnimg.cn/466092a41d3c4dd2999cc6cb69532305.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在JDK1.8之前，元空间就是原来的方法区（永久代）；</p><p>比如new User(),那么User这个变量在虚拟机栈中存储为局部变量，但是其值是在堆中存储的</p><p>程序计数器：表明代码执行到哪一行</p><p>当类加载后，Class文件首先会存储在元空间中，然后运行时才会涉及其他几个空间部分</p><h2 id="2-4-JVM哪些区域是线程私有的，哪些区域是线程共享的？☆"><a href="#2-4-JVM哪些区域是线程私有的，哪些区域是线程共享的？☆" class="headerlink" title="2.4 JVM哪些区域是线程私有的，哪些区域是线程共享的？☆"></a>2.4 JVM哪些区域是线程私有的，哪些区域是线程共享的？☆</h2><p>1、堆、元空间（方法区）是线程共享的；</p><p>2、其他区域是线程私有的；</p><p><img src="https://img-blog.csdnimg.cn/228fe4ea721744d88c221a55e4e2abaf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>线程私有的区域如虚拟机栈、本地方法栈、程序计数器，这些就不存在线程安全的问题，每个线程之间这些区域是隔离的，不共享变量，就不会导致冲突，没有安全问题</p><p>举例：两个线程对应就有两个虚拟机栈，一一对应。无论有几个线程，堆和元空间都是公用的一个</p><h2 id="2-5-从JVM角度剖析如下程序代码如何执行？"><a href="#2-5-从JVM角度剖析如下程序代码如何执行？" class="headerlink" title="2.5 从JVM角度剖析如下程序代码如何执行？"></a>2.5 从JVM角度剖析如下程序代码如何执行？</h2><p><img src="https://img-blog.csdnimg.cn/1172c5acc584401a90768850e3949891.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bf9aba7b51174d7db44c430b12949155.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>Config类在new的时候，对象存在堆中，该类的信息是在元空间里的</p><h2 id="2-6-JVM运行时数据区-程序计数器-的特点及作用？"><a href="#2-6-JVM运行时数据区-程序计数器-的特点及作用？" class="headerlink" title="2.6 JVM运行时数据区 程序计数器 的特点及作用？"></a>2.6 JVM运行时数据区 程序计数器 的特点及作用？</h2><p>1、程序计数器是一块较小的内存空间，几乎可以忽略；</p><p>2、是当前线程所执行的字节码的行号指示器；</p><p>3、Java多线程执行时，每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响；</p><p>4、该区域是“线程私有”的内存，每个线程独立存储； </p><p>5、该区域不存在OutOfMemoryError；</p><p>6、无GC回收；</p><blockquote><p>总结：程序计数器是在线程产生的时候存在，在线程结束（销毁时候）消失，不需要垃圾回收（GC）</p></blockquote><h2 id="2-7-JVM运行时数据区-虚拟机栈的特点及作用？"><a href="#2-7-JVM运行时数据区-虚拟机栈的特点及作用？" class="headerlink" title="2.7 JVM运行时数据区 虚拟机栈的特点及作用？"></a>2.7 JVM运行时数据区 虚拟机栈的特点及作用？</h2><p>1、线程私有；</p><p>2、方法执行会创建栈帧，存储局部变量表等信息；</p><p>3、方法执行入虚拟机栈，方法执行完出虚拟机栈；（先进后出）</p><p>4、<strong>【深度过长】</strong> 栈深度大于虚拟机所允许StackOverflowError；</p><p>5、栈需扩展而无法申请空间OutOfMemoryError（比较少见）；hotspot虚拟机没有；</p><p>6、栈里面运行方法，存放方法的局部变量名，变量名所指向的值（常量值、对象值等）都存放到堆上的；</p><p>7、栈一般都不设置大小，栈所占的空间其实很小，可以通过-Xss1M进行设置，如果不设置默认为1M；</p><p>8、随线程而生，随线程而灭；</p><p>9、该区域不会有GC回收；</p><blockquote><p>解释：OutOfMemoryError一般少见，比如写个死循环不断的创建线程，当创建到一定程度，无法再继续给空间到新线程时，每个线程都会生成一个线程栈，每个线程栈会占用一定的内存区域，从而导致超出，会把会报此错误。</p></blockquote><p>如下，死循环中不断创建新的线程，而每个线程又不会结束，即不会销毁，从而导致大量内存占用。</p><p><img src="https://img-blog.csdnimg.cn/a8ca94b2a86543fb8012424b55060d55.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：递归调用时，有时会出现StackOverflowError，如下案例：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/174e439c54294adea990c98bfbde932a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输出结果：</p><p>解释栈大小设置：</p><p>一般1M足够大了，往往会将其设置小一点，在idea中添加JVM配置，默认是1M，也可以改为128k：</p><p><img src="https://img-blog.csdnimg.cn/14673c4fc962481b9436f76ea64bf89c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>改了栈大小之后，原来的栈深度35710就会减小，再报Stack Overflow：</p><p>相当于把栈变小了，压的栈就会相应变少。</p><p><img src="https://img-blog.csdnimg.cn/e43dc936d5ea4f598def559d401bf24f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>总结：实际项目中，一般也不会递归调用太多次，1M的话，调用个3w多次肯定是够用的！所以改小一点是有好处的，改小一点反而可以启动更多线程，比如原本10M的内存空间可以创建10个1M的线程，那么把栈大小改小后，线程所占用的内存空间就变小了，从而使得线程数量变多</p></blockquote><h2 id="2-8-JVM运行时数据区-本地方法栈的特点及作用？"><a href="#2-8-JVM运行时数据区-本地方法栈的特点及作用？" class="headerlink" title="2.8 JVM运行时数据区 本地方法栈的特点及作用？"></a>2.8 JVM运行时数据区 本地方法栈的特点及作用？</h2><p>1、与虚拟机栈基本类似；</p><p>2、区别在于本地方法栈为Native方法服务；</p><p>3、HotSpot虚拟机将虚拟机栈和本地方法栈合并；</p><p>4、有StackOverflowError和OutOfMemoryError（比较少见）；</p><p>5、随线程而生，随线程而灭；</p><p>6、GC不会回收该区域；</p><p><strong>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；</strong></p><p>解释：本地方法栈和虚拟机栈类似，只不过存储的是Native方法，也就是底层由C++写的方法；而HotSpot是把虚拟机栈和本地方法栈合并到一起了！</p><p><img src="https://img-blog.csdnimg.cn/0ec3e41627be41b5ab41cc45f81115da.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-9-JVM运行时数据区-Java堆的特点及作用？☆"><a href="#2-9-JVM运行时数据区-Java堆的特点及作用？☆" class="headerlink" title="2.9 JVM运行时数据区 Java堆的特点及作用？☆"></a>2.9 JVM运行时数据区 Java堆的特点及作用？☆</h2><p>1、线程共享的一块区域；</p><p>2、虚拟机启动时创建；</p><p>3、虚拟机所管理的内存中<strong>最大的一块区域</strong>；</p><p>4、存放所有实例<strong>对象或数组</strong>；</p><p>5、GC垃圾收集器的主要管理区域；</p><p>6、可分为新生代、老年代；</p><p>7、新生代更细化可分为Eden、From Survivor、To Survivor，Eden:Survivor = 8:1:1</p><p>8、可通过<strong>-Xmx、-Xms</strong>调节堆大小；</p><p>9、无法再扩展<strong>java.lang.OutOfMemoryError: Java heap space</strong></p><p>10、<strong>【TLAB】</strong> 如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率；</p><blockquote><p>解释：堆的年代划分</p></blockquote><p><img src="https://img-blog.csdnimg.cn/99db4806553041eeadea59a7c1e0f024.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：堆内存不足了，就会OOM，java.lang.OutOfMemoryError: Java heap space 堆溢出</p></blockquote><p><img src="https://img-blog.csdnimg.cn/11b3fa8d4f544029b771362463d76e2d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输出结果：</p><p><img src="https://img-blog.csdnimg.cn/62e1f4b03635406f8e4f1ab69e81b7dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果改一下堆大小：<br><img src="https://img-blog.csdnimg.cn/55c7019bb71d4f6fb6d34e3e6da04ba7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/56c5710d4e924a89be55af07bc438056.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：TLAB：</p><p>因为堆是共享区域，所以当多个线程往堆里面放内容时，会产生一个竞争关系、冲突问题，那么最朴素的想法就是用锁去解决这个线程安全问题，但是用锁呢，又会导致效率比较低，所以干脆给每个线程一个默认区域，区域不大，但是供每个线程各自去放内容，也就是给每个线程分配了一个较小的缓冲区，当把缓冲区放满后，再去公共区放数据！</p></blockquote><h2 id="2-10-JVM中对象如何在堆内存分配？"><a href="#2-10-JVM中对象如何在堆内存分配？" class="headerlink" title="2.10 JVM中对象如何在堆内存分配？"></a>2.10 JVM中对象如何在堆内存分配？</h2><p>1、<strong>指针碰撞（Bump The Pointer）</strong>：内存规整的情况下；</p><p>2、<strong>空闲列表（Free List）</strong>：内存不规整的情况下；</p><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定；</p><p>因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；</p><p>而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存；</p><p>3、<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB）：对象创建在虚拟机中频繁发生，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况；</p><p>那么解决方案有两种：</p><p>（1）同步锁定，JVM是采用CAS配上失败重试的方式保证更新操作的原子性； </p><p>（2）线程隔离，把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定，虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定； </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:TLABSize&#x3D;512k 设置大小；</span><br></pre></td></tr></table></figure><blockquote><p>解释：指针碰撞：</p><p>当内存排列规整的时候，指针不断向右遍历，依次排列对象</p></blockquote><p><img src="https://img-blog.csdnimg.cn/d7dbb10ca5f1438d9ae5fcf9b7f9ae56.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>空闲列表:<br>和指针碰撞不同，该方式的内存排列不规整，有一个空闲列表去记录哪些区域是空闲的，那么当存储时去找对应的空闲内存进行存储</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c4819cc4f5e644a1a47bf5b28f035f7d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：具体用哪种方式，这个是根据垃圾回收器的空，间压缩整理能力来决定的，如果GC每次回收完后，将空内存排列的规整，那么就用指针碰撞</p></blockquote><p>一些JVM可以配置的参数：<br><img src="https://img-blog.csdnimg.cn/c1323e7f99184687868394628184dd0b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-11-JVM堆内存中的对象布局？"><a href="#2-11-JVM堆内存中的对象布局？" class="headerlink" title="2.11 JVM堆内存中的对象布局？"></a>2.11 JVM堆内存中的对象布局？</h2><p>在 HotSpot 虚拟机中，一个对象的存储结构分为3块区域：</p><p>对象头(Header)、实例数据(Instance Data) 和 对齐填充(Padding)；</p><ul><li>对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit，官方称为 ‘Mark Word’；<br><img src="https://img-blog.csdnimg.cn/0d8739fc506f4542ad2ce640f76bdfc8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例，另外，如果是Java数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以；</li></ul><ul><li>实例数据(Instance Data)：程序代码中所定义的各种成员变量类型的字段内容(包含父类继承下来的和子类中定义的)；</li></ul><ul><li>对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍，HotSpot虚拟机，任何对象的大小都是8字节的整数倍；</li></ul><h2 id="2-12-JVM什么情况下会发生堆内存溢出？☆"><a href="#2-12-JVM什么情况下会发生堆内存溢出？☆" class="headerlink" title="2.12 JVM什么情况下会发生堆内存溢出？☆"></a>2.12 JVM什么情况下会发生堆内存溢出？☆</h2><p>Java堆中用于储存对象，只要不断地创建对象，并且保持<strong>GC Roots</strong>到对象之间有可达路径 </p><p>来避免垃圾回收机制清理这些对象，那么随着对象数量的增加，总容量达到最大堆的容量限制后就会产生内存溢出；</p><p>MAT工具分析xxx.hprof文件(相当于一个内存log)，排查溢出的原因；   </p><p>添加JVM参数 输出hprof文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath&#x3D;d:&#x2F;dev&#x2F;heapdump.hprof</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c59c2b4e6da54e2aac354e8fb56fab74.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b607a62acc6548faa40bcfa3a789a594.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>利用Eclipse的MAT工具来分析文件：</p><p>官网即可下载，open file，生成怀疑报告Leak suspects</p><p><img src="https://img-blog.csdnimg.cn/9560b3184aa747ae8e5a09b7e5e7e603.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-Xms3072M</span><br><span class="line"></span><br><span class="line">-Xmx3072M</span><br><span class="line"></span><br><span class="line">-Xmn1536M</span><br><span class="line"></span><br><span class="line">-Xss1M</span><br><span class="line"></span><br><span class="line">-XX:-UseCompressedClassPointers</span><br><span class="line"></span><br><span class="line">-XX:MetaspaceSize&#x3D;256M</span><br><span class="line"></span><br><span class="line">-XX:MaxMetaspaceSize&#x3D;256M</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio&#x3D;8</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;5</span><br><span class="line"></span><br><span class="line">-XX:PretenureSizeThreshold&#x3D;1M</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"></span><br><span class="line">-Xloggc:d:&#x2F;dev&#x2F;gc.log</span><br><span class="line"></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath&#x3D;d:&#x2F;dev&#x2F;heapdump.hprof</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/69ca5ae04bbb48f08da1850d89ffe88b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：Java堆中用于储存对象，只要不断地创建对象，并且保持<strong>GC Roots</strong>到对象之间有可达路径 </p><p>比如这里的orderList是一个GC root根，然后引用了new ArrayList<Order>()这个List对象地址，然后这个List对象又在循环中，不断的去引用到了order对象，由于对象一直在创建，所以就能保持GC Roots到对象之间有可达路径!</p><p>如果这个List对象引用断了，那么就会将剩余的进行垃圾回收，从而不会导致堆内存溢出，也就是说，该List对象不再被引用了，就可以销毁了(被GC回收)，从而就不会占用堆内存了</p></blockquote><p><img src="https://img-blog.csdnimg.cn/92b64722c1e3442d9ac310556327beed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>验证猜想：</p></blockquote><p>如果将order的引用注释掉：</p><p>这样一来，虽然orderList还是指向了堆内存中的List对象，但是List对象没有去引用新生成的order对象，导致order对象由于没有被引用，就会被GC回收，这样就不会导致堆内存溢出了.<br><img src="https://img-blog.csdnimg.cn/dcc1a44ff47a4892b9faf570372e05e4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以通过visualVM软件来可视化堆内存中对象的变化过程：</p><p>可以看出黄色的是每一个对象新生和销毁的过程，顶峰代表出生，下降到0代表销毁，所以就可以一直跑，不会堆溢出.<br><img src="https://img-blog.csdnimg.cn/248986e276794e50b98d0df6717a118c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对比溢出的情况：<br><img src="https://img-blog.csdnimg.cn/fdb13d45941348649229f5280c364b09.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>New区域不断的增加，到顶后，Old再累积</p><h2 id="2-13-JVM如何判断对象可以被回收？"><a href="#2-13-JVM如何判断对象可以被回收？" class="headerlink" title="2.13 JVM如何判断对象可以被回收？"></a>2.13 JVM如何判断对象可以被回收？</h2><p>在JVM堆里面存放着所有的Java对象，垃圾收集器在对堆进行回收前，首先要确定这些对象之中哪些还“存活”着，哪些已经“死去”；</p><p>Java通过 <strong>可达性分析（Reachability Analysis）</strong> 算法 来判定对象是否存活的；</p><p>该算法的基本思路：通过一系列称为“GC Roots”的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连（也称为不可达），则证明此对象是不可能再被使用的对象，就可以被垃圾回收器回收；<br><img src="https://img-blog.csdnimg.cn/e230558cf0b642d3a458ae89b8b7a670.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对象object 5、object 6、object 7虽然有关联，但它们到GC Roots是不可达的，所以它们将会被判定为可回收的对象；</p><p><strong>哪些对象可以作为GC Roots呢？</strong> </p><p>1、在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等所引用的对象；</p><p>2、方法区/元空间中的类静态属性引用的对象；</p><p>3、方法区/元空间中的常量引用的对象；</p><p>4、在本地方法栈中JNI（即通常所说的Native方法）引用的对象； </p><p>5、Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 </p><p>NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器；</p><p>6、所有被同步锁（synchronized关键字）持有的对象；</p><p>7、反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等； </p><p>8、其他可能临时性加入的对象；</p><blockquote><p>总结：一般我们最常见的就是虚拟机栈中的局部变量引用的对象、临时变量，作为GC Root。</p></blockquote><h2 id="2-14-谈谈Java中不同的引用类型？"><a href="#2-14-谈谈Java中不同的引用类型？" class="headerlink" title="2.14 谈谈Java中不同的引用类型？"></a>2.14 谈谈Java中不同的引用类型？</h2><p>Java里有不同的引用类型，分别是强引用、软引用、弱引用 和 虚引用；</p><p>强引用：Object object = new Object(）;</p><p>软引用：SoftReference 内存充足时不回收，内存不足时则回收；</p><p>弱引用：WeakReference 不管内存是否充足，只要GC一运行就会回收该引用对象；</p><p>虚引用：PhantomReference这个其实暂时忽略也行，因为很少用，它形同虚设，就像没有引用一样，其作用就是该引用对象被GC回收时候触发一个系统通知，或者触发进一步的处理；</p><blockquote><p>解释：</p><p>强引用【大多用】，因为有变量指向对象，只要引用没有释放，即便是内存不足、溢出了，也不能回收这个引用</p><p>软引用【缓存用】，要看内存足不足，弱引用，一般用于缓存领域(内存充足就缓存起来，内存不足就清空缓存，比如mybatis中就用到过)</p><p>弱引用【很少用】：比如类库ThreadLocal用到过</p><p>虚引用【很少用】</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">References</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//强引用</span></span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//软引用</span></span><br><span class="line">        SoftReference softReference = <span class="keyword">new</span> SoftReference(object);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//弱引用</span></span><br><span class="line">        WeakReference weakReference = <span class="keyword">new</span> WeakReference(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-15-JVM堆内存分代模型？"><a href="#2-15-JVM堆内存分代模型？" class="headerlink" title="2.15 JVM堆内存分代模型？"></a>2.15 JVM堆内存分代模型？</h2><p>JVM堆内存的分代模型：年轻代、老年代；</p><p>大部分对象朝生夕死，少数对象长期存活；</p><p><img src="https://img-blog.csdnimg.cn/6814a9e209ec4beebc5c7b4f595071d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>From Survivor区也叫S0区，To Survivor 也叫S1区</p><p>大小也可以通过参数去调整</p><h2 id="2-16-JVM堆中新生代的垃圾回收过程？☆☆☆☆"><a href="#2-16-JVM堆中新生代的垃圾回收过程？☆☆☆☆" class="headerlink" title="2.16 JVM堆中新生代的垃圾回收过程？☆☆☆☆"></a>2.16 JVM堆中新生代的垃圾回收过程？☆☆☆☆</h2><p><img src="https://img-blog.csdnimg.cn/bc2645bcf46742fe81a85eb407c70c24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>JVM里垃圾回收针对的是 <strong>新生代，老年代，还有元空间/方法区（永久代）</strong>，</p><p>不会针对方法的栈帧进行回收，方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存里清理掉，也就是<strong>虚拟机栈不存在垃圾回收</strong>；</p><p>代码里创建出来的对象，一般就是两种：</p><p>1、一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收；</p><p>2、一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停的去使用；</p><p>第一种短期存活的对象，是在Java堆内存的新生代里分配；</p><p>第二种长期存活的对象，通过在新生代S0区和S1区来回被垃圾回收15次后，进入Java堆内存的老年代中，这里的15次，我们也称为对象的年龄，即对象的年龄为15岁；</p><p>java -XX:+PrintFlagsFinal 打印jvm默认参数值；</p><blockquote><p>总结：<strong>垃圾回收针对的是堆和元空间</strong></p></blockquote><p><strong>过程详解：</strong></p><p>新创建的对象先进Eden空间，满了后，再就触发Minor GC就会去回收Eden区域里面的对象，这里面有些需要存活、有些需要回收，先把要存活的移到From Survivor区域，把要回收的对象清除掉。<br><img src="https://img-blog.csdnimg.cn/870f4346c35c43068d98a8f2ab22194b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第二轮：当Eden区域第二次再满的时候，这时又要出发Minor GC，这时候处理回收的就是Eden和S0两个区域的对象了</p><p>先将不能回收的对象移到S1区域，把要回收的对象清空掉，此时Eden区域空闲了。<br><img src="https://img-blog.csdnimg.cn/18ee3ee769424e268e2d65fa5ad9163a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后再处理S0区域中的对象，把要回收的清除，要存活的移到S1区域。<br><img src="https://img-blog.csdnimg.cn/1094d8f91e724c72b2bab0d1659a4d2b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3f6349966c7b44a6a71263e21297d05f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第三轮：当Eden区域再次满载状态时，再次触发Minor GC，这时处理的就是已满的Eden以及S1区域，先处理Eden：将回收的清除，需要存活的移至S0，针对S1区域做同理操作。<br><img src="https://img-blog.csdnimg.cn/7baf9572459f44568b4f5e697b067125.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4d5adeb8062b4b7eb384c5c2e5f883a2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后再回收S1区域的对象，其中不能回收的移到S0区域，要回收的清除掉。<br><img src="https://img-blog.csdnimg.cn/5cf03084c84740008af73897fa365c3f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">如此，循环往复，已存在于S0、S1的对象经过Minor GC后，要继续存活的就移到另一个区域(S0 or S1)，要回收的清除即可，要回收的对象就会在S0、S1两个区域中间来回移动，当移动的次数大于15次后，那之后就放进老年代，表示这个对象是需要长期存活的对象。</p><p>在中间每次清理S0、S1后，每次处理后都会有一个是空闲状态的，下一次把需要存活的移到空闲的区域</p><p><strong>年龄阈值</strong></p><p>关于年龄阈值，如果是并行GC，默认值是15，如果是CMS垃圾处理器的，就是6，详细可以看官方文档：</p><p>一般不指定垃圾处理器，那就是并行的，所以默认15次</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC</a></p><p><img src="https://img-blog.csdnimg.cn/656d20e0fc544965af0f785bf29deca9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以执行命令来看JVM的默认参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal 打印jvm默认参数值；</span><br></pre></td></tr></table></figure><h2 id="2-17-JVM对象动态年龄判断是怎么回事？☆☆☆"><a href="#2-17-JVM对象动态年龄判断是怎么回事？☆☆☆" class="headerlink" title="2.17 JVM对象动态年龄判断是怎么回事？☆☆☆"></a>2.17 JVM对象动态年龄判断是怎么回事？☆☆☆</h2><p>虚拟机<strong>并不是永远</strong>地要求对象的年龄必须达到了MaxTenuringThreshold=15才能晋升老年代；</p><p><strong>结论</strong><br>动态年龄判断：Survivor区的对象年龄从小到大进行累加，当累加到X年龄（某个年龄）时占用空间的总和大于50%（可以使用-XX:TargetSurvivorRatio=? 来设置保留多少空闲空间，默认值是50），那么比X年龄大的对象都会晋升到老年代；</p><p>1、Survivor区分布如下图：</p><p>这里是三轮后的的一个分布结果<br><img src="https://img-blog.csdnimg.cn/642f3d684c4f40f9b82a341303c2d2f1.png" alt="在这里插入图片描述"></p><blockquote><p>解释：也就是还有45%的对象还在存活，只要大于50%，才会触发动态年龄判断</p></blockquote><p>2、此时新生代GC后，有6%的对象进入Survivor区，Survivor区分布如下图：<br><img src="https://img-blog.csdnimg.cn/292de29e8215408a814dbad57aae85c0.png" alt="在这里插入图片描述"><br>这时从1岁加到4岁时,总和51% 大于50%，但此时没有大于四岁的对象，即没有对象晋升</p><blockquote><p>解释：动态年龄判断是在大于50%后触发，然后针对的是50%以后的大年龄对象，也就是4岁以后的，5岁 6岁…此处没有</p></blockquote><p>3、又经过一次新生代GC后，有40%的对象进入Survivor区，Survivor区分布如下图：<br><img src="https://img-blog.csdnimg.cn/05aab638f83447baa0ceaf497fa4b74c.png" alt="在这里插入图片描述"><br>Survivor区的对象年龄从小到大进行累加，当累加到 3 年龄时的总和大于50%，那么比3大的都会晋升到老年代，即<strong>4岁的20%、5岁的20%晋升到老年代</strong>；</p><blockquote><p>总结：并不是严格的到了15岁，就会到达老年代，也有动态年龄判断机制！</p></blockquote><h2 id="2-18-什么是老年代空间分配担保机制"><a href="#2-18-什么是老年代空间分配担保机制" class="headerlink" title="2.18 什么是老年代空间分配担保机制"></a>2.18 什么是老年代空间分配担保机制</h2><p><img src="https://img-blog.csdnimg.cn/016cc3b2804c45188544b456bfdb6ae7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>Eden：800m –&gt;300m</p><p>S0：100m</p><p>S1：100m</p><p>老年代：1000m，剩350m、200m</p><p>新生代Minor GC后剩余存活对象太多，无法放入Survivor区中，此时就必须将这些存活对象直接转移到老年代去，如果此时老年代空间也不够怎么办？</p><p>1、执行任何一次Minor GC之前，JVM会先检查一下老年代可用内存空间，是否大于新生代所有对象的总大小，因为在极端情况下，可能新生代Minor GC之后，新生代所有对象都需要存活，那就会造成新生代所有对象全部要进入老年代；</p><p>2、如果老年代的可用内存大于新生代所有对象总大小，此时就可以放心大胆的对新生代发起一次Minor GC，因为Minor GC之后即使所有对象都存活，Survivor区放不下了，也可以转移到老年代去； </p><p>3、如果执行Minor GC之前，检测发现老年代的可用空间已经小于新生代的全部对象总大小，那么就会进行下一个判断，判断老年代的可用空间大小，是否大于之前每一次Minor GC后进入<strong>老年代的对象的平均大小</strong>，如果判断发现老年代的内存大小，大于之前每一次Minor GC后进入老年代的对象的平均大小，那么就是说可以冒险<strong>尝试一下Minor GC</strong>，但是此时真的可能有风险，那就是Minor GC过后，剩余的存活对象的大小，大于Survivor空间的大小，也大于老年代可用空间的大小，老年代都放不下这些存活对象了，此时就会触发一次“Full GC”； </p><p>所以老年代空间分配担保机制的目的？也是为了<strong>避免频繁进行Full GC</strong>；</p><p>4、如果Full GC之后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致“OOM”内存溢出 ；</p><p>在JDK6的时候有一个参数-XX:+HandlePromotionFailure用于开启是否要进行空间担保;</p><blockquote><p>解释：</p><p>简单来说，就是往老年代放对象的时候，这个空间够不够，有一个担保机制。</p><p>当Eden新生代区域装满对象后，触发Minor GC，这里的核心在于做一个判断：</p><p>判断老年代的可用空间能不能大于新生代的对象大小总和，（这里相当于假设新生代对象全部都不可回收 并且S0 S1也不够，那么就得往老年代里面放，如果老年代可以全覆盖了，说明可以直接Minor GC，是没有OOM风险的）；如果老年代空间不足以覆盖全部新生代对象，那么就再作第二个判断：看历史往老年代放对象的平均大小和老年代的可用空间做比较(这里相当于是个评估，用历史平均去预算一下，但是也可能这一次比历史平均的都大，那么最终还得Full GC，Full GC指的是对老年代做回收，如果仍然不够则OOM)，这样的目的还是为了避免Full GC</p></blockquote><p><img src="https://img-blog.csdnimg.cn/034ec2ed49e84d10a32b1037e7e6172b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>核心关键：</strong><br>避免频繁的Full GC，所以每次判断都是先尽量走Minor GC，实在不行再Full GC。</p><h2 id="2-19-什么情况下对象会进入老年代？"><a href="#2-19-什么情况下对象会进入老年代？" class="headerlink" title="2.19 什么情况下对象会进入老年代？"></a>2.19 什么情况下对象会进入老年代？</h2><p>1、躲过15次GC之后进入老年代，可通过JVM参数“-XX:MaxTenuringThreshold”来设置年龄，默认为15岁；</p><p>2、动态对象年龄判断；</p><p>3、老年代空间担保机制；</p><p>4、<strong>大对象直接进入老年代</strong>；</p><p>大对象是指需要大量连续内存空间的Java对象，比如很长的字符串或者是<strong>很大的数组或者List集合</strong>，大对象在分配空间时，容易导致内存明明还有不少空间时就提前触发垃圾回收以获得足够的连续空间来存放它们，而当复制对象时，大对象又会引起<strong>高额的内存复制开销，</strong>为了避免新生代里出现那些大对象，然后屡次躲过GC而进行来回复制，此时JVM就直接把该大对象放入老年代，而不会经过新生代；</p><p>我们可以通过JVM参数“-XX:PretenureSizeThreshold”设置多大的对象直接进入老年代，该值为字节数，比如“1048576”字节就是1MB，该参数表示如果创建一个大于这个大小的对象，比如一个超大的数组或者List集合，此时就直接把该大对象放入老年代，而不会经过新生代； </p><p>-XX:PretenureSizeThreshold参数只对Serial和ParNew两款新生代收集器有效，其他新生代垃圾收集器不支持该参数，如果必须使用此参数进行调优，可考虑 ParNew+CMS的收集器组合；</p><blockquote><p>解释：对于大对象来说，一般大概率是不会被回收的，那么如果在S0和S1区域来回的移动，这样的内存开销是很大的，为了避免这一个巨大开销，就直接将过大的对象直接放入到老年代中存储</p></blockquote><h2 id="2-20-JVM运行时数据区-元空间的特点及作用？"><a href="#2-20-JVM运行时数据区-元空间的特点及作用？" class="headerlink" title="2.20 JVM运行时数据区 元空间的特点及作用？"></a>2.20 JVM运行时数据区 元空间的特点及作用？</h2><p>1、在JDK1.8开始才出现元空间的概念，之前叫方法区/永久代；</p><p>2、元空间与Java堆类似，是线程共享的内存区域；</p><p>3、<strong>存储被加载的类信息、常量、静态变量、常量池、即时编译后的代码等数据</strong>；</p><p>4、元空间采用的是本地内存，本地内存有多少剩余空间，它就能扩展到多大空间，也可以设置元空间大小；</p><p>-XX:MetaspaceSize=20M -XX:MaxMetaspaceSize=20m</p><p>5、元空间很少有GC垃圾收集，一般该区域回收条件苛刻，能回收的信息比较少，所以GC很少来回收；</p><p>6、元空间内存不足时，将抛出OutOfMemoryError；</p><blockquote><p>解释：</p><p>jdk1.8前都叫方法区，目前都叫元空间，这个区域和堆是并列的，也属于线程共享的内存区域，其存储的主要是类的信息，静态变量、常量等等一系列静态的量，比如下图，类加载后，类的信息就会存储在元空间中；</p><p>元空间的内存是不需要垃圾回收的，能回收的信息比较少</p><p>当元空间内存不足时候也会报OOM</p><p>元空间的大小占用的是本地内存，所以本地内存还剩多少，就可以给它扩展到多少，一般来说都是绝对足够的</p></blockquote><p> <img src="https://img-blog.csdnimg.cn/53665f46da0e434687e874ea7e83afe3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>测试元空间溢出</strong></p><p>这里采用了动态代理方式，来不断的创建类到元空间中</p><p>死循环，这里当超出了内存大小后就会溢出，如果不设置参数的话，就是根据机器剩余的内存来扩展，这时候需要等待很久才会溢出，如下图修改元空间大小参数，大小设置为20m，会马上内存溢出：</p><p><img src="https://img-blog.csdnimg.cn/e79ae98560b44d228a49e2e0a243f23a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/19ac30138e4d497089b0c551074be655.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元空间溢出测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaSpace</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);<span class="comment">//缓存</span></span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建动态代理类class</span></span><br><span class="line">            UserService userService = (UserService)enhancer.create();</span><br><span class="line">            userService.find();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"创建了"</span> + (++counter) + <span class="string">"个动态代理对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService类加载......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"find......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-21-JVM本机直接内存的特点及作用？"><a href="#2-21-JVM本机直接内存的特点及作用？" class="headerlink" title="2.21 JVM本机直接内存的特点及作用？"></a>2.21 JVM本机直接内存的特点及作用？</h2><p>1、直接内存（Direct Memory）不属于JVM运行时数据区，是本机直接物理内存；</p><p>2、像在JDK 1.4中新加入了NIO（New Input/Output）类，一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的 DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据；</p><p>3、可能导致OutOfMemoryError异常出现； netty</p><h2 id="2-22-JVM本机直接内存溢出问题？"><a href="#2-22-JVM本机直接内存溢出问题？" class="headerlink" title="2.22 JVM本机直接内存溢出问题？"></a>2.22 JVM本机直接内存溢出问题？</h2><p><strong>直接内存（Direct Memory）</strong> 的容量大小可通过-XX:MaxDirectMemorySize参数来指定，该参数表示设置新I / O（java.nio程序包）直接缓冲区分配的最大总大小（以字节为单位）;默认情况下，大小设置为0，这意味着JVM自动为NIO直接缓冲区分配选择大小；</p><p>由直接内存导致的内存溢出，<strong>无法生成Heap Dump文件</strong>，如果程序中直接或间接使用了NIO技术，那就可以重点考虑检查一下直接内存方面的原因；</p><p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dev/heapdump.hprof</p><blockquote><p>解释</p><ol><li><p>如果想输出原因文件，则要输入JVM参数XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dev/heapdump.hprof</p></li><li><p>测试NIO的直接内存溢出：</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectBufferOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        List&lt;ByteBuffer&gt; buffers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</span><br><span class="line">            buffers.add(byteBuffer);</span><br><span class="line">            System.out.println(count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报直接内存溢出(物理内存)</p><p> <img src="https://img-blog.csdnimg.cn/38e79a5bd5ca40aeba133f00e707e012.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>修改直接内存参数<br><img src="https://img-blog.csdnimg.cn/1eadedc438334164bf0b84758a0fd24e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4728feee8d2f4b81acd1bd3d3918cc0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>如果想输出原因文件，则要输入JVM参数XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dev/heapdump.hprof</p><ol><li>先配置</li><li>运行程序，报Direct buffer memory错误</li><li>发现在D:/dev/下没有生成heapdump.hprof文件</li></ol><p>这个步骤可以用来<strong>排查出是直接内存</strong>溢出，再进一步考虑是否直接或者间接的使用到了NIO技术</p><h2 id="2-23-几个与JVM内存相关的核心参数？"><a href="#2-23-几个与JVM内存相关的核心参数？" class="headerlink" title="2.23 几个与JVM内存相关的核心参数？"></a>2.23 几个与JVM内存相关的核心参数？</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-Xms Java堆内存的大小；</span><br><span class="line">-Xmx Java堆内存的最大大小；</span><br><span class="line"></span><br><span class="line">-Xmn Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小；</span><br><span class="line"></span><br><span class="line">-XX:MetaspaceSize 元空间大小；</span><br><span class="line"></span><br><span class="line">-XX:MaxMetaspaceSize 元空间最大大小；</span><br><span class="line"></span><br><span class="line">-Xss 每个线程的栈内存大小；</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio&#x3D;8 设置eden区 和survivor 区大小的比例，默认是8:1:1；</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;5 年龄阈值；</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC 指定CMS垃圾收集器；</span><br><span class="line"></span><br><span class="line">-XX:+UseG1GC 指定使用G1垃圾回收器</span><br></pre></td></tr></table></figure><p>–查看默认的堆大小及默认的垃圾收集器</p><p>java -XX:+PrintCommandLineFlags -version</p><h2 id="2-24-查看一个对象的大小"><a href="#2-24-查看一个对象的大小" class="headerlink" title="2.24 查看一个对象的大小"></a>2.24 查看一个对象的大小</h2><p>导入Lucene库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//1024kb = 1m</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      Order order = <span class="keyword">new</span> Order();</span><br><span class="line">      <span class="comment">//计算指定对象及其引用树上所有对象的综合大小，单位字节</span></span><br><span class="line">      <span class="keyword">long</span> size = RamUsageEstimator.sizeOf(order);</span><br><span class="line">      <span class="comment">//计算指定对象及其引用树上所有对象的综合大小，返回可读的结果，如：2KB</span></span><br><span class="line">      String humanSize = RamUsageEstimator.humanSizeOf(order);</span><br><span class="line">      </span><br><span class="line">      System.out.println(size);</span><br><span class="line">      System.out.println(humansize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e5b64d5d802d489ca62aeb2e03760e28.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、深入剖析JVM内存管理&quot;&gt;&lt;a href=&quot;#二、深入剖析JVM内存管理&quot; class=&quot;headerlink&quot; title=&quot;二、深入剖析JVM内存管理&quot;&gt;&lt;/a&gt;二、深入剖析JVM内存管理&lt;/h1&gt;&lt;h2 id=&quot;2-1-Java代码到底是如何运行起来的？</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="JAVA虚拟机" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM【JVM类加载机制】</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM/</id>
    <published>2021-11-06T07:55:12.000Z</published>
    <updated>2021-11-06T08:22:24.123Z</updated>
    
    <content type="html"><![CDATA[<p>概述：</p><ul><li>JVM类加载机制</li><li>深入剖析JVM内存管理</li><li>JVM垃圾回收机制</li><li>JVM故障诊断性能调优</li></ul><h1 id="一、JVM类加载机制"><a href="#一、JVM类加载机制" class="headerlink" title="一、JVM类加载机制"></a>一、JVM类加载机制</h1><h2 id="1-1-Java运行时一个类是什么时候被加载的？"><a href="#1-1-Java运行时一个类是什么时候被加载的？" class="headerlink" title="1.1 Java运行时一个类是什么时候被加载的？"></a>1.1 Java运行时一个类是什么时候被加载的？</h2><p>一个类在什么时候开始被加载，《Java虚拟机规范》中并没有进行强制约束，交给了虚拟机自己去自由实现，HotSpot虚拟机是按需加载，在需要用到该类的时候加载这个类；</p><p>1、Sun公司最早的 Classic虚拟机；</p><p>2、Sun/Oracle公司的HotSpot虚拟机；</p><p>3、BEA公司的JRockit虚拟机；</p><p>4、IBM公司的IBM J9虚拟机；</p><p>官方：<a href="https://docs.oracle.com/javase/8/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/</a> </p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>-XX:+TraceClassLoading</p><p>测试类的详细载入：</p><p> <img src="https://img-blog.csdnimg.cn/5bd24ce438114ca6931b59bb58529a42.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/2e6b46a24d774bd1bdc32c2d084e0dd3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d43ad7b91ce94a3ebfb0e9137c23ee83.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-2-JVM一个类的加载过程？"><a href="#1-2-JVM一个类的加载过程？" class="headerlink" title="1.2 JVM一个类的加载过程？"></a>1.2 JVM一个类的加载过程？</h2><p>一个类从加载到jvm内存，到从jvm内存卸载，它的整个生命周期会经历7个阶段：</p><p>1、加载（Loading）</p><p>2、验证（Verification）</p><p>3、准备（Preparation）</p><p>4、解析（Resolution）</p><p>5、初始化（Initialization）</p><p>6、使用（Using）</p><p>7、卸载（Unloading）</p><p>其中验证、准备、解析三个阶段统称为连接（Linking）；<br><img src="https://img-blog.csdnimg.cn/13fa5bffb22047db8449f3846761b42e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>加载：</strong> classpath、jar包、网络、某个磁盘位置下的类的class二进制字节流读进来，在内存中生成一个代表这个类的java.lang.Class对象放入元空间，此阶段我们程序员可以干预，我们可以自定义类加载器来实现类的加载；</p><p><strong>验证：</strong> 验证Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证虚拟机的安全；</p><p><strong>准备：</strong> 类变量赋默认初始值，int为0，long为0L，boolean为false，引用类型为null；常量赋正式值；</p><p><strong>解析：</strong> 把符号引用翻译为直接引用；</p><p><strong>初始化：</strong> 当我们new一个类的对象，访问一个类的静态属性，修改一个类的静态属性，调用一个类的静态方法，用反射API对一个类进行调用，<strong>初始化当前类，其父类也会被初始化</strong>…… 那么这些都会触发类的初始化；</p><p><strong>使用：</strong> 使用这个类；</p><p><strong>卸载：</strong></p><p>1.该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例；</p><p>2.加载该类的ClassLoader已经被GC； （ClassLoader：类加载器，用于加载class）</p><p>3.该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法；</p><p><strong>准备阶段：</strong></p><p>​    对于final常量来说，准备阶段直接赋值a为123，对于类变量，是在类初始化（new）的时候才会进行赋值，所以先赋0，而对于实例变量abc来说，也是先赋0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123; <span class="comment">// java.lang.Class</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">222</span>;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"sdfsdf"</span>; <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> abc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -XX:+TraceClassLoading 监控类的加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.working();</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解析阶段：</p><p>把一个类的class文件读进来之后，变成java.lang.class对象，在元空间里面</p></blockquote><h2 id="1-3一个类被初始化的过程？☆☆☆"><a href="#1-3一个类被初始化的过程？☆☆☆" class="headerlink" title="1.3一个类被初始化的过程？☆☆☆"></a>1.3一个类被初始化的过程？☆☆☆</h2><p><img src="https://img-blog.csdnimg.cn/b81a91c6b2e745eba65d3991c8d1eef5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>类的初始化阶段，Java虚拟机才真正开始执行类中编写<strong>Java程序代码</strong>；</p><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，</p><p>而在初始化阶段，才真正初始化类变量和其他资源；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态常量  ==准备</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String staticConstantField = <span class="string">"静态常量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量 ==准备阶段赋值为 null，初始化阶段赋值为 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量 == 创建对象的时候赋值</span></span><br><span class="line">    <span class="keyword">public</span> String field = <span class="string">"变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块 ==初始化阶段执行</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(staticConstantField);</span><br><span class="line">        System.out.println(staticField);</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块 == 创建对象的时候执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">"初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器 == 创建对象的时候执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java Test02</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test02();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、rt.jar charset.jar</span></span><br><span class="line">        <span class="comment">// 2、InitialOrderTest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证初始化：</p><ol><li>当main方法中new对象时，执行空：<br><img src="https://img-blog.csdnimg.cn/b904b3f0c0ac458da6908208327572f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>此时会执行静态代码块中的语句，同时静态常量、静态变量都得到了初始化，所以main方法执行后，会初始化Test02类中的静态常量、静态变量、静态代码块</li></ol><ol start="2"><li>main中new Test02对象时：<br><img src="https://img-blog.csdnimg.cn/cf00cf501e374fa9bf1a8c9af9501425.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>同样也会先初始化Test02中的静态常量、静态变量、静态代码块，和第一个验证一致，其次再去初始化类的成员变量、代码块、构造方法</li></ol><h2 id="1-4-继承时父子类的初始化顺序是怎样的？"><a href="#1-4-继承时父子类的初始化顺序是怎样的？" class="headerlink" title="1.4 继承时父子类的初始化顺序是怎样的？"></a>1.4 继承时父子类的初始化顺序是怎样的？</h2><p>父类–静态变量</p><p>父类–静态初始化块</p><p>子类–静态变量</p><p>子类–静态初始化块</p><p>父类–变量</p><p>父类–初始化块</p><p>父类–构造器</p><p>子类–变量</p><p>子类–初始化块</p><p>子类–构造器</p><p>父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String p_StaticField = <span class="string">"父类--静态变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">public</span> String p_Field = <span class="string">"父类--变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(p_StaticField);</span><br><span class="line">        System.out.println(<span class="string">"父类--静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(p_Field);</span><br><span class="line">        System.out.println(<span class="string">"父类--初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"父类--构造器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">", j="</span> + j);</span><br><span class="line">        i = <span class="number">1</span>; j = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s_StaticField = <span class="string">"子类--静态变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">public</span> String s_Field = <span class="string">"子类--变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(s_StaticField);</span><br><span class="line">        System.out.println(<span class="string">"子类--静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s_Field);</span><br><span class="line">        System.out.println(<span class="string">"子类--初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"子类--构造器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序入口 java ChildClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChildClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试验证：</p><ol><li><p>main方法中不执行任何语句：<br><img src="https://img-blog.csdnimg.cn/85865c3977de490c9c7d1144bb0fcc10.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当在子类的main中执行时，会先初始化父类的静态变量+静态代码块，然后再初始化子类的静态变量+静态代码块</p></li><li><p>main方法中new子类对象时：<br><img src="https://img-blog.csdnimg.cn/da506d9c8bd349e9bcc61a301ffde44d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>前面的依旧，先初始化父类子类的静态变量、静态代码块，然后由于new了子类，所以还会先执行父类的成员变量、代码块、构造器，再执行子类的成员变量、代码块、构造器。</p></li><li><p>如果在子类main中new父类对象<br><img src="https://img-blog.csdnimg.cn/003ee5bee17c42ca9300c6b2addc1d85.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>结果可想而知，由于是子类的main，会先初始化父类子类静态变量、静态代码块，然后由于new了父类，所以还会初始化父类的成员变量、代码块、构造器</p></li></ol><h2 id="1-5-究竟什么是类加载器？"><a href="#1-5-究竟什么是类加载器？" class="headerlink" title="1.5 究竟什么是类加载器？"></a>1.5 究竟什么是类加载器？</h2><p><img src="https://img-blog.csdnimg.cn/ebe3963d9cb549828b27307c07336cdf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在类“加载”阶段，通过一个类的全限定名来获取描述该类的二进制字节流的这个动作的“代码”被称为“类加载器”（Class Loader），这个 <strong>动作是可以自定义实现</strong> 的；</p><p>类加载器可以由C++、Java语言实现</p><p><strong>简单来说，就是把.class文件以二进制形式读进来</strong></p><h2 id="1-6-JVM有哪些类加载器？"><a href="#1-6-JVM有哪些类加载器？" class="headerlink" title="1.6 JVM有哪些类加载器？"></a>1.6 JVM有哪些类加载器？</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：</p><p>1、启动类加载器（Bootstrap ClassLoader），使用C++语言实现，是虚拟机自身的一部分；</p><p>2、其他所有的类加载器，由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader；</p><p>站在Java开发者的角度来看，自JDK 1.2开始，Java一直保持着三层类加载器架构；<br><img src="https://img-blog.csdnimg.cn/30454650ccfb4aeb9bad631755a2d745.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-7-JVM中不同的类加载器加载哪些文件？"><a href="#1-7-JVM中不同的类加载器加载哪些文件？" class="headerlink" title="1.7 JVM中不同的类加载器加载哪些文件？"></a>1.7 JVM中不同的类加载器加载哪些文件？</h2><p>1、启动类加载器（Bootstrap ClassLoader）：（根的类加载器）C++语言实现的，在java中通过getClassLoader方法是获取不到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;JAVA_HOME&gt;\jre\lib\rt.jar，resources.jar、charsets.jar</span><br><span class="line"></span><br><span class="line">被-Xbootclasspath参数所指定的路径中存放的类库；</span><br></pre></td></tr></table></figure><p>2、扩展类加载器（Extension ClassLoader）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sun.misc.Launcher$ExtClassLoader，</span><br><span class="line"></span><br><span class="line">&lt;JAVA_HOME&gt;\jre\lib\ext，</span><br><span class="line"></span><br><span class="line">被java.ext.dirs系统变量所指定的路径中所有的类库；</span><br></pre></td></tr></table></figure><p>3、应用程序类加载器（Application ClassLoader）：系统的类加载器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line"></span><br><span class="line">加载用户类路径（ClassPath）上所有的类库；</span><br></pre></td></tr></table></figure><blockquote><p>测试验证：</p></blockquote><p>比如在</p><ul><li><p><JAVA_HOME>\jre\lib\rt.jar下找到一个类BufferReader类，查看其classLoader，为空，由于是c++语言编写的，所以Java中获取不到，是正常的；</p><p>输出为null则表明<strong>根的类加载器</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/38a1011b414d4e08a616e481e7cb6f79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>AppClassLoader，包括自己写的代码以及项目中涉及到的第三方jar包（如Springboot）<br><img src="https://img-blog.csdnimg.cn/84656823250941ce9128e7b206304cbc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>继承结构：<br><img src="https://img-blog.csdnimg.cn/b935dacc92ad46c49fc9a53da03119b6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="1-8-JVM三层类加载器之间的关系是继承吗？"><a href="#1-8-JVM三层类加载器之间的关系是继承吗？" class="headerlink" title="1.8 JVM三层类加载器之间的关系是继承吗？"></a>1.8 JVM三层类加载器之间的关系是继承吗？</h2><img src="https://img-blog.csdnimg.cn/89bda791bb7e4bd08962b8042fc80e3b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>不是继承关系。</li></ul><p>解释：<br><img src="https://img-blog.csdnimg.cn/2bccbcf820094c25a44338b7f9da2292.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b1c78fa1a84f44038119bdb37527e16b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7f9a344f09134651b3e479ca0b70a9ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2f33361c23e04775b0519a8fb63d9156.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>换个角度思考这个问题，前面提到过BootstrapClassLoader是C++语言实现的，ExtClassLoader是Java实现的，怎么可能继承呢？</p><p>如果我们自定义一个类加载器，那么则是继承共同的父类ClassLoader(抽象类)</p><h2 id="1-9-JVM类加载的双亲委派模型-☆☆☆"><a href="#1-9-JVM类加载的双亲委派模型-☆☆☆" class="headerlink" title="1.9 JVM类加载的双亲委派模型 ☆☆☆"></a>1.9 JVM类加载的双亲委派模型 ☆☆☆</h2><p><img src="https://img-blog.csdnimg.cn/9ff291a01cf941ef812669baa1d7a41f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>官方描述：</strong></p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当上一层类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到这个类）时，下一层类加载器才会尝试自己去加载；</p><blockquote><p><strong>过程分析：</strong></p><p>如：我要加载String这个类，来自rt.jar,首先让App ClassLoader去加载，但它自己不加载，委派给上一层加载，ExtClassLoader也不去加载，再继续委派给Bootstrap ClassLoader，再往上就没有了，那么此时BootstrapClassLoader就要去尝试加载，它主要是加载jre下内部库的jar包，而String这个类正好在rt.jar中，所以就return了，从而把String这个类加载到JVM内存中了。</p></blockquote><blockquote><p>当BootstrapClassLoader加载内库后，找不到所要加载的类，那么就让第二层ExtClassLoader去尝试加载，找得到就return，找不到就继续让AppClassLoader去加载后找。</p><p>当这个类几个类加载器都找不到时，报ClassNotFoundException</p><p>解释一下为啥叫双亲：因为AppClassLoader上面有两层，所以叫双亲</p><p>总结：先自底向上委派，再自顶向下去尝试加载</p></blockquote><h2 id="1-10-JDK为什么要设计双亲委派模型，有什么好处？"><a href="#1-10-JDK为什么要设计双亲委派模型，有什么好处？" class="headerlink" title="1.10 JDK为什么要设计双亲委派模型，有什么好处？"></a>1.10 JDK为什么要设计双亲委派模型，有什么好处？</h2><p>1、确保安全，避免Java核心类库被修改；</p><p>2、避免重复加载；</p><p>3、保证类的唯一性；</p><p>如果你写一个jaa.lang.String的类去运行，发现会抛出如下异常；</p><p>解释：</p><p> 比如即使自己写了个String类，也不会被加载，因为最先会加载rt.jar下的String，能够避免核心内库被修改，要保证安全。<br> <img src="https://img-blog.csdnimg.cn/fb14a61393854f4fa0828b5f99db626f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/01b32ddb909044a88ca3e70d7ad9999a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>自定义的包理论上是最终被APPClassLoader去加载的，但是这里为啥会报错，是因为包和核心内库重名了，所以报安全异常</p><h2 id="1-11-可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？"><a href="#1-11-可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？" class="headerlink" title="1.11 可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？"></a>1.11 可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？</h2><p>可以；</p><p>想要打破这种模型，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可；</p><h2 id="1-12-如何自定义自己的类加载器？"><a href="#1-12-如何自定义自己的类加载器？" class="headerlink" title="1.12 如何自定义自己的类加载器？"></a>1.12 如何自定义自己的类加载器？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、继承ClassLoader</span><br><span class="line">2、覆盖findClass(String name)方法 或者 loadClass() 方法；</span><br></pre></td></tr></table></figure><p>findClass(String name)方法 不会打破双亲委派；</p><p>loadClass() 方法 可以打破双亲委派（如何去加载可以自己去实现）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义ClassLoader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span></span><br><span class="line">        <span class="comment">//name = 包名 + 类名</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// User.class</span></span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line"></span><br><span class="line">        Class clazz = myClassLoader.findClass(<span class="string">"com.bjpowernode.loader.User"</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line"></span><br><span class="line">        System.out.println(User<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        Class claz2 = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Object o2 = claz2.newInstance();</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来com.bjpowernode.loader.User应该去AppClassLoader中加载的，但由于自定义了myClassLoader，并调用了findClass方法，所以会使用自定义的方法去加载。</p><p><img src="https://img-blog.csdnimg.cn/0b3754f67b0c4c15a6f33ed513605403.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-13-ClassLoader中的loadClass-、findClass-、defineClass-区别？"><a href="#1-13-ClassLoader中的loadClass-、findClass-、defineClass-区别？" class="headerlink" title="1.13 ClassLoader中的loadClass()、findClass()、defineClass()区别？"></a>1.13 ClassLoader中的loadClass()、findClass()、defineClass()区别？</h2><p>loadClass() 就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中；</p><p>findClass() 根据名称或位置加载.class字节码；</p><p>definclass() 把字节码转化为java.lang.Class；</p><p>1、当我们想要自定义一个类加载器的时候，并且想破坏双亲委派模型时，我们会重写loadClass()方法；</p><p>2、如果我们想定义一个类加载器，但是不想破坏双亲委派模型的时候呢？可以可以重写findClass方法()，findClass()方法是JDK1.2之后的ClassLoader新添加的一个方法，这个方法只抛出了一个异常，没有默认实现；</p><p>JDK1.2之后已不再提倡用户直接覆盖loadClass()方法，而是建议把自己的类加载逻辑实现到findClass()方法中；</p><p>因为覆盖即打破双亲委派，所以建议改findClass</p><p>所以，如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass()中实现你自己的加载逻辑即可；</p><blockquote><p>经典案例：Tomcat就打破了双亲委派机制</p></blockquote><h2 id="1-14-加载一个类采用Class-forName-和ClassLoader有什么区别"><a href="#1-14-加载一个类采用Class-forName-和ClassLoader有什么区别" class="headerlink" title="1.14 加载一个类采用Class.forName()和ClassLoader有什么区别"></a>1.14 加载一个类采用Class.forName()和ClassLoader有什么区别</h2><p><img src="https://img-blog.csdnimg.cn/f13857d9007a481b8a80a13c63409d6a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> Class.forName(<span class="string">"com.jvm.demo.loader.ChildClass"</span>)</span><br><span class="line">       </span><br><span class="line">     Class clazz = Test05.class.getClassLoader().loadClass("com.jvm.demo.loader.ChildClass")</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7f6d9e55388c40669dbb6cae7585ee94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/91d105129ccf47e893c53bfe3220b152.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>分析区别：<br>由此可见，ClassLoader这种方式，只经过了加载-&gt;链接，但是没有初始化，但是forName方式会初始化<br>如果继续对类实例化，则会初始化，并会创建对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">     Class clazz = Test05.class.getClassLoader().loadClass("com.jvm.demo.loader.ChildClass");</span><br><span class="line">    clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/bcca71557c23441dbf196a7344a96128.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>看看两个方法底层实现：</p><p>forName底层会初始化类：</p><p>调用了一个本地C++方法<br><img src="https://img-blog.csdnimg.cn/21090b3adde84d84ab47d39e7ceffafb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>ClassLoader底层：</p><p>双亲委派类加载，没有对类进行初始化<br><img src="https://img-blog.csdnimg.cn/6446910b0afa4f88b61c9ee328a53227.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-15-了解Tomcat-的类加载机制"><a href="#1-15-了解Tomcat-的类加载机制" class="headerlink" title="1.15 了解Tomcat 的类加载机制"></a>1.15 了解Tomcat 的类加载机制</h2><p><img src="https://img-blog.csdnimg.cn/ec833dac95374d2bacc77b42dec35f0e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以看到，在原来的Java的类加载机制基础上，Tomcat新增了3个基础类加载器和每个Web应用的类加载器+JSP类加载器；</p><p>3个基础类加载器在 conf/catalina.properties 中进行配置：</p><p>common.loader=”${catalina.base}/lib”,”${catalina.base}/lib/<em>.jar”,”${catalina.home}/lib”,”${catalina.home}/lib/</em>.jar”<br> server.loader=<br> shared.loader=</p><p>Tomcat自定义了WebAppClassLoader类加载器，打破了双亲委派的机制，即如果收到类加载的请求，首先会尝试自己去加载，如果找不到再交给父加载器去加载，目的就是为了优先加载Web应用自己定义的类，我们知道ClassLoader默认的loadClass方法是以双亲委派的模型进行加载类的，那么Tomcat打破了这个规则，重写了loadClass方法，我们可以看到WebAppClassLoader类中重写了loadClass方法；</p><h2 id="1-16-有没有听说过热加载和热部署，如何自己实现一个热加载？"><a href="#1-16-有没有听说过热加载和热部署，如何自己实现一个热加载？" class="headerlink" title="1.16 有没有听说过热加载和热部署，如何自己实现一个热加载？"></a>1.16 有没有听说过热加载和热部署，如何自己实现一个热加载？</h2><p><strong>热加载</strong> 是指可以在不重启服务的情况下让更改的代码生效，热加载可以显著的提升开发以及调试的效率，它是基于Java的类加载器实现的，但是由于热加载的不安全性，一般不会用于正式的生产环境；</p><p><strong>热部署</strong> 是指可以在不重启服务的情况下重新部署整个项目，比如Tomcat热部署就是在程序运行时，如果我们修改了War包中的内容，那么Tomcat就会删除之前的War包解压的文件夹，重新解压新的War包生成新的文件夹；</p><p>1、热加载是在运行时重新加载class，后台会启动一个线程不断检测你的class是否发生改变；</p><p>2、热部署是在运行时重新部署整个项目，耗时相对较高；</p><p>如何实现热加载呢？</p><p>在程序代码更改且重新编译后，让运行的进程可以实时获取到新编译后的class文件，然后重新进行加载；</p><p><strong>重点步骤</strong></p><p>1、实现自己的类加载器；</p><p>2、从自己的类加载器中加载要热加载的类；</p><p>3、不断轮训要热加载的类class文件是否有更新，如果有更新，重新加载；</p><p>类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义一个类加载器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * bootstrap ClassLoader jdk/jre/目录下的jar包加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ext ClassLoader  jdk/ext/目录下的jar包加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * App ClassLoader --我们应用的ClassLoader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File classPathFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Class&gt; clazzCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="comment">//缓存 保存加载的类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String classPath = MyClassLoader.class.getResource("").getPath();</span><br><span class="line">        <span class="keyword">this</span>.classPathFile = <span class="keyword">new</span> File(classPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.findClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name, <span class="keyword">boolean</span> force) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//force是否强制加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//之前有没有加载过这个class</span></span><br><span class="line">        Class cls = clazzCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (force) &#123;</span><br><span class="line">            <span class="comment">//如果强制加载 则缓存值值为空，后面重新加载一遍</span></span><br><span class="line">            cls = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String className = MyClassLoader.class.getPackage().getName() + "." + name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个cls不为空则直接return了</span></span><br><span class="line">        <span class="keyword">if</span> (cls == <span class="keyword">null</span> &amp;&amp; classPathFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File classFile = <span class="keyword">new</span> File(classPathFile + <span class="string">"\\"</span> + name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>) + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">if</span> (classFile.exists()) &#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">                ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                    bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cls = defineClass(className, bos.toByteArray(), <span class="number">0</span>, bos.size());</span><br><span class="line">                    clazzCache.put(name, cls);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            fis.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(bos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            bos.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazzCache.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个定时任务去轮询：</p><p>观察狗 线程：</p><blockquote><p>思路：遍历文件，去拿到每个文件的时间，判断是否被修改，如果修改则重新触发加载类(自定义类加载器)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察狗</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchDog</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, FileDefine&gt; fileDefineMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchDog</span><span class="params">(Map&lt;String, FileDefine&gt; fileDefineMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileDefineMap = fileDefineMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.getClass().getResource(<span class="string">""</span>).getPath());</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File watchFile : files) &#123;</span><br><span class="line">            <span class="keyword">long</span> newTime = watchFile.lastModified();</span><br><span class="line">            FileDefine fileDefine = fileDefineMap.get(watchFile.getPath());</span><br><span class="line">            <span class="keyword">long</span> oldTime = fileDefine.getLastDefine();</span><br><span class="line">            <span class="comment">//如果文件被修改了,那么重新生成累加载器加载新文件</span></span><br><span class="line">            <span class="keyword">if</span> (newTime != oldTime) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件被修改......"</span>);</span><br><span class="line">                fileDefine.setLastDefine(newTime);</span><br><span class="line">                <span class="comment">//重新触发类加载</span></span><br><span class="line">                loadMyClass(watchFile.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadMyClass</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">            myClassLoader.findClass(className.replace(<span class="string">".class"</span>, <span class="string">""</span>), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, FileDefine&gt; fileDefineMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File file = new File(Test.class.getResource("").getPath());</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File watchFile : files) &#123;</span><br><span class="line">            FileDefine fileDefine = <span class="keyword">new</span> FileDefine();</span><br><span class="line">            fileDefine.setLastDefine(watchFile.lastModified());</span><br><span class="line">            fileDefineMap.put(watchFile.getPath(), fileDefine);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定时任务</span></span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> WatchDog(fileDefineMap), <span class="number">3</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        MyClassLoader w = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Class clazz = w.findClass(<span class="string">"MyLog"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ILog myLog = (ILog) clazz.newInstance();</span><br><span class="line">                myLog.log();</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试其中一个修改类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLog</span> <span class="keyword">implements</span> <span class="title">ILog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"log, version 1.0"</span>); 、</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处修改 System.out.println(“log, version 1.0”);为 System.out.println(“log, version 2.0”); 文件发生修改，但是要编译一下，点击build-&gt;Recompile ‘’MyLog.java’，那么轮询时就会发现文件的修改</p><p><img src="https://img-blog.csdnimg.cn/9fb916ae1aff4c37b5dba37591bd7dea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM类加载机制&lt;/li&gt;
&lt;li&gt;深入剖析JVM内存管理&lt;/li&gt;
&lt;li&gt;JVM垃圾回收机制&lt;/li&gt;
&lt;li&gt;JVM故障诊断性能调优&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一、JVM类加载机制&quot;&gt;&lt;a href=&quot;#一、JVM类加载机</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="JAVA虚拟机" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂云计算精髓MapReduce</title>
    <link href="https://ericzikun.github.io/2021/08/05/deep10-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%BA%91%E8%AE%A1%E7%AE%97%E7%B2%BE%E9%AB%93MapReduce/"/>
    <id>https://ericzikun.github.io/2021/08/05/deep10-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%BA%91%E8%AE%A1%E7%AE%97%E7%B2%BE%E9%AB%93MapReduce/</id>
    <published>2021-08-05T03:06:47.000Z</published>
    <updated>2021-09-28T06:07:09.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MapReduce-简介"><a href="#MapReduce-简介" class="headerlink" title="MapReduce 简介"></a>MapReduce 简介</h1><p>核心思想：“分而治之”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce思想在生活中处处可见。或多或少都曾接触过这种思想。MapReduce的思想核心 是“分而治之”，适用于大量复杂的任务处理场景(大规模数据处理场景)。</p><ul><li>Map负责——<strong>分</strong>，把复杂的任务分解为若干个“简单的任务”来并行处理。可以进行拆分的 前提是这些小任务可以并行计算，彼此间几乎没有<strong>依赖关系。</strong></li><li>Reduce负责——<strong>合</strong>，对map阶段的结果进行全局汇总。 MapReduce运行在yarn集群</li></ul><p>有两个阶段：</p><ol><li>ResourceManager</li><li>NodeManager</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这两个阶段合起来正是MapReduce思想的体现。后面再细说这两个阶段。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce的执行流程用下面这张图一目了然：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简而言之：首先将一个文件分成n片小文件，对每个小部分做map处理，最后再reduce汇总计算结果到一起<br><img src="https://img-blog.csdnimg.cn/5e3af54cd8bd441b83d6973bada83f0f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中的Reduce操作这里画了两个，可能是在汇总计算操作时对不同类型的数据做汇总处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有一个比较形象的语言解释MapReduce: 我们要数图书馆中的所有书。你数1号书架，我数2号书架。这就是“Map”。我们人越多，数书<br>就更快。 现在我们到一起，把所有人的统计数加在一起。这就是“Reduce”。</p><h1 id="MapReduce-设计构思"><a href="#MapReduce-设计构思" class="headerlink" title="MapReduce 设计构思"></a>MapReduce 设计构思</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce是一个分布式运算程序的编程框架，核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在Hadoop集群上。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。 为程序员提供一个抽象和高层的编程接口和框架。程序员<strong>仅需要关心其应用层的具体计算问题</strong>，仅需编写少量的处理应用本身计算问题的程序代码。如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来,交给计算框架去处理:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map和Reduce为程序员提供了一个清晰的操作接口抽象描述。MapReduce中定义了如下的Map 和Reduce两个抽象的编程接口，由用户去编程实现.Map和Reduce,MapReduce处理的数据类型是&lt;key,value&gt;键值对。</p><p>Map: (k1; v1) → [(k2; v2)]<br>Reduce: (k2; [v2]) → [(k3; v3)]</p><p>这里以wordcount来举例：</p><img src="https://img-blog.csdnimg.cn/e869575151bc4750a0b9c66664dd4158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>一个完整的mapreduce程序在分布式运行时有三类实例进程:</p><ol><li>MRAppMaster 负责整个程序的过程调度及状态协调 </li><li>MapTask 负责map阶段的整个数据处理流程</li><li>ReduceTask 负责reduce阶段的整个数据处理流程</li></ol><img src="https://img-blog.csdnimg.cn/b44ab181fd084ebe9fe72ebb01f75140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>总结：记住两点：必须由ResourceManager来接受计算任务并资源分配，由App Master来执行具体任务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MapReduce-简介&quot;&gt;&lt;a href=&quot;#MapReduce-简介&quot; class=&quot;headerlink&quot; title=&quot;MapReduce 简介&quot;&gt;&lt;/a&gt;MapReduce 简介&lt;/h1&gt;&lt;p&gt;核心思想：“分而治之”&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nb</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="云计算" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://ericzikun.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="MapReduce" scheme="https://ericzikun.github.io/tags/MapReduce/"/>
    
    <category term="hadoop" scheme="https://ericzikun.github.io/tags/hadoop/"/>
    
    <category term="分布式" scheme="https://ericzikun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>弄懂服务端、客户端【手写一个socket聊天室】</title>
    <link href="https://ericzikun.github.io/2021/08/02/deep9-%E5%BC%84%E6%87%82%E6%9C%8D%E5%8A%A1%E7%AB%AF%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%90%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAsocket%E8%81%8A%E5%A4%A9%E5%AE%A4%E3%80%91/"/>
    <id>https://ericzikun.github.io/2021/08/02/deep9-%E5%BC%84%E6%87%82%E6%9C%8D%E5%8A%A1%E7%AB%AF%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%90%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAsocket%E8%81%8A%E5%A4%A9%E5%AE%A4%E3%80%91/</id>
    <published>2021-08-02T08:15:50.000Z</published>
    <updated>2021-08-02T09:36:17.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见架构："><a href="#常见架构：" class="headerlink" title="常见架构："></a>常见架构：</h2><p>C/S架构：Client/Server(客户端/服务器)结构<img src="https://img-blog.csdnimg.cn/4eb987112f954ccfacc5390c87394ea3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>B/S架构：Browser/Server(浏览器/服务器)结构<br><img src="https://img-blog.csdnimg.cn/3ddc8a3513924c2dbca0b5c8f740f1a9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="服务端和客户端"><a href="#服务端和客户端" class="headerlink" title="服务端和客户端"></a>服务端和客户端</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简单地说：一般客户端负责和用户的交互，也就是屏幕显示(UI/UE)，服务端负责数据存储，也就是你的用户数据，而计算能力，客户端和服务端一般各负责一部分。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 微信、qq这种聊天功能一般在用户之间通信时，用户的数据先是发送到服务器上的，然后通过服务器进行转发给指定用户，从而完成一次用户间的通信，那么如何证明这一点呢？比如一下几种场景：</p><ol><li>当A用户不在线时，B用户给A发送，A是接收不到的，当A一上线，信息会立马发送给他，可推理出B用户发送的数据会保存在服务器中。</li><li>当A用户给B传输文件时，上传完后，B需要下载才可传输到本地，说明下载之前已经上传到服务器了，如果清空本地的该文件，在一定时间范围内仍然可以重新下载回来，说明服务器上文件还在。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于一个简单的群聊功能，实现的基本原理就是，客户端给服务器发送数据，服务器再将请求发送给其他客户端，从而完成转发，单聊那就是在客户端传服务器的过程中加入了目标用户识别码。</li></ol><h2 id="TCP-IP、UDP？"><a href="#TCP-IP、UDP？" class="headerlink" title="TCP/IP、UDP？"></a>TCP/IP、UDP？</h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里有一张图，表明了这些协议的关系。   <strong>TCP/IP协议族包括运输层、网络层、链路层。</strong><br><img src="https://img-blog.csdnimg.cn/3f62427555804da288d52f933babf2f1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h2 id="Socket技术"><a href="#Socket技术" class="headerlink" title="Socket技术"></a>Socket技术</h2><img src="https://img-blog.csdnimg.cn/e43ecb011edf4531883da487a41db724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简单来说，socket就是对tcp/ip协议的封装，在java中是一个类，方便用户去完成通信。</p><img src="https://img-blog.csdnimg.cn/6541003ddc4843e7a5ed40cac608c162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h3 id="Socket建立通信的流程："><a href="#Socket建立通信的流程：" class="headerlink" title="Socket建立通信的流程："></a>Socket建立通信的流程：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 服务端的ServerSocket通过绑定ip和port，从而完成初始化，以保证在port下监听待接入的客户端,accept()函数使得监听到接入的客户端，这里可以采用死循环【建立新的线程】保持服务端一直在监听并接受新的客户端的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">Socket socket = ss.accept();</span><br></pre></td></tr></table></figure><p>客户端：<br>同样通过绑定ip port建立Socket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket = <span class="keyword">new</span> Socket(host, port);</span><br></pre></td></tr></table></figure><p>服务端accept得到的Socket相当于是在客户端自建的Socket基础之上构建的新的Socket</p><p>服务端得到了与客户端连接的Socket之后便可以拿到该Socket的输入、输出流；<br>对于客户端也是一样，需要通过Socket拿到输入输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream is= socket.getInputStream();</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br></pre></td></tr></table></figure><h2 id="群聊代码："><a href="#群聊代码：" class="headerlink" title="群聊代码："></a>群聊代码：</h2><p>思路：<br><img src="https://img-blog.csdnimg.cn/83a0c801c17448c3a6acc2351603f43f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 服务端和客户端通信必须构建一个管道，管道的两端分别是InputStream、OutputStream，当服务端输出时用OutputStream，某一个客户端对应的就是InputStream来接受服务端的输出，即每个管道的输入输出一一对应。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么对于服务端来说，他的输入流，应该是客户端的输出流，有多少个客户端，就应该有多少个线程来维护这个管道，所以每连接一个客户端，就应该启动一个输入流给服务端。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么，服务端的输出流（输出的线程）应该有多少个呢，如果要实现转发 群发功能，那么服务端的输出流线程只能是一个 里面有多个输出流，因为它要给每一个客户端去发消息，消息可以存在消息列表里面，每次从msgQueue里面拿出第一个消息，然后发送给每一个客户端，所以对于服务端的输出线程，它理应包含一个list去装载每一个客户端的socket，这样才能在群发时 遍历每一个客户端的socket 并且拿到socket对应的输出流，将消息群发出去。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于1个客户端来说，比服务端简单很多，输入流（输入线程）就只用构建一个，用于接受客户端输出的数据，输出流（输出线程）也是构建一个，用于发送给服务端。具体的代码架构如下图所示，将客户端和服务端代码分离，便于维护和后期拓展功能</p><img src="https://img-blog.csdnimg.cn/28bbdcce6692413599f38399e62be2bf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.client.InputThread;</span><br><span class="line"><span class="keyword">import</span> chatroom.client.OutputThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 10:42 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Socket对象</span></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//服务器的Ip地址和服务器所使用的端口号</span></span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">8082</span>;</span><br><span class="line">    <span class="keyword">private</span> String label = <span class="string">"客户端"</span>;</span><br><span class="line">    <span class="keyword">private</span> String clientName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">        createCient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createCient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">            createInput(socket,label);</span><br><span class="line">            createOutput(socket,label);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createOutput</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        OutputThread outputThread = <span class="keyword">new</span> OutputThread(socket,label);</span><br><span class="line">        outputThread.setClientName(clientName);</span><br><span class="line">        <span class="keyword">new</span> Thread(outputThread).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createInput</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        InputThread inputThread = <span class="keyword">new</span> InputThread(socket,label);</span><br><span class="line">        <span class="keyword">new</span> Thread(inputThread).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"客户端1"</span>);</span><br><span class="line">        Client client2 = <span class="keyword">new</span> Client(<span class="string">"客户端2"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:24 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputThread</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = is.read(b);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//客户端输入：接受服务端的输出</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:26 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String label; <span class="comment">// 记录是客户端 or 服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String clientName; <span class="comment">//记录客户端的名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputThread</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientName</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//客户端 接受用户的输入 发送到服务端</span></span><br><span class="line">            System.out.println(<span class="string">"请输入要发送的内容"</span>);</span><br><span class="line">            Scanner ss = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String ans = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> curTime = System.currentTimeMillis();</span><br><span class="line">                curTime = curTime;</span><br><span class="line">                ans = clientName + <span class="string">"："</span> + ss.nextLine();</span><br><span class="line"></span><br><span class="line">                os.write(ans.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (</span><br><span class="line">                IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.client.Client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 3:42 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：客户端1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"客户端1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.client.Client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 3:42 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"客户端2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.server.InputThread;</span><br><span class="line"><span class="keyword">import</span> chatroom.server.OutputThread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 10:43 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">8082</span>;</span><br><span class="line">    <span class="keyword">private</span> String label = <span class="string">"服务端"</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> LinkedBlockingDeque&lt;String&gt; msgQueue;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Socket&gt; sockets;<span class="comment">//维护每一个与客户端连接的socket</span></span><br><span class="line">    <span class="keyword">public</span> Integer clientNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        createServer();</span><br><span class="line">        <span class="keyword">this</span>.clientNum = sockets.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务器套接字</span></span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println((<span class="string">"服务器已经启动,监听端口为"</span> + port));</span><br><span class="line">            <span class="comment">//初始化一个msgQueue用于存放客户端传来的数据</span></span><br><span class="line">            <span class="keyword">this</span>.msgQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">            <span class="keyword">this</span>.sockets = <span class="keyword">new</span> ArrayList&lt;Socket&gt;();</span><br><span class="line"></span><br><span class="line">            createOutput(sockets, msgQueue);</span><br><span class="line">            <span class="comment">// 给客户端发送信息 只需要维护一个OutputThread即可 以保证每次从msgQueue里取一次msg</span></span><br><span class="line">            <span class="comment">// 都能将该msg群发个多个客户端</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                Socket socket = ss.accept();</span><br><span class="line">                sockets.add(socket);</span><br><span class="line">                createInput(socket, msgQueue);<span class="comment">//每一个与客户端之间的socket都需要建立一个inputThread去接收</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//服务器套接字等待一个客服端socket连入，如果连接成功的话，就会创建一个套接字，不然在这里一直等待</span></span><br><span class="line">                System.out.println(<span class="string">"已经接受连接"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程 OutputThread：服务端输出到客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOutput</span><span class="params">(ArrayList&lt;Socket&gt; sockets, LinkedBlockingDeque&lt;String&gt; msgQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        OutputThread outputThread = <span class="keyword">new</span> OutputThread(msgQueue, sockets);</span><br><span class="line">        <span class="keyword">new</span> Thread(outputThread).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程 InputThread：服务端接受客户端的输入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createInput</span><span class="params">(Socket socket, LinkedBlockingDeque&lt;String&gt; msgQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputThread inputThread = <span class="keyword">new</span> InputThread(socket, msgQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(inputThread).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:24 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">public</span>   LinkedBlockingDeque&lt;String&gt; msgQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputThread</span><span class="params">(Socket socket,LinkedBlockingDeque&lt;String&gt; msgQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgQueue</span><span class="params">(LinkedBlockingDeque&lt;String&gt; msgQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is= socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = is.read(b);</span><br><span class="line">                <span class="comment">//接受客户端传来的信息</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(b , <span class="number">0</span>, len));</span><br><span class="line">                <span class="comment">//再把信息传到集合中去，再在outputThread中输出给其他客户端</span></span><br><span class="line">                msgQueue.add(<span class="keyword">new</span> String(b , <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:26 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Socket&gt; sockets;</span><br><span class="line">    <span class="keyword">public</span> LinkedBlockingDeque&lt;String&gt; msgQueue;</span><br><span class="line">    <span class="keyword">private</span> String label; <span class="comment">// 记录是客户端 or 服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputThread</span><span class="params">(LinkedBlockingDeque&lt;String&gt; msgQueue, ArrayList&lt;Socket&gt; sockets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sockets = sockets;</span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgQueue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    String poll = msgQueue.poll();</span><br><span class="line">                    <span class="comment">//群发给所有客户端</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sockets.size(); i++) &#123;</span><br><span class="line">                        Socket curSocket = sockets.get(i);</span><br><span class="line">                        os = curSocket.getOutputStream();</span><br><span class="line">                        os.write(poll.getBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见架构：&quot;&gt;&lt;a href=&quot;#常见架构：&quot; class=&quot;headerlink&quot; title=&quot;常见架构：&quot;&gt;&lt;/a&gt;常见架构：&lt;/h2&gt;&lt;p&gt;C/S架构：Client/Server(客户端/服务器)结构&lt;img src=&quot;https://img-blog.c</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="socket" scheme="https://ericzikun.github.io/tags/socket/"/>
    
    <category term="服务端" scheme="https://ericzikun.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    <category term="客户端" scheme="https://ericzikun.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>深入线程池【手写线程池！阿里弃用之辨析】</title>
    <link href="https://ericzikun.github.io/2021/07/01/deep8-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://ericzikun.github.io/2021/07/01/deep8-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-07-01T05:40:40.000Z</published>
    <updated>2021-07-01T05:44:23.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 线程池和<strong>数据库连接池</strong>非常类似，可以统一管理和维护线程，减少没有必要的开销。 </p><h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为频繁的开启线程或者停止线程，线程需要从新被 cpu 从就绪到运行状态调度，需要发生<br>cpu 的上下文切换，效率非常低。<br><img src="https://img-blog.csdnimg.cn/20210630105323135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><blockquote><p>当线程从run中sleep后，会到达阻塞状态，这时候要想再回到run状态，得先就绪再到run状态，成本极高；</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 分析：如果这里有100个线程，则会新建100个newThread，100次start，100次的就绪，100次的CPU调度，才能被运行，必然也有100次的销毁，整个的成本非常高！<br>所以我们提前创建好100个线程，都在<strong>运行状态</strong>，只要有请求过来了，直接再run方法中进行执行就行了！而不是又经过创建-&gt;就绪-&gt;运行 这个耗时的过程！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p><h1 id="哪里使用到线程池"><a href="#哪里使用到线程池" class="headerlink" title="哪里使用到线程池"></a>哪里使用到线程池</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实际开发项目中 禁止自己 new 线程。必须使用线程池来维护和创建线程。<br><img src="https://img-blog.csdnimg.cn/20210630111710128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际企业开发中，如果像这样去new线程，那一定会被开除！！</p><blockquote><p>如果别人找到了这个bug，比如你这个接口有每次创建线程的bug，那么别人可以通过这个bug给你服务器攻击！造成CPU飙高，线程池就可以很好的管理，管理线程创建的数量，而不是无限制的创建！</p></blockquote><h1 id="线程池有哪些作用"><a href="#线程池有哪些作用" class="headerlink" title="线程池有哪些作用"></a>线程池有哪些作用</h1><p>核心点：复用机制 提前创建好固定的线程一直在运行状态 实现复用 限制线程创建数量。<br>1.<strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。<br>2.<strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。<br>3.<strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。<br>4.<strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池 ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</p><p>总结：<strong>统一维护管理</strong></p><h1 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h1><p>Executors.newCachedThreadPool(); 可缓存线程池<br>Executors.newFixedThreadPool()；可定长度 限制最大线程数<br>Executors.newScheduledThreadPool() ； 可定时<br>Executors.newSingleThreadExecutor(); 单例<br>底层都是基于 ThreadPoolExecutor 构造函数封装</p><blockquote><p>前面四个基本上实际生产不会去用，阿里巴巴不推荐，因为底层都是由ThreadPoolExecutor 构造封装的，而构造函数中是一个无界的队列（后面解释）</p></blockquote><h3 id="Executors-newCachedThreadPool-："><a href="#Executors-newCachedThreadPool-：" class="headerlink" title="Executors.newCachedThreadPool()："></a>Executors.newCachedThreadPool()：</h3> <img src="https://img-blog.csdnimg.cn/2021063011395861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" />下面是它的源码部分<img src="https://img-blog.csdnimg.cn/20210630114057781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" />核心线程数传的0，最大是无限，没有界限，如果用这个无限的去创建，而不是复用机制，故不去用！这个api实际开发不用！ 可以改成可定长度线程池，这样即使for循环有10个线程创建，但是会被传入的nThread所限制。<img src="https://img-blog.csdnimg.cn/20210630114422898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /># 线程池底层是如何实现复用的本质思想：创建一个线程，不会立马停止或者销毁而是一直实现复用。1. 提前创建固定大小的线程一直保持在正在运行状态；（可能会非常消耗 cpu 的资源）2. 当需要线程执行任务，将该任务提交缓存在并发队列中；如果缓存队列满了，则会执行拒绝策略；3. 正在运行的线程从并发队列中获取任务执行从而实现多线程复用问题；<p><img src="https://img-blog.csdnimg.cn/2021063011505721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>线程的核心点：复用机制——</p><ol><li>提前创建好固定的线程一直在运行状态—-死循环实现</li><li>提交的线程任务缓存到一个并发队列集合中，交给我们正在运行的线程执行</li><li>正在运行的线程就从队列中获取该任务执行</li></ol><p>如何保证线程一直在运行，而不会停掉被销毁呢？———加一个<strong>while死循环</strong>即可</p><img src="https://img-blog.csdnimg.cn/2021063011531157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h1 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h1><p>思路：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先线程池得定义一系列线程，并且构造的时候让这些线程都处于一个运行状态，用workThreads代替，构造的时候可以给定限制的工作线程数量以及任务集合中的size上限，运行状态通过改写每一个工作线程的run方法即可，利用死循环让其处于一直运行的状态！具体每一个工作线程要做的任务是什么，就通过拿取runnableDeque这个队列中的每一个任务即可，poll方法拿取后便删除该任务。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想控制线程池使得结束，可以通过控制工作线程中while循环的条件，设置一个isRun的Boolean变量，并且当任务队列中没有任务了之后线程池才停止工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExecutors</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WorkThread&gt; workThreads;</span><br><span class="line">    <span class="comment">// 缓存我们线程任务</span></span><br><span class="line">    <span class="keyword">private</span> BlockingDeque&lt;Runnable&gt; runnableDeque;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRun = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大线程数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxThreadCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExecutors</span><span class="params">(<span class="keyword">int</span> maxThreadCount, <span class="keyword">int</span> dequeSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.限制队列容量缓存</span></span><br><span class="line">        runnableDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(dequeSize);</span><br><span class="line">        <span class="comment">//2.提前创建好固定的线程一直在运行状态----死循环实现</span></span><br><span class="line">        workThreads = <span class="keyword">new</span> ArrayList&lt;WorkThread&gt;(maxThreadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxThreadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> WorkThread().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (isRun||runnableDeque.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                Runnable runnable = runnableDeque.poll();</span><br><span class="line">                <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runnableDeque.offer(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyExecutors myExecutors = <span class="keyword">new</span> MyExecutors(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            myExecutors.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">","</span> + finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        myExecutors.isRun = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadPoolExecutor核心参数"><a href="#ThreadPoolExecutor核心参数" class="headerlink" title="ThreadPoolExecutor核心参数"></a>ThreadPoolExecutor核心参数</h1><p>corePoolSize：核心线程数量 一直正在保持运行的线程<br>maximumPoolSize：最大线程数，线程池允许创建的最大线程数。<br>keepAliveTime：超出 corePoolSize 后创建的线程的存活时间。<br>unit：keepAliveTime 的时间单位。<br>workQueue：任务队列，用于保存待执行的任务。<br>threadFactory：线程池内部创建线程所用的工厂。<br>handler：任务无法执行时的处理器。</p><h2 id="线程池创建的线程会一直在运行状态吗？"><a href="#线程池创建的线程会一直在运行状态吗？" class="headerlink" title="线程池创建的线程会一直在运行状态吗？"></a>线程池创建的线程会一直在运行状态吗？</h2><p>不会<br>例如：配置核心线程数 corePoolSize 为 2 、最大线程数 maximumPoolSize 为 5<br>我们可以通过配置超出 corePoolSize 核心线程数后创建的线程的存活时间例如为 60s，在 60s 内非核心线程一直没有任务执行，则会停止该线程。<br>总结：核心线程数是一直在运行的，但最大线程数是不一定的，看具体任务，如果任务的情况下补给到最大线程范围内更多的线程进来工作，最大线程减去核心线程的这部分线程在工作完后再销毁。<br>目的：为了节约服务器资源</p><h2 id="为什么阿里巴巴不建议使用-Executors"><a href="#为什么阿里巴巴不建议使用-Executors" class="headerlink" title="为什么阿里巴巴不建议使用 Executors"></a>为什么阿里巴巴不建议使用 Executors</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为默认的 Executors 线程池底层是基于 ThreadPoolExecutor构造函数封装的，采用<strong>无界队列存放缓存任务</strong>，会无限缓存任务容易发生内存溢出，会导致我们最大线程数会失效。<br><img src="https://img-blog.csdnimg.cn/20210630151105463.png"  style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，</span><br><span class="line">这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </span><br><span class="line">说明：Executors各个方法的弊端：</span><br><span class="line"><span class="number">1</span>）newFixedThreadPool和newSingleThreadExecutor:</span><br><span class="line">  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至<span class="number">1</span>OOM。</span><br><span class="line"><span class="number">2</span>）newCachedThreadPool和newScheduledThreadPool:</span><br><span class="line">  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至<span class="number">1</span>OOM。</span><br></pre></td></tr></table></figure><h2 id="线程池底层-ThreadPoolExecutor-底层实现原理"><a href="#线程池底层-ThreadPoolExecutor-底层实现原理" class="headerlink" title="线程池底层 ThreadPoolExecutor 底层实现原理"></a>线程池底层 ThreadPoolExecutor 底层实现原理</h2><p>1.当线程数小于核心线程数时，创建线程。<br>2.当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。<br>3.当线程数大于等于核心线程数，且任务队列已满<br>3.1 若线程数小于最大线程数，创建线程<br>3.2 若线程数等于最大线程数，抛出异常，拒绝任务<br>看例子：<br>分析：首先创建了一个线程池，有2个核心线程，4个最大线程，并且blockingQueue的容量为5（用于缓存任务队列），然后我们再for中提交了10个任务进行执行，第一个和第二个任务直接被2个核心线程来执行，3、4、5、6、7就被缓存到容量为5的blockingQueue队列中了，然后遍历到第八个新任务的时候，当前的线程数已经大于了核心线程数，并且任务队列已经装满了，那就再创建（最大线程数-核心线程数）个线程，这里也就是2个新的工作线程被创建去执行第8、第9个任务，当遍历到第10个任务的时候，就已经没有工作线程来执行了，并且任务队列之前也装满了，从而拒绝任务！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.提交的线程任务数&lt;核心线程数  （核心线程数任务复用）</span></span><br><span class="line">        <span class="comment">//2.提交的线程任务数&gt;核心线程数 且我们队列容量没有满 将该任务缓存到我们队列中</span></span><br><span class="line">        <span class="comment">// 循环3 4 5 6 7 缓存到我们队列中</span></span><br><span class="line">        <span class="comment">//3.提交的线程任务数&gt;核心线程数 且我们队列容量满了</span></span><br><span class="line">        <span class="comment">//8,9，10</span></span><br><span class="line">        <span class="comment">// 最多在额外创建两个线程 4-2 2个线程</span></span><br><span class="line">        <span class="comment">// 2个线程 8 ,9</span></span><br><span class="line">        <span class="comment">// 10个任务----拒绝</span></span><br><span class="line">        ExecutorService executorService = MyThreadPoolExecutor.newFixedThreadPool(<span class="number">2</span>, <span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">","</span> + finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实际上最多执行多少个任务 核心线程数+缓存队列的容量+最大线程数-核心线程数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己重写的一个ExecutorService，限制了传入的核心线程数、最大线程数、以及任务队列的容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">int</span> blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(blockingQueue), (RejectedExecutionHandler) <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池队列满了，任务会丢失吗"><a href="#线程池队列满了，任务会丢失吗" class="headerlink" title="线程池队列满了，任务会丢失吗"></a>线程池队列满了，任务会丢失吗</h2><p>如果队列满了，且任务总数&gt;最大线程数则当前线程走拒绝策略。<br>可以自定义异拒绝异常，将该任务缓存到 redis、本地文件、mysql 中后期项目启动实现补偿。<br>1.AbortPolicy 丢弃任务，抛运行时异常<br>2.CallerRunsPolicy 执行任务<br>3.DiscardPolicy 忽视，什么都不会发生<br>4.DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务</p><h2 id="线程池拒绝策略类型有哪些呢"><a href="#线程池拒绝策略类型有哪些呢" class="headerlink" title="线程池拒绝策略类型有哪些呢"></a>线程池拒绝策略类型有哪些呢</h2><p>1.AbortPolicy 丢弃任务，抛运行时异常<br>2.CallerRunsPolicy 执行任务<br>3.DiscardPolicy 忽视，什么都不会发生<br>4.DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务<br>5.实现 RejectedExecutionHandler 接口，可自定义处理器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是线程池&quot;&gt;&lt;a href=&quot;#什么是线程池&quot; class=&quot;headerlink&quot; title=&quot;什么是线程池&quot;&gt;&lt;/a&gt;什么是线程池&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 线程池和&lt;strong</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="线程池" scheme="https://ericzikun.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>别再问我字符串了！彻底理解Java中的字符串（==、equals、堆内存、常量池）</title>
    <link href="https://ericzikun.github.io/2021/06/29/deep7-%E6%B7%B1%E5%85%A5Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://ericzikun.github.io/2021/06/29/deep7-%E6%B7%B1%E5%85%A5Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-06-29T03:41:40.000Z</published>
    <updated>2021-07-01T05:41:52.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="equals、"><a href="#equals、" class="headerlink" title="equals、=="></a>equals、==</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先明确一点，==比较的是引用，equals比较的是内容，在类库没有定义equals方法重写的情况下，自然继承的是Object类的equals方法，上源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么对于String类来说，官方已封装了复写之后的equals方法，比较的是具体内容，判断：如果是引用相同，也就是堆内的地址相同，那么就是同一个对象，直接返回true，否则就遍历字符串中的每一个字符进行比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，字符串还有个常量池，也就是说如果先定义了一个”ABC”字符串，再定义一个相同字符串的时候，会首先去常量池里面找之前有没有定义，如果有，则直接指向常量池的同一地址。</p><h2 id="常量池介绍"><a href="#常量池介绍" class="headerlink" title="常量池介绍"></a>常量池介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化</p><ul><li><p>为字符串开辟一个字符串常量池，类似于缓存区</p></li><li><p>创建字符串常量时，首先坚持字符串常量池是否存在该字符串</p></li><li><p>存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了以上的铺垫，后面几个问题就好解释了：</p><h1 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"ABC"</span>);</span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">        System.out.println(str2 == str3);<span class="comment">// flase</span></span><br><span class="line">        System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2.equals(str3)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str1与str2都指向的是常量池中同一个字符串的地址，所以==为true，而str3是new了一个新的对象，会在堆中新建一个内存地址，所以比较str3和str3的地址时则为flase，equals就简单了，比较的均为字符串内容，故均为true。<br><img src="https://img-blog.csdnimg.cn/20210629134246186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h1 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"ABC"</span>);</span><br><span class="line">        String str3_1=str3.intern();</span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">        System.out.println(str2 == str3);<span class="comment">// flase</span></span><br><span class="line">        System.out.println(str3_1 == str1);<span class="comment">// true</span></span><br><span class="line">        System.out.println(str3_1 == str3);<span class="comment">// flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们新定义一个str3_1变量，让他取str3的intern()方法，此方法是这样定义的：</p><blockquote><p>这是一个native的方法，书上是这样描述它的作用的：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回常量池池中这个字符串的String对象；否则，将此String对象包含的字符添加到常量池中，并返回此String对象的引用。</p></blockquote><p>所以str3_1拿到的是常量池中的”ABC“地址，和str1、str2的地址肯定是相同的，</p><h1 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        str1 +=<span class="string">"D"</span>;</span><br><span class="line">        String str5 = <span class="string">"ABCD"</span>;<span class="comment">// 肯定在常量池中生成一个</span></span><br><span class="line">        System.out.println(str5 == str1);<span class="comment">//flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里如果给str1拼接了一个D字符串，这里通过javap命令查看字节码文件，会发现+=操作在String源码中调用的其实是apped方法，生成的是一个新的对象堆地址，str5指向的常量池的地址与str1指向的堆对象地址不一，如果我在str1拼接之后加上str1 = str1.intern(); 这时候由于str1指向的是常量池中的ABCD，==就为true了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        str1 +=<span class="string">"D"</span>;</span><br><span class="line">        str1 = str1.intern();</span><br><span class="line">        String str5 = <span class="string">"ABCD"</span>;<span class="comment">// 肯定在常量池中生成一个</span></span><br><span class="line">        System.out.println(str5 == str1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里intern调用之后，如果常量池中没有”ABCD“，则会在常量池生成，如果有则直接指向它。所以此处的str1指向的是常量池中的”ABCD“，后面定义的str5在构造时则会直接指向常量池中的”ABCD“</p><p>如果这里把str1 += ”D“修改一下成常量与常量的拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        str1 =<span class="string">"ABC"</span> +<span class="string">"D"</span>;</span><br><span class="line">        String str5 = <span class="string">"ABCD"</span>;<span class="comment">// 肯定在常量池中生成一个</span></span><br><span class="line">        System.out.println(str5 == str1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果两个常量进行拼接，编译器会自动优化成”ABCD”，也就是存到了常量池中去了，str5指向的也是常量池中的值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>原则：</p><p>（1）常量+常量：结果是常量池</p><p>（2）常量与变量 或 变量与变量：结果是堆</p><p>（3）拼接后调用intern方法：结果在常量池</p><p>new 出来的是在堆空间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;equals、&quot;&gt;&lt;a href=&quot;#equals、&quot; class=&quot;headerlink&quot; title=&quot;equ</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="字符串" scheme="https://ericzikun.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="堆内存" scheme="https://ericzikun.github.io/tags/%E5%A0%86%E5%86%85%E5%AD%98/"/>
    
    <category term="常量池" scheme="https://ericzikun.github.io/tags/%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mac Alfred 工作流 Python开发，可自定义任何接口，全自动化办公</title>
    <link href="https://ericzikun.github.io/2021/06/29/Mac-Alfred-%E5%B7%A5%E4%BD%9C%E6%B5%81-Python%E5%BC%80%E5%8F%91%EF%BC%8C%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E4%BD%95%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/"/>
    <id>https://ericzikun.github.io/2021/06/29/Mac-Alfred-%E5%B7%A5%E4%BD%9C%E6%B5%81-Python%E5%BC%80%E5%8F%91%EF%BC%8C%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E4%BD%95%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/</id>
    <published>2021-06-29T03:40:49.000Z</published>
    <updated>2021-06-29T06:10:41.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用Mac的人应该大多都知道这个，但是workflow工作流，应该是很多人没自己写过，得知支持Python脚本后，自己花了几个小时研究了一下如何把接口融合到Alfred快捷方式中，这里给大家提供一个模板，以这样的形式，无论是免费api还是自己封装的工具接口，均可集成到Alfred中！</p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="https://img-blog.csdnimg.cn/20210629100429404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210629100454129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="申请接口"><a href="#申请接口" class="headerlink" title="申请接口"></a>申请接口</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 市面上有很多免费接口，这里以聚合数据的头条新闻api为例，链接：<a href="https://www.juhe.cn/docs/api/id/235，在官网注册申请api即可，得到一个key，发送请求参数时带上key和其他参数即可。" target="_blank" rel="noopener">https://www.juhe.cn/docs/api/id/235，在官网注册申请api即可，得到一个key，发送请求参数时带上key和其他参数即可。</a></p><h1 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h1><h2 id="建立空白workflow"><a href="#建立空白workflow" class="headerlink" title="建立空白workflow"></a>建立空白workflow</h2><p><img src="https://img-blog.csdnimg.cn/20210629092138388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210629092200330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>填上基本信息即可，也可以设置一个图标<br>再在里面空白处右键选择script filter<br><img src="https://img-blog.csdnimg.cn/20210629092344177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210629100110687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在script filter里面，我们去运行Python脚本，接受的参数就是”{query}”可以进行传参，这里采用了一个免费的头条新闻api，只要接口能测成功即可，不赘述:<br><img src="https://img-blog.csdnimg.cn/20210629095727194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Python代码，整体思路就是，定义好获取接口数据的方法，并将结果返回给workflow的具体字段即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">Project Name: alfredProjects</span></span><br><span class="line"><span class="string">File Name: alfredTest.py</span></span><br><span class="line"><span class="string">Author: apple</span></span><br><span class="line"><span class="string">Create Date: 2021/6/28</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> workflow <span class="keyword">import</span> Workflow, web, ICON_WEB</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line"></span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">query_map = dict(</span><br><span class="line">    inner=<span class="string">u"输入in搜索头条国内新闻"</span>,</span><br><span class="line">    outter=<span class="string">'输入out搜索头条国际新闻'</span>,</span><br><span class="line">    top=<span class="string">u'输入top搜索热点新闻'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_recent_news</span><span class="params">(query)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> query == <span class="string">"in"</span>:</span><br><span class="line">        url = <span class="string">"http://v.juhe.cn/toutiao/index?"</span></span><br><span class="line">        params = &#123;<span class="string">"key"</span>: <span class="string">"dd0fb509ac5407213bc6a0fddd48f234"</span>,</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"guonei"</span>&#125;</span><br><span class="line">    <span class="keyword">elif</span> query == <span class="string">"out"</span>:</span><br><span class="line">        url = <span class="string">"http://v.juhe.cn/toutiao/index?"</span></span><br><span class="line">        params = &#123;<span class="string">"key"</span>: <span class="string">"dd0fb509ac5407213bc6a0fddd48f234"</span>,</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"guoji"</span>&#125;</span><br><span class="line">    <span class="keyword">elif</span> query == <span class="string">"top"</span>:</span><br><span class="line">        url = <span class="string">"http://v.juhe.cn/toutiao/index?"</span></span><br><span class="line">        params = &#123;<span class="string">"key"</span>: <span class="string">"dd0fb509ac5407213bc6a0fddd48f234"</span>,</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"top"</span>&#125;</span><br><span class="line"></span><br><span class="line">    r = web.post(url, data=params)</span><br><span class="line">    print(r)</span><br><span class="line">    <span class="comment"># throw an error if request failed, Workflow will catch this and show</span></span><br><span class="line">    <span class="comment"># it to the user</span></span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    <span class="comment"># result = r.json()</span></span><br><span class="line">    <span class="keyword">return</span> r.json()[<span class="string">"result"</span>][<span class="string">'data'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(wf)</span>:</span></span><br><span class="line">    query = wf.args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> query:</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">"inner"</span>, <span class="string">"outter"</span>, <span class="string">"top"</span>]:</span><br><span class="line">            wf.add_item(</span><br><span class="line">                title=query_map[key],</span><br><span class="line">                valid=<span class="literal">True</span>,</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> get_recent_news(query)</span><br><span class="line"></span><br><span class="line">        news = wf.cached_data(query, wrapper, max_age=<span class="number">300</span>)</span><br><span class="line">        <span class="comment"># news = get_recent_news(query)</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> news:</span><br><span class="line">            wf.add_item(title=<span class="string">u"【&#123;&#125;】&#123;&#125;"</span>.format(r[<span class="string">"author_name"</span>], r[<span class="string">'title'</span>]),</span><br><span class="line">                        arg=r[<span class="string">'url'</span>],</span><br><span class="line">                        valid=<span class="literal">True</span>,</span><br><span class="line">                        icon=ICON_WEB)</span><br><span class="line">    <span class="comment"># Send output to Alfred. You can only call this once.</span></span><br><span class="line">    <span class="comment"># Well, you *can* call it multiple times, but Alfred won't be listening</span></span><br><span class="line">    <span class="comment"># any more...</span></span><br><span class="line">    wf.send_feedback()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    wf = Workflow()</span><br><span class="line">    sys.exit(wf.run(main))</span><br></pre></td></tr></table></figure><p>最后说一下脚本和相关库放在哪里：<br> <img src="https://img-blog.csdnimg.cn/20210629100050804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击后，会在finder显示该工作流的文件夹，将workflow库以及Python脚本放在此下即可：<br><img src="https://img-blog.csdnimg.cn/20210629100136563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="跳转页面"><a href="#跳转页面" class="headerlink" title="跳转页面"></a>跳转页面</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于返回的json数据里面，每个新闻有个url，我们将url设为workflow的item args即可，代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wf.add_item(title=<span class="string">u"【&#123;&#125;】&#123;&#125;"</span>.format(r[<span class="string">"author_name"</span>], r[<span class="string">'title'</span>]),</span><br><span class="line">                       arg=r[<span class="string">'url'</span>],</span><br><span class="line">                       valid=<span class="literal">True</span>,</span><br><span class="line">                       icon=ICON_WEB)</span><br></pre></td></tr></table></figure><p>再在script filter之后接一个url即可：<br><img src="https://img-blog.csdnimg.cn/20210629100833240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Alfred&quot;&gt;&lt;a href=&quot;#Alfred&quot; class=&quot;headerlink&quot; title=&quot;Alfred&quot;&gt;&lt;/a&gt;Alfred&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用Mac的人应该大多都</summary>
      
    
    
    
    <category term="技巧" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="提升效率" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E5%B7%A7/%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87/"/>
    
    
    <category term="效率" scheme="https://ericzikun.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="学术" scheme="https://ericzikun.github.io/tags/%E5%AD%A6%E6%9C%AF/"/>
    
    <category term="Mac" scheme="https://ericzikun.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>多线程中的wait与sleep ,synchronize与lock有啥子区别?死锁辨析</title>
    <link href="https://ericzikun.github.io/2021/06/26/deep6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84wait%E4%B8%8Esleep-synchronize%E4%B8%8Elock%E6%9C%89%E5%95%A5%E5%AD%90%E5%8C%BA%E5%88%AB-%E6%AD%BB%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81%E8%BE%A8%E6%9E%90/"/>
    <id>https://ericzikun.github.io/2021/06/26/deep6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84wait%E4%B8%8Esleep-synchronize%E4%B8%8Elock%E6%9C%89%E5%95%A5%E5%AD%90%E5%8C%BA%E5%88%AB-%E6%AD%BB%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81%E8%BE%A8%E6%9E%90/</id>
    <published>2021-06-26T13:55:47.000Z</published>
    <updated>2021-06-29T06:01:58.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wait与sleep"><a href="#wait与sleep" class="headerlink" title="wait与sleep"></a>wait与sleep</h1><ol><li>来自不同的类<br>首先，wait和sleep都不是一个类下的方法：<br>wait来自：Object<br>sleep来自：Thread<img src="https://img-blog.csdnimg.cn/20210626221030902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210626221053496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></li></ol><p>因为java中所有的类都是继承自object的，所以所有类都可以调用wait方法，这是一个final的方法，同时不是一个静态方法，所以调用该方法需要先实例化一个Object对象才可以</p><ol start="2"><li>释放锁的不同<br>wait 会释放锁，sleep 睡觉了，抱着锁睡觉，不会释放!  也就是说，如果有两个线程，其中一个锁住了某个对象时，中间sleep了，这时候另一个线程时拿不到该对象的锁的，得等第一个线程sleep完并释放锁才可。<br>wait会释放这个锁，并把这个wait的线程加入到这个锁的等待队列中去</li><li>使用的范围不同<br>wait必须在同步代码块中使用</li><li>使用sleep不需要被唤醒，但是wait是需要notify()或者notifyAll()去唤醒的，除了wait(1000)这种形式.</li></ol><p>举例说明问题：</p><h1 id="synchronized与lock"><a href="#synchronized与lock" class="headerlink" title="synchronized与lock"></a>synchronized与lock</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized如果加在了非静态方法上，表示的是synchronized(调用方法的类的对象) {}，如果加在了静态方法上，表示的是synchronized(类.class) {}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferSynchronizedAndLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123; ticket.sale();</span><br><span class="line">            &#125; &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性、方法</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">        <span class="comment">// 卖票的方式</span></span><br><span class="line">        <span class="comment">// synchronized 本质: 队列，锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"卖出了"</span>+(number--)+<span class="string">"票,剩余:"</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210627101008598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>此处如果不对方法加synchronized修饰（不加锁）：<br><img src="https://img-blog.csdnimg.cn/20210627101419402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>Lock是一个接口，实现类有一下几个：<br><img src="https://img-blog.csdnimg.cn/20210627102346313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>先看可重入锁（ReentrantLock）：<br><img src="https://img-blog.csdnimg.cn/20210627102525603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>这里的可重入锁构造时候除非传入fair公平，否则默认为不公平锁。<br>公平锁：十分公平:可以先来后到<br>非公平锁：十分不公平:可以插队 (默认)<a href="https://blog.csdn.net/lsgqjh/article/details/63685058" target="_blank" rel="noopener">深入剖析ReentrantLock公平锁与非公平锁源码实现</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferSynchronizedAndLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123; ticket.sale();</span><br><span class="line">            &#125; &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性、方法</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 卖票的方式</span></span><br><span class="line">        <span class="comment">// synchronized 本质: 队列，锁</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"卖出了"</span>+(number--)+<span class="string">"票,剩余:"</span>+number);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized-与-lock区别"><a href="#synchronized-与-lock区别" class="headerlink" title="synchronized 与 lock区别"></a>synchronized 与 lock区别</h2><ol><li>synchronized 内置的Java关键字， Lock 是一个Java类</li><li>synchronized无法判断获取锁的状态，Lock 可以判断是否获取到了锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread提供了holdLock()方法检测当前线程是否持有锁，注意，是当前线程</span><br></pre></td></tr></table></figure></li><li>synchronized 会自动释放锁，lock 必须要手动释放锁!如果不释放锁，死锁</li><li>synchronized 线程 1(获得锁，阻塞)、线程2(只能等待);Lock锁就不一定会等待下去了，这里有个<strong>lock.tryLock()方法，尝试获取锁，可以做个判断让其尝试不到锁时不等待！！</strong></li><li>synchronized 可重入锁，不可以中断的，非公平;Lock ，可重入锁，可以 判断锁，非公平(可以在构造ReentrantLock()中自行设置boolean fair，true为公平，默认flase非公平</li><li>synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码!<h1 id="生产消费模型"><a href="#生产消费模型" class="headerlink" title="生产消费模型"></a>生产消费模型</h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 说白了就是多线程之间的通信，场景如下：有两个线程分别负责同一个资源类里变量的增加和减少，即生产与消费，对于增加和减少的逻辑：当资源中为0的时候，减少的方法就应该等待，不能再减少了；那么当资源不等于0 或者大于某个值时，增加方法就应该不再继续增加了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 具体方法总结：判断等待–&gt;业务–&gt;通知<h2 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a>synchronized实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题！  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A   B 操作同一个变量   num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210627120837300.png"  style="zoom:50%;" /></li></ol><h3 id="此处存在的问题"><a href="#此处存在的问题" class="headerlink" title="此处存在的问题"></a>此处存在的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 案例这样，如果只是两个线程通信，一个增加一个减少，必然不会出错，如果再增加几个呢？那notify之后，哪个线程来抢占呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/2021062714180563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过结果可以看出，有个值变成了2，也就是两个加法被唤醒了，且使得值均加了1。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于这里的资源类中增加和减少的方法使用的是if判断，所以也就只有一次判断，而wait之后，重新被唤醒要执行的是wait之后的语句，所以必须让他反复的判断一下值，这样才能保证线程安全！！将if改成while即可！！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if在官方文档中存在一个<strong>虚假唤醒的问题</strong><br><img src="https://img-blog.csdnimg.cn/20210627142330902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h2 id="lock锁实现"><a href="#lock锁实现" class="headerlink" title="lock锁实现"></a>lock锁实现</h2><p>Lock提供了condition.await(); 来替换等待，condition.signalAll(); 来替换唤醒全部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span></span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//condition.await(); // 等待</span></span><br><span class="line">    <span class="comment">//condition.signalAll(); // 唤醒全部</span></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务代码</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前面实现的都是随机的状态，也就是没有人为的去控制线程执行顺序，<strong>Condition可以精准的通知和唤醒！！</strong><br>这里提供一个场景：<strong>A 执行完调用B，B执行完调用C，C执行完调用A</strong>！！<br>这里如果num为1时，让A执行，num=2–&gt;B, num=3–&gt;C</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data3 data = <span class="keyword">new</span> Data3();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span></span>&#123; <span class="comment">// 资源类 Lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>; <span class="comment">// 1A  2B  3C</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;AAAAAAA"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，B</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;BBBBBBBBB"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，c</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;BBBBBBBBB"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，c</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210627144412929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70#pic_center =200x400"  style="zoom:50%;" /><p>输出结果即：A执行完通知B执行，B执行完通知C……..</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h2><p>多线程操作共享资源，存在同时对资源的读写 ，会导致资源的原子性遭到不一致处理 </p><p>需要锁操作来控制多个线程对象资源操作的原子性（安全性）</p><h2 id="锁的工作模式："><a href="#锁的工作模式：" class="headerlink" title="锁的工作模式："></a>锁的工作模式：</h2><p> 对于一个共享资源，我们有 lock 与 unlock 两个原子操作 </p><p>在一个线程对于一个资源进行操作的时候，实行lock 操作 ，这个时候其他线程就不能再操作这个资源对象了进入阻塞状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">有两个资源对象</span></span><br><span class="line"><span class="comment">一个是碗  一个是米饭</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有两个线程  T1  T2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">T1 拿了一个碗 想去盛饭 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">T2 拿了一份米饭  想拿这个碗来装</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">T1 可以拿到饭吗？ 不能 </span></span><br><span class="line"><span class="comment">T2 可以拿到碗吗？ 不能</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">package</span> com.thread0622;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str1 = <span class="string">"米饭"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str2 = <span class="string">"碗"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程1 持有米饭的监视器锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 持有 "</span> + str1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 想持有 "</span> + str2);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T1 End...."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 持有 "</span> + str2);</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁 的情况下想获取 米饭的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 想持有 "</span> + str1);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T2 End...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决死锁的办法"><a href="#解决死锁的办法" class="headerlink" title="解决死锁的办法"></a>解决死锁的办法</h1><p>1、在申请一个对象资源锁的时候  加入一个时间判断，释放手头所有的资源锁 </p><p>2、写代码时候，尽量避免这种情况的写法 ，嵌套资源锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread0622;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str1 = <span class="string">"米饭"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str2 = <span class="string">"碗"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程1 持有米饭的监视器锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 持有 "</span> + str1);</span><br><span class="line">&#125;<span class="comment">// 使用完一个资源之后就立即释放锁 </span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 想持有 "</span> + str2);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T1 End...."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 持有 "</span> + str2);</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁 的情况下想获取 米饭的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 想持有 "</span> + str1);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T2 End...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、finally 关键字  能够保证 finally 块中的代码   执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;wait与sleep&quot;&gt;&lt;a href=&quot;#wait与sleep&quot; class=&quot;headerlink&quot; title=&quot;wait与sleep&quot;&gt;&lt;/a&gt;wait与sleep&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;来自不同的类&lt;br&gt;首先，wait和sleep都不是一个类下的方</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="https://ericzikun.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Springboot项目docker部署配置文件外挂载</title>
    <link href="https://ericzikun.github.io/2021/06/26/Springboot%E9%A1%B9%E7%9B%AEdocker%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%96%E6%8C%82%E8%BD%BD/"/>
    <id>https://ericzikun.github.io/2021/06/26/Springboot%E9%A1%B9%E7%9B%AEdocker%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%96%E6%8C%82%E8%BD%BD/</id>
    <published>2021-06-26T13:49:57.000Z</published>
    <updated>2021-06-26T13:53:27.106Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 利用docker对一个Springboot打包时会遇到要及时更改相关数据库或者外部接口的ip及port，如果每次都进到容器内部修改，那一定非常麻烦，这里我想到了两种解决方案，并最终使用了后者。两种方法类似，无论哪种，都必须经过外挂载的步骤，也就是要把配置文件放到一个和宿主机映射的目录下：如图，这里采用的是docker-compose.yaml容器编排方式，不赘述：<br><img src="https://img-blog.csdnimg.cn/20210626214430420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将配置文件放在宿主机目录的config下，代码中写到“/usr/app_file/config/config/json”即可被容器访问到!</p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p>容器内运行jar包的CMD采用指定外部application.yml的命令：<br>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup jdk1<span class="number">.8</span><span class="number">.0_131</span>/bin/java -jar -Dspring.config.location=tmp/springboottmp/xxx.yaml tmp/service.jar --spring.profiles.active=test &gt; logs/xxxlog.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h2><p>不使用application.yml，用最原始的方式读取一个json文件的键值对，并替换代码变量即可,在Springboot config下定义一个JsonConfig类即可，代码简单，关键是要把地址写到容器内的与宿主机映射的<strong>外挂载目录下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String json_file = <span class="string">"/usr/app_file/config/es.json"</span>;</span><br><span class="line">        JSONObject configJ = <span class="keyword">this</span>.readJsonFile(json_file);</span><br><span class="line">        <span class="keyword">if</span>(configJ.containsKey(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> configJ.getString(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">readJsonFile</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        String readJson = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">            InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(fileInputStream, <span class="string">"UTF-8"</span>);</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">            String tempString = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((tempString = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                readJson += tempString;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="comment">// 获取json</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jsonObject = JSONObject.parseObject(readJson);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JSONException e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 利用docker对一个Springboot打包时会遇到要及时更改相关数据库或者外部接口的ip及port，如果每次都进到容器内部修改，那一定非常麻烦，这里我想到了两种解决方案，并最终使用了后</summary>
      
    
    
    
    <category term="技术栈" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="Springboot" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/Springboot/"/>
    
    
    <category term="Springboot" scheme="https://ericzikun.github.io/tags/Springboot/"/>
    
    <category term="Docker" scheme="https://ericzikun.github.io/tags/Docker/"/>
    
    <category term="JSON" scheme="https://ericzikun.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Websocket通信实战</title>
    <link href="https://ericzikun.github.io/2021/06/26/Websocket%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98/"/>
    <id>https://ericzikun.github.io/2021/06/26/Websocket%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98/</id>
    <published>2021-06-26T07:35:32.000Z</published>
    <updated>2021-06-26T07:39:04.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最近给实验室做的个系统需要用docker打包到对方服务器上，并提供多个URL页面以及接口，需求是要将提供的URL页面通过Iframe方式集成到他们的系统去，他们向我们的后端接口发送数据请求，渲染结果到我们的URL页面上，不了解WebSocket前把我难住了，我想到了设置时间间隔 不断向后端请求 也可以解决问题，但是并不优雅，请求数据过大时，时间间隔也不好设定。直到实验室李师兄通过WebSocket技术给我做了示范，原来前后端Http通信除了Ajax之外 还有WebSocket这种客户端和服务端的双向长连接通信。</p><h1 id="WebSocket与Ajax轮询"><a href="#WebSocket与Ajax轮询" class="headerlink" title="WebSocket与Ajax轮询"></a>WebSocket与Ajax轮询</h1><p><img src="https://img-blog.csdnimg.cn/20210626152619628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WebSocket  允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器<strong>只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的<strong>带宽等资源。</strong></p><p>HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><h1 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> websocket = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'WebSocket'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    <span class="comment">// websocket = new WebSocket("ws://localhost:8081/acl/websocket");</span></span><br><span class="line">    websocket = <span class="keyword">new</span> WebSocket(finalurlip);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">"浏览器不支持websocket，请更换浏览器！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接发生错误的回调方法</span></span><br><span class="line">websocket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setMessageInnerHTML(<span class="string">"建立websocket连接出错！"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接成功建立的回调方法</span></span><br><span class="line">websocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//setMessageInnerHTML("open");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收到消息的回调方法</span></span><br><span class="line"><span class="comment">//消息內包含桑基图数据</span></span><br><span class="line">websocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">    data = <span class="built_in">JSON</span>.parse(msg.data);</span><br><span class="line">    <span class="keyword">var</span> nodes = <span class="built_in">JSON</span>.parse(data.nodes);</span><br><span class="line">    <span class="keyword">var</span> links = <span class="built_in">JSON</span>.parse(data.links);</span><br><span class="line">    <span class="built_in">console</span>.log(nodes);</span><br><span class="line">    <span class="built_in">console</span>.log(links);</span><br><span class="line">    <span class="keyword">var</span> sankeyData = &#123;&#125;;</span><br><span class="line">    sankeyData[<span class="string">"nodes"</span>] = nodes;</span><br><span class="line">    sankeyData[<span class="string">"links"</span>] = links;</span><br><span class="line">    vm2.sankeyData = sankeyData;</span><br><span class="line">    <span class="built_in">console</span>.log(vm2.sankeyData);</span><br><span class="line">    vm2.setTopicSankey_2(<span class="number">1</span>,<span class="string">"acl"</span>,<span class="string">"数据演化图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接关闭的回调方法</span></span><br><span class="line">websocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setMessageInnerHTML(<span class="string">"websocket连接关闭！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    websocket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息显示在网页上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMessageInnerHTML</span>(<span class="params">innerHTML</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//alert(innerHTML);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    websocket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span><br><span class="line">    websocket.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后端Java代码"><a href="#后端Java代码" class="headerlink" title="后端Java代码"></a>后端Java代码</h1><h2 id="WebSocketConfig"><a href="#WebSocketConfig" class="headerlink" title="WebSocketConfig"></a>WebSocketConfig</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.irlab.agriculture.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入WebSocket Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocketServer"><a href="#WebSocketServer" class="headerlink" title="WebSocketServer"></a>WebSocketServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.irlab.agriculture.service.acl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.irlab.agriculture.controller.ACLController;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/acl/websocket"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WebSocketServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前在线链接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger onlineCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放每个客户端对应的mywebsocket对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketServers = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与某个客户端的链接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sid = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接建立成功的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        onlineCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        sid = session.getId();</span><br><span class="line">        webSocketServers.add(<span class="keyword">this</span>);</span><br><span class="line">        logger.info(<span class="string">"有新窗口开始监听:&#123;&#125;,当前在线人数为&#123;&#125;"</span>,session.getId(),webSocketServers.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接关闭的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        onlineCount.decrementAndGet();</span><br><span class="line">        webSocketServers.remove(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        logger.info(<span class="string">"有窗口关闭,当前在线人数为&#123;&#125;"</span>,webSocketServers.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message,Session session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        logger.info(<span class="string">"收到来自窗口：&#123;&#125;的信息：&#123;&#125;"</span>,sid,message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session,Throwable error)</span></span>&#123;</span><br><span class="line">        logger.error(<span class="string">"websocket发生错误："</span>,error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器主动推送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器群发消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendInfoToMany</span><span class="params">(String info)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">            logger.info(<span class="string">"推送消息到多个窗口"</span>);</span><br><span class="line">            <span class="keyword">if</span>(webSocketServers.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                logger.error(<span class="string">"没有注册的窗口！"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(WebSocketServer item:webSocketServers)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    item.sendMessage(info);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; <span class="title">getWebSocketServers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSocketServers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 最近给实验室做的个系统需要用docker打包到对方服务</summary>
      
    
    
    
    <category term="技术栈" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="Springboot" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/Springboot/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="WebSocket" scheme="https://ericzikun.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>实验室学姐问到可见性细节，被批浮于表面【可见性的原理初探】</title>
    <link href="https://ericzikun.github.io/2021/06/13/Deep4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>https://ericzikun.github.io/2021/06/13/Deep4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/</id>
    <published>2021-06-13T12:32:33.000Z</published>
    <updated>2021-06-26T07:36:25.763Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 之前也只是知道有可见性这么回事，但是原理不算很明白！今天把多线程的可见性原理梳理一下，原理弄懂，而非死记硬背！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先看多线程例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 启动线程</span></span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.主线程继续</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (MyThread.a ==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"主线程读到了a=1"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程启动，休息2s..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"将a的值改为1"</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210613191915845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里启动了一个MyThread线程，并在主线程里面不断的去判断该成员变量a的值是否进行了修改，而实际情况是MyThread线程对值修改之后，主线程中并没有拿到这个最新的值而跳出while循环，那么这又是为啥呢？<br><img src="https://img-blog.csdnimg.cn/20210613192254802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一个线程启动后，会单独建立一个栈供使用，那么这里就有主线程和新线程两个栈，启动线程后，栈内调用的成员变量、成员方法这些都是从同一个方法区中获取的，比如这里的MyThread.class静态区，拿到的都是方法区中的副本存到自己线程的栈内存当中，所以这个值就应该是线程启动当时的副本状态！只要不修改这个副本文件，就会一直使用这个副本，也不会重新去方法区拿。<br>当修改了副本后，他会立刻同步到方法区中，比如这里的新线程修改使得a=1，那么就会立刻去改方法区中MyThread.class静态区a的值为1，那么这个新线程今后用的值都是这个修改后的副本了，但是对于主线程，它拿到的一直是a修改之前的最开始的那个副本文件，所以对于主线程来说a=0。</p><blockquote><p><strong>总结1：</strong> 每个线程去使用共享内容时候，是把共享的内容复制一份副本到自己的栈内存<br><strong>总结2：</strong> 副本中的值发生改变时，立刻同步到方法区中<br><strong>总结3：</strong> 如果当前线程没有重新从方法区中拷贝副本，那么使用的资源还是上一次拿到的副本文件</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么，如何让主线程也拿到最新修改的方法区呢？也就是说如何再次获取一个最新的副本呢？有以下几个方法：</p><ol><li>让主线程<strong>sleep</strong>一下，那么线程休眠后再启动则会重新复制资源副本到主线程栈内存中。</li><li>给成员变量a设置<strong>volatile</strong>修饰符，保证其可见性！</li><li>使用<strong>同步代码块synchronized</strong>：只要遇到<strong>同步</strong>，那么线程也会重新去方法区拿最新的资源副本</li></ol><p>方法一：让主线程sleep而重新获取资源副本到栈内存当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 启动线程</span></span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.主线程继续</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (MyThread.a ==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"主线程读到了a=1"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程启动，休息2s..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"将a的值改为1"</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210613201001340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>方法二：使用volatile，直接给a变量加即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>方法三：使用同步代码块 synchronized，这里随便对什么加锁都行，都会重新向方法区请求最新资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 启动线程</span></span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.主线程继续</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//            Thread.sleep(1);</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Demo<span class="class">.<span class="keyword">class</span>) </span>&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (MyThread.a ==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"主线程读到了a=1"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程启动，休息2s..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"将a的值改为1"</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 之前也只是知道有可见性这么回事，但是原理不算很明白！今天把多线程的可见性原理梳理一下，原理弄懂，而非死记硬背！&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="https://ericzikun.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
    <category term="可见性" scheme="https://ericzikun.github.io/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>对多线程稍作整理【多线程】</title>
    <link href="https://ericzikun.github.io/2021/06/11/Deep3-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://ericzikun.github.io/2021/06/11/Deep3-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-06-11T03:11:09.000Z</published>
    <updated>2021-06-29T05:58:55.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><ul><li><p>并发:指两个或多个事件在同一个时间段内发生。</p></li><li><p>并行:指两个或多个事件在同一时刻发生(同时发生)。</p></li></ul><p>注意辨析宏观与微观的理解</p><p><img src="https://img-blog.csdnimg.cn/20210611124507184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="&lt;img src=&quot;多线程笔记.assets/image-20210605152309555.png&quot; alt=&quot;image-20210605152309555&quot; style=&quot;zoom:50%;&quot; /&gt;"></p><p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有<strong>多个程序</strong>同时运行，这在单 CPU 系统中，每 一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分 时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上(CPU)，实现多任务并行执行， 即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><blockquote><p>注意:单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个 线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><ul><li><p>进程:是指一个内存中运行的应用程序（比如打开一个软件 至少占用1个进程），每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程;进程也是程序的一次执行过程，是系统运行程序的基本单位;系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p>线程:线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p></li></ul><p><strong>简而言之:一个程序运行后至少有一个进程，一个进程中可以包含多个线程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">线程：CPU 可执行的最小任务单元 </span><br><span class="line"></span><br><span class="line">八核CPU -八核16线程  </span><br><span class="line">单核 单线程 CPU </span><br><span class="line"></span><br><span class="line">线程 让程序节省时间，提高效率</span><br><span class="line">多线程的CPU 可以看作可以并行运算的机器 </span><br><span class="line"></span><br><span class="line">单线程 - - 交替运行  不能节省时间提高效率</span><br><span class="line"> --同时运行的效果 </span><br><span class="line">CPU 运算速度特别快 </span><br><span class="line">在两个线程之间实现快速切换执行 </span><br><span class="line"></span><br><span class="line">进程：线程的老大 -- 程序运行</span><br></pre></td></tr></table></figure><h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度:"></a>线程调度:</h1><h2 id="分时调度"><a href="#分时调度" class="headerlink" title="分时调度"></a>分时调度</h2><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为 <strong>抢占式调度</strong>。</p><ul><li><p>设置线程的优先级</p></li><li><p>抢占式调度详解</p><p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如:现在我们一边使用编辑器，一边使用腾讯会议软件，同时还开着qq、微信、IDEA等软件。此时，这些程序是 在同时运行，”<strong>感觉这些软件好像在同一时刻运行着“</strong>。</p><p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着<strong>高速的切换</strong>。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，<strong>让CPU的使用率更高</strong>。</p></li></ul><h1 id="Java实现线程的三个方法："><a href="#Java实现线程的三个方法：" class="headerlink" title="Java实现线程的三个方法："></a>Java实现线程的三个方法：</h1><h2 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、创建一个类 继承 Thread </span><br><span class="line">2、重写run方法</span><br><span class="line">3、此类创建对象调用 start()方法</span><br><span class="line">每个线程对象都只能启动一次</span><br></pre></td></tr></table></figure><h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><pre><code>1、创建一个类  implements Runnable接口 2、重写run方法3、此类创建对象 交给Thread类对象调用 start()方法4、此类创建对象 交给线程池 调用 start()方法    每个线程对象都可以被Thread类对象重复启动         更轻量 方便 </code></pre><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、创建一个类  implements Callable接口 </span><br><span class="line">2、重写call方法</span><br><span class="line">3、此类创建对象 交给线程池 调用 start()方法</span><br><span class="line">可以带有返回值</span><br></pre></td></tr></table></figure><p>三个方法之间的区别，优缺点：</p><table><thead><tr><th>&lt;!– 特点</th><th>Thread</th><th>Runnable</th><th>Callable</th></tr></thead><tbody><tr><td>优点</td><td>方便实现，代码简单</td><td>每个线程对象都可以被Thread类对象重复启动。<br/>实现接口，线程类就还能继承其它类，线程之间资源共享方便，不用加static进行修饰</td><td>实现接口，线程类就还能继承其它类,线程之间资源共享方便，不用加static进行修饰,线程可以有返回值,线程可以抛出异常</td></tr><tr><td>缺点</td><td>每个线程对象都只能启动一次 <br/>必须重写run方法run，方法不能有返回值，run方法不能抛出异常</td><td>必须重写run方法,run方法不能有返回值,run方法不能抛出异常</td><td>线程创建比较麻烦，代码比较复杂 –&gt;</td></tr></tbody></table><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611150520309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70) --><h1 id="线程状态："><a href="#线程状态：" class="headerlink" title="线程状态："></a>线程状态：</h1><p>一共有T1、T2、T3三个时间段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动 T1</span><br><span class="line"></span><br><span class="line">运行 </span><br><span class="line">等待消耗小T2</span><br><span class="line">计时等待</span><br><span class="line"></span><br><span class="line">终止 T3</span><br></pre></td></tr></table></figure><p>线程池：–  减少 T1 T3 所占的时间和资源<br><img src="https://img-blog.csdnimg.cn/2021061113283062.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和<strong>预期</strong>的是一样的，就是<strong>线程安全的</strong>。<br>这里以小球绘制为例：<br>背景：给画板添加点击事件，点击一次画板屏幕则创建一个小球线程<br>不加锁的情况下：<br>面板绘制主函数：<br>给画板添加点击事件ballLiten</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BallUI</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</span><br><span class="line"></span><br><span class="line">BallUI()&#123;</span><br><span class="line">setTitle(<span class="string">"运动小球"</span>);</span><br><span class="line">setSize(<span class="number">600</span>,<span class="number">600</span>);</span><br><span class="line">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">setVisible(<span class="keyword">true</span>);</span><br><span class="line">Graphics g = getGraphics();<span class="comment">// 获取画笔对象</span></span><br><span class="line">BallListener ballLiten =<span class="keyword">new</span> BallListener(g);</span><br><span class="line">addMouseListener(ballLiten);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> BallUI();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写点击方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BallListener</span> <span class="keyword">implements</span> <span class="title">MouseListener</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 点击一次 创建一个球 运动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Graphics g;</span><br><span class="line"></span><br><span class="line">BallListener(Graphics g)&#123;</span><br><span class="line"><span class="keyword">this</span>.g = g;</span><br><span class="line">&#125;</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseClicked</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">Color color = <span class="keyword">new</span> Color(random.nextInt(Integer.MAX_VALUE/<span class="number">200</span>));</span><br><span class="line">DrawBallThread dbt = <span class="keyword">new</span> DrawBallThread(g, e.getX(), e.getY(), <span class="number">30</span>,color);</span><br><span class="line">dbt.num=<span class="number">0</span>;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(dbt);</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制运动的小球线程类(不加锁)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * implements Runnable每个线程 实际运行的内容是独立的</span></span><br><span class="line"><span class="comment"> * 成员属性是共享的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawBallThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">Graphics g;<span class="comment">// 保证可见</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">50</span>;</span><br><span class="line">Color color = Color.RED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DrawBallThread</span><span class="params">(Graphics g, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> size, Color color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.g = g;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> speedX=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> copynum = num;</span><br><span class="line"><span class="comment">//Random ran = new Random();</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//-------------------------不加锁的情况下--------------------</span></span><br><span class="line"><span class="comment">//g.setColor(new Color(238,238,238)); //灰色 先画背景 相当于清屏</span></span><br><span class="line"><span class="comment">//g.fillOval(x, y, size, size);</span></span><br><span class="line"><span class="keyword">if</span> (copynum ** <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;<span class="number">500</span>) &#123;</span><br><span class="line">speedX =-speedX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y&lt;<span class="number">0</span>||y&gt;<span class="number">500</span>) &#123;</span><br><span class="line">speedX =-speedX;</span><br><span class="line">&#125;</span><br><span class="line">x += speedX;</span><br><span class="line">y += speedX;</span><br><span class="line">&#125;</span><br><span class="line">g.setColor(color);</span><br><span class="line">g.fillOval(x, y, size, size);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">30</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210611135324644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p><strong>分析</strong>：<br>由图可见，在线程执行的方法中由于每个点击事件触发的线程拿到的都是同一个Graphics g对象，在一个线程启动后不久，另外点击而新开的线程拿到的仍然是同一个Graphics g对象，这里的Graphics g对象属于共享变量，它的color属性也是在不断变化的！从而导致各个线程之间的球颜色混乱！如果要解决此问题，则要将线程执行方法中的<strong>Graphics g对象这个共享变量加锁，保证它在当前线程运行结束的情况下才可被其他线程所调用</strong>，如下为加锁情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * implements Runnable每个线程 实际运行的内容是独立的</span></span><br><span class="line"><span class="comment"> * 成员属性是共享的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawBallThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">Graphics g;<span class="comment">// 保证可见</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">50</span>;</span><br><span class="line">Color color = Color.RED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DrawBallThread</span><span class="params">(Graphics g, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> size, Color color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.g = g;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> speedX=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> copynum = num;</span><br><span class="line"><span class="comment">//Random ran = new Random();</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//-------------------------加锁的情况下-------------------- synchronized (g) &#123;</span></span><br><span class="line"><span class="comment">//g.setColor(new Color(238,238,238)); //灰色 先画背景 相当于清屏</span></span><br><span class="line"><span class="comment">//g.fillOval(x, y, size, size);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">if</span> (copynum ** <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;<span class="number">500</span>) &#123;</span><br><span class="line">speedX =-speedX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y&lt;<span class="number">0</span>||y&gt;<span class="number">500</span>) &#123;</span><br><span class="line">speedX =-speedX;</span><br><span class="line">&#125;</span><br><span class="line">x += speedX;</span><br><span class="line">y += speedX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (g) &#123;</span><br><span class="line"><span class="comment">//g.setColor(Color.white);</span></span><br><span class="line"><span class="comment">//g.fillRect(0, 0, 500, 500);</span></span><br><span class="line"></span><br><span class="line">g.setColor(color);</span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 300; i++) &#123;</span></span><br><span class="line"><span class="comment">//g.fillOval(x, y, size, size);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">g.fillOval(x, y, size, size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">30</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210611135114185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>小结：<br>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量<strong>只有读操作，而无写</strong>操作，一般来说，这个全局变量是<strong>线程安全</strong>的;若有<strong>多个线程同时执行写</strong>操作，一般都需要考虑<strong>线程同步</strong>， 否则的话就可能影响线程安全。</p><h3 id="同步代码块、锁"><a href="#同步代码块、锁" class="headerlink" title="同步代码块、锁"></a>同步代码块、锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前面先引出了小球的案例，已对锁有了初步了解，现在详细介绍一下同步代码块、锁：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要解决上述多线程并发访问一个资源的安全性问题，Java中提供了同步机制 (synchronized)来解决。</p><p><strong>同步代码块</strong>: synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。<br>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">synchronized</span>(同步锁)&#123; 需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步锁: 对象的同步锁只是一个概念,可以想象为在对象上<strong>标记了一个锁</strong>。</p><ol><li><strong>锁对象</strong> 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。<blockquote><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 (BLOCKED)。</p></blockquote></li></ol><p><strong>同步方法</strong>: 使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外<br>等着。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123; 可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lock锁</strong>：<code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,<br>同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> :加同步锁。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> :释放同步锁。</span></span><br></pre></td></tr></table></figure><p>举例：<br>在线程执行方法的前后<strong>执行锁对象的lock、unlock</strong>方法达到加锁和释放锁的目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行卖票操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//每个窗口卖票的操作 //窗口 永远开启 while(true)&#123;</span></span><br><span class="line">lock.lock(); </span><br><span class="line"><span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line"><span class="comment">//出票操作 //使用sleep模拟一下出票时间 try &#123;</span></span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">e.printStackTrace(); &#125;</span><br><span class="line"><span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">String name = Thread.currentThread().getName(); </span><br><span class="line">System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">&#125;</span><br><span class="line">lock.unlock(); </span><br><span class="line">&#125;</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p>几个安全相关的概念普及：</p><p><strong>原子性</strong>：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</p><p><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<strong>常采用volatile</strong>去修饰变量，能够保证各个线程的一致可见性，也就是当一个线程修改了变量值后，别的线程能够看到</p><p><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。</p><pre><code>num=1;  -- 1 num++  2 num++  数据安全不能保证 volatile    -- 一致可见性 不能保证线程数据安全synchronized -- 重量级锁 性能优秀 -- 不方便 -- 实现锁机制 --  保证原子性 final 原子操作：载入 堆中共享变量  写回变量  lock unlock     保证数据原子性的操作：        一个个来    文件操作：        读 写     所有线程 只读 -- 共享     线程 一个读   一个写 -- 必须实现 锁 排队     所有线程  写 写 - 必须实现 锁        JUC     ArrayList -- 增删查改 -- 原子操作的是：增删改 Redis -- 单线程 方法 ：分别对哪些资源对象进行加锁     方法中使用的变量     方法所在类的对象 </code></pre><p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;headerlink&quot; title=&quot;并发与并行&quot;&gt;&lt;/a&gt;并发与并行&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;并发:指两个或多个事件在同一个时间段内发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并行:指两个或多个</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="https://ericzikun.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>二维码也不过如此嘛，手写二维码玩一下【计算机基础：二进制+字节+移位运算】</title>
    <link href="https://ericzikun.github.io/2021/06/09/Deep5-%E6%89%8B%E5%86%99%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>https://ericzikun.github.io/2021/06/09/Deep5-%E6%89%8B%E5%86%99%E4%BA%8C%E7%BB%B4%E7%A0%81/</id>
    <published>2021-06-09T10:11:01.000Z</published>
    <updated>2021-06-26T07:35:54.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实二维码就是由URL字符串转换得到的，那么手写一个最简单的字符与图像的转换如何实现呢？下面请看</p><h2 id="字符串转二维码"><a href="#字符串转二维码" class="headerlink" title="字符串转二维码"></a>字符串转二维码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryString</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">setTitle(<span class="string">"二维码"</span>);</span><br><span class="line">setSize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.paint(g);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] binaryArray = stringToBinaryArray(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">int</span>[][] imgdata = <span class="keyword">new</span> <span class="keyword">int</span>[binaryArray.length/<span class="number">16</span>][<span class="number">16</span>]; <span class="comment">//</span></span><br><span class="line">BufferedImage buffimg = <span class="keyword">new</span> BufferedImage(<span class="number">160</span>,(binaryArray.length/<span class="number">16</span>)*<span class="number">10</span>,BufferedImage.TYPE_INT_ARGB);</span><br><span class="line">Graphics g2 = buffimg.getGraphics();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgdata.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgdata[i].length; j++) &#123;</span><br><span class="line">imgdata[i][j] = binaryArray[i*<span class="number">16</span>+j];</span><br><span class="line"><span class="keyword">if</span>(imgdata[i][j]==<span class="number">48</span>) &#123;</span><br><span class="line">g2.setColor(Color.white);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">g2.setColor(Color.black);</span><br><span class="line">&#125;</span><br><span class="line">g2.fillRect(j*<span class="number">10</span>, i*<span class="number">10</span>,<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">g.drawImage(buffimg, <span class="number">100</span>, <span class="number">100</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] stringToBinaryArray(String srcStr) &#123;</span><br><span class="line">String link = <span class="string">"http://www.bilibili.com 天气不错"</span>; <span class="comment">//28个字符</span></span><br><span class="line"><span class="comment">//String link = "http://www.baidu.com 天气"; //28个字符</span></span><br><span class="line"><span class="comment">// 二进制 Str -&gt; 二进制码</span></span><br><span class="line"><span class="comment">// 转成char</span></span><br><span class="line"><span class="keyword">int</span> strLength = link.length();</span><br><span class="line"><span class="keyword">int</span>[] binaryData = <span class="keyword">new</span> <span class="keyword">int</span>[strLength * <span class="number">16</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLength; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c = link.charAt(i);</span><br><span class="line"></span><br><span class="line">String binaryStr = Integer.toBinaryString(c);</span><br><span class="line">System.out.println(<span class="string">"------缺码------"</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(binaryStr);<span class="comment">// 缺码</span></span><br><span class="line"><span class="comment">// 补码：在前补 0</span></span><br><span class="line"><span class="keyword">int</span> binaryStrLength = binaryStr.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (binaryStrLength &lt; <span class="number">16</span>) &#123;</span><br><span class="line">binaryStr = <span class="string">"0"</span> + binaryStr;</span><br><span class="line">binaryStrLength++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"------全码------"</span>);</span><br><span class="line">System.out.println(binaryStr);<span class="comment">// 全码</span></span><br><span class="line">System.out.println(<span class="string">"--存入binaryData--"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">System.out.println(binaryStr.charAt(j));</span><br><span class="line">binaryData[i * <span class="number">16</span> + j] = binaryStr.charAt(j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"------binaryData-------"</span>);</span><br><span class="line">System.out.println(binaryData);</span><br><span class="line">System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryData.length; i++) &#123;</span><br><span class="line">System.out.print(binaryData[i]);</span><br><span class="line">System.out.print(<span class="string">" "</span>);</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">16</span>) &#123;</span><br><span class="line">System.out.println();</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> binaryData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>BinaryString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20210613223458780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70#pic_center" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20210613223458780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70#pic_center</a> =200x400)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里输入的字符串为：”<a href="http://www.bilibili.com" target="_blank" rel="noopener">http://www.bilibili.com</a> 天气不错“，由图可以清晰看出由于是16位，那么前面字母部分的二进制则均为0，只有后面才有黑色的1，英文字母只占满了后8位，而最后四个中文字符，才有16位进行二进制编码，占满了全部16位，不懂为啥英文占8位，中文得16位的请看另一篇讲字符串二进制的文章 <a href="https://blog.csdn.net/popofzk/article/details/117712441?spm=1001.2014.3001.5501" target="_blank" rel="noopener">计算机基础：二进制+字节+移位运算</a></p><h2 id="二维码转字符串"><a href="#二维码转字符串" class="headerlink" title="二维码转字符串"></a>二维码转字符串</h2><p>大致思路：</p><ol><li>读取到二维码图片，用数组存储rgb像素值，再把黑白色转成0、1二进制</li><li>每一个字符得到整理成一个二进制字符串（16位）。</li><li>再把二进制字符串转String字符串（二进制字符串先转十进制数字，十进制再转字符串）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code2String</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public String picPath;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setH</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setW</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] getImagePix(String picPath)&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(picPath);</span><br><span class="line">        BufferedImage img = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            img = ImageIO.read(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> w = img.getWidth();</span><br><span class="line">        <span class="keyword">int</span> h = img.getHeight();</span><br><span class="line">        setH(h);</span><br><span class="line">        setW(w);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"图片宽度为："</span>+ w+ <span class="string">" 图片长度为："</span>+h</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span>[][] imgArr = <span class="keyword">new</span> <span class="keyword">int</span> [h][w];</span><br><span class="line">        System.out.println(<span class="string">"---------imgArr----length"</span>);</span><br><span class="line">        System.out.println(imgArr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgArr[i].length; j++) &#123;</span><br><span class="line">                imgArr[i][j] =img.getRGB(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> imgArr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">binaryToString</span><span class="params">(ArrayList&lt;String&gt; binaryStringList)</span></span>&#123;</span><br><span class="line">        String resultString = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryStringList.size(); i++) &#123;</span><br><span class="line">            String binaryString = binaryStringList.get(i);</span><br><span class="line"><span class="comment">//            System.out.println("------二进制转十进制数字------");</span></span><br><span class="line">            <span class="keyword">int</span> binaryInt=Integer.parseInt(binaryString, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> [] arrayS = &#123;binaryInt&#125;;</span><br><span class="line"><span class="comment">//            System.out.println("------十进制转字符串-------");</span></span><br><span class="line">            String s = <span class="keyword">new</span> String(arrayS,<span class="number">0</span>,arrayS.length);</span><br><span class="line">            resultString += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">codeParsing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [][] imgArr = getImagePix(<span class="string">"img/pic1.png"</span>);</span><br><span class="line">        <span class="keyword">int</span> zoom = Math.round((<span class="keyword">float</span>)w/<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> [][] binaryArr = <span class="keyword">new</span> <span class="keyword">int</span>[h/zoom][<span class="number">16</span>]; <span class="comment">//28x16</span></span><br><span class="line">        System.out.println(<span class="string">"---zoom---"</span>);</span><br><span class="line">        System.out.println(zoom);</span><br><span class="line">        System.out.println(<span class="string">"---------binaryArr.length---------"</span>);</span><br><span class="line">        System.out.println(binaryArr.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryArr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; binaryArr[i].length; j++) &#123;</span><br><span class="line"><span class="comment">//                System.out.println("---------binaryArr[i].length--------");</span></span><br><span class="line"><span class="comment">//                System.out.println(binaryArr[i].length);</span></span><br><span class="line"><span class="comment">//                System.out.println("第" + i + " 第"+j);</span></span><br><span class="line"><span class="comment">//                System.out.println(j);</span></span><br><span class="line"><span class="comment">//                System.out.println("---------imgArr[i*zoom][j*zoom]---------");</span></span><br><span class="line"><span class="comment">//                System.out.println(imgArr[i*zoom][j*zoom]);</span></span><br><span class="line">                <span class="keyword">int</span> rgbValue = imgArr[i*zoom][j*zoom];</span><br><span class="line">                <span class="keyword">int</span> red,green,blue;</span><br><span class="line">                red = rgbValue &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">                green = rgbValue &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">                blue = rgbValue &gt;&gt; <span class="number">0</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">                <span class="keyword">int</span> gray = (red + green + blue) / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (gray == <span class="number">0</span>)&#123;<span class="comment">//黑色</span></span><br><span class="line">                    binaryArr[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    binaryArr[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                System.out.println("存入的值"+ gray);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"--------------binaryArr二进制字符串-------------"</span>);</span><br><span class="line">        ArrayList&lt;String&gt; binaryStringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryArr.length; i++) &#123;</span><br><span class="line">            String curString = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; binaryArr[i].length; j++) &#123;</span><br><span class="line">                System.out.print(binaryArr[i][j]);</span><br><span class="line">                curString += binaryArr[i][j];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            binaryStringList.add(curString);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------二进制字符串转String字符串-----------"</span>);</span><br><span class="line">        String binaryToString = binaryToString(binaryStringList);</span><br><span class="line">        System.out.println(binaryToString);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Code2String code2String = <span class="keyword">new</span> Code2String();</span><br><span class="line">        code2String.codeParsing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 其实二维码就是由URL字符串转换得到的，那么手写一个最</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="计算机基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://ericzikun.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="程序是怎样跑起来的" scheme="https://ericzikun.github.io/tags/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    
    <category term="二进制" scheme="https://ericzikun.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="字节" scheme="https://ericzikun.github.io/tags/%E5%AD%97%E8%8A%82/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>原码、补码，字符串的底层存储都不懂，还敢说学过计算机？【计算机基础：二进制+字节+移位运算】</title>
    <link href="https://ericzikun.github.io/2021/06/08/Deep2%EF%BC%9A%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6+%E5%AD%97%E8%8A%82+%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%91/"/>
    <id>https://ericzikun.github.io/2021/06/08/Deep2%EF%BC%9A%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6+%E5%AD%97%E8%8A%82+%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%91/</id>
    <published>2021-06-08T10:11:01.000Z</published>
    <updated>2021-06-29T05:57:51.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>提到二进制，为啥计算机底层数据存储都采用二进制呢？计算机内部事由IC电子部件构成，IC的一个引脚，只能表示两个状态（《程序是怎样跑起来的》第二章）</p><img src="https://img-blog.csdnimg.cn/20210608182649936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h1 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h1><p>二进制的数一般是8位、16、32，8位的二进制数被称为一个字节，字节是最基本的信息计量单位，而位是最小单位，字节是基本单位，内存和磁盘都是用字节来储存和读写数据，使用位单位则无法读写数据，因此，字节是基本单位</p><h2 id="位bit"><a href="#位bit" class="headerlink" title="位bit"></a>位bit</h2><p>bit位:位是==计算机存储的最小单位==简称为b也称为比特(bit)例如1b,2b,3b<br>byte字节:byte字节是计算机用于计量存储容量的,一种计量单位<br>1byte= 8bit<br>1byte =1B<br>1byte=存1个字母<br>2byte=存一个汉字</p><p>32位和62位系统有什么区别：</p><ol><li>处理数据能力不同：64位的一次可以处理64位的数据，向下兼容，比如32位 16位</li><li>支持的内存不同，或者说寻址能力不同：32位的最多支持4gb的内存，而64最多支持上百g的内存</li><li>架构不同</li><li>对配置要求不同，32位系统需要32位的配套系统安装</li></ol><p>疑问：既然有32 64，那有没有128位呢？</p><p>字符：电子计算机或者说是无线电通信中字母、数字、符号的统称</p><h2 id="各类型占用比特（bit）"><a href="#各类型占用比特（bit）" class="headerlink" title="各类型占用比特（bit）"></a>各类型占用比特（bit）</h2><img src="https://img-blog.csdnimg.cn/2021060818305690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>1个byte（字节）= 8位（bit），每一位就是0、1二进制，那么8位就能储存$2^8=256$个数字，所以1个字节能够代表256个数字，取值范围在-128~127</li><li>以此类推，1个short（短整型）=16位，那么就能储存$2^{16}=65535$个，取值范围就在-32768~32767</li></ul><h2 id="吃透字符："><a href="#吃透字符：" class="headerlink" title="吃透字符："></a>吃透字符：</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>字符的历史比较复杂：<br>分为可见字符和控制字符：</p><ul><li>可见字符：英文字母、数字、标点符号</li><li>控制字符：如 换行、回车等</li></ul><img src="https://img-blog.csdnimg.cn/20210608223909373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" />如图，将这0~127（128个）的编号称作==码位==，代表了字符的id信息，再把这每个字符的码位转化二进制信息进行存储，这样的二进制信息为ASCII码：<img src="https://img-blog.csdnimg.cn/20210609170132592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>但是原始128个ASCII码字符过于少，仅满足==美国==需求，为了满足==欧洲等国家==字符集的需求，又对ASCII进行了扩充，从128扩充到255，那么ASCII码也就只能表示256个字符，对于==中国==来说，实在太少！</p><p>因为8位最多只能表示256个字符，对于中文来说，有几千个中文字符，我们则必须用16位表示一个字符了！那么要先设计字符集：</p><h3 id="GB2312字符集"><a href="#GB2312字符集" class="headerlink" title="GB2312字符集"></a>GB2312字符集</h3><p>使用分区管理，共计94个区，每个区含94个位，共8836个码位。<br>先介绍一下码位：<br><img src="https://img-blog.csdnimg.cn/2021060920062834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><br> <img src="https://img-blog.csdnimg.cn/2021060920050574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><br> <img src="https://img-blog.csdnimg.cn/20210609200829267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>前面的ASCII码可以直接转为二进制来存储，GB2312如何存储？<br><img src="https://img-blog.csdnimg.cn/20210609201044655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><br>GBK2312的高位和低位都大于127，那么计算机只要碰到大于127的字节就是汉字的开始<br><img src="https://img-blog.csdnimg.cn/2021061110542046.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>那么，世界上就会有不同的编码，会非常乱！<br><img src="https://img-blog.csdnimg.cn/20210611105453827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>ISO组织为了解决这个问题，开始规范化编码！提出了Unicode，目的就是把世界上所有字符放在一起并编号<br><img src="https://img-blog.csdnimg.cn/20210611105733928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是ASCII本来也只需要8位、GB2312只用16位，这里的UCS字符集需要32位，扩大了4倍、2倍，导致Unicode提出后并没有被广泛接受，而后期各国交流更加频繁，从而新生了一个新编码UTF-8<br>UTF-8每次传送8位数据，是一种可变长的编码格式<br><img src="https://img-blog.csdnimg.cn/20210611110356437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算<img src="https://img-blog.csdnimg.cn/20210608183243416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h1><p>移位运算指的是将二进制数值各个数位进行左右移位（shift）的运算，移位有左移、右移两种。<br>左移好理解，就是将原数值乘以2的n次幂，但是右移要注意了！二进制中的最高位表示的是符号（1代表负数，0代表正数），<br>eg：那么-1用8位如何表示呢？<br>大部分人会理解成：1的二进制是00000001，那么-1就是10000001，答案错！正确为：11111111。<br>计算机做减法运算时，实际上内部是加法，那么表示负数，就要用到正数的==补数==表示，补数=正数取反+1；<br>验证：1+（-1）=</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000001</span></span><br><span class="line">+<span class="number">1111111</span></span><br><span class="line">   <span class="number">10000000</span></span><br></pre></td></tr></table></figure><p>这里相加后是9位，其中最高位的1溢出，答案为0，符合。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 仔细思考一下补数整个的机制，就不难理解如-32768至32767、 -128至127这些数据表示大范围为何正数最大值都比负数最大小1了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二进制&quot;&gt;&lt;a href=&quot;#二进制&quot; class=&quot;headerlink&quot; title=&quot;二进制&quot;&gt;&lt;/a&gt;二进制&lt;/h1&gt;&lt;p&gt;提到二进制，为啥计算机底层数据存储都采用二进制呢？计算机内部事由IC电子部件构成，IC的一个引脚，只能表示两个状态（《程序是怎样跑起</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="计算机基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://ericzikun.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="程序是怎样跑起来的" scheme="https://ericzikun.github.io/tags/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    
    <category term="二进制" scheme="https://ericzikun.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="字节" scheme="https://ericzikun.github.io/tags/%E5%AD%97%E8%8A%82/"/>
    
    <category term="移位运算" scheme="https://ericzikun.github.io/tags/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>儿子到底继承了爸爸哪些优良传统？【OOP+继承+接口】</title>
    <link href="https://ericzikun.github.io/2021/05/28/Deep1%EF%BC%9A%E3%80%90OOP-%E7%BB%A7%E6%89%BF-%E6%8E%A5%E5%8F%A3%E3%80%91/"/>
    <id>https://ericzikun.github.io/2021/05/28/Deep1%EF%BC%9A%E3%80%90OOP-%E7%BB%A7%E6%89%BF-%E6%8E%A5%E5%8F%A3%E3%80%91/</id>
    <published>2021-05-28T10:22:49.000Z</published>
    <updated>2021-06-29T05:53:46.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在Java中，继承是类与类之间的一种关系，分为父类和子类两种。这里和接口区分一下：一个类只能继承一个父类，而不能继承多个——即单继承关系；而一个类却可以实现多个接口。如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>子类继承了父类的所有内容，但是对于不同访问修饰父类修饰的属性方法，子类所调用的权限也不相同。对于public关键词修饰的属性和方法，子类同一个项目下都可以继承和调用。protected关键词修饰的属性和方法，可以在同包下和子类继承关系下继承和调用。对于缺省关键词的方法和属性，只能在同包下继承的调用，但是对于private修饰符修饰的属性和方法，只能自己该类使用。<br>子类继承父类的方法后，还可以根据需要重写其该方法。重写方法的名称必须与父类相同，访问修饰符可以和父类相同也可以比父类权限更大、返回值类型可以和父类相同也可以是父的子类，这样可以丰富扩展子类继承父类的方法。<br>对于继承父类的子类方法，在初始化方法时可以使用父类容器来初始化子类</p><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的内容"><a href="#继承的内容" class="headerlink" title="继承的内容"></a>继承的内容</h3><ol><li>子类继承到父类的哪些东西？</li></ol><p>所有</p><ol start="2"><li>子类以及子类对象可以调用到继承的哪些属性和方法？</li></ol><p>要看 父类的属性、方法的具体==访问修饰符==：</p><table><thead><tr><th>访问修饰符</th><th>访问范围</th></tr></thead><tbody><tr><td>public</td><td>项目里</td></tr><tr><td>private</td><td>类里</td></tr><tr><td>protected</td><td>包下，不同包的子类</td></tr><tr><td>缺省</td><td>同包下</td></tr></tbody></table><p>那么对于子类来说，</p><p>同包下：</p><p>​    只有private不能调用</p><p>不同包下：</p><p>​    public，protected 可以调用</p><p>==protected== 受保护的，子类不能访问父类的私有字段。不过有时候希望限制<strong>父类中的某个方法只允许子类访问</strong>，或者<strong>希望子类的方法访问超类的某个字段</strong>。</p><h3 id="方法重写："><a href="#方法重写：" class="headerlink" title="方法重写："></a>方法重写：</h3><p>注解格式：除方法体之外与父类一致</p><h4 id="访问修饰符："><a href="#访问修饰符：" class="headerlink" title="访问修饰符："></a>访问修饰符：</h4><p>子类中重写的方法，与父类权限一致或者大于（因为子类继承，希望它有更强的扩展性，所以权限理应更大）</p><h4 id="返回值类型："><a href="#返回值类型：" class="headerlink" title="返回值类型："></a>返回值类型：</h4><p>与父类方法的返回值类型类/子类</p><h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><p>参数类型 不能修改</p><p>对于子类而言：子类及子类对象可以优先调用重写之后的</p><h4 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h4><p>方法名相同，参数不一致（子类 父类也可以实现重载，并不会归为一种类型）</p><h4 id="自动转型："><a href="#自动转型：" class="headerlink" title="自动转型："></a>自动转型：</h4><p>强制转型：int i = (int)1.2;<br>        A a = new B();<br>        A 是 B 的 父类——&gt; 祖先<br>        向上转型 之后 还会优先调用重写的方法吗？<br>            会</p><p>子类对像  向上 -&gt; 父类类型 ——&gt;向下转回子类类型 【可以】<br>父类对象 –&gt; 向下转型 子类类型 （==对象 无中生有== 子类可能有一些特别的属性方法 父类没有）【不可以】</p><p>==注意==：子类向上转型后，只能调用父类有的方法，并且是调的子类覆盖重写的，而不能调用子类独立的方法；子类独有的方法在父类中根本没有定义，所以父类无法找到子类独有的方法。</p><p>任务：一个类实例化的加载过程：</p><p>顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.加载静态成员&#x2F;代码块：</span><br><span class="line"></span><br><span class="line">先递归地加载父类的静态成员&#x2F;代码块(Object的最先)；再依次加载到本类的静态成员。</span><br><span class="line">同一个类里的静态成员&#x2F;代码块，按写代码的顺序加载。</span><br><span class="line">如果其间调用静态方法，则调用时会先运行静态方法，再继续加载。同一个类里调用静态方法时，可以不理会写代码的顺序。</span><br><span class="line">调用父类的静态成员，可以像调用自己的一样；但调用其子类的静态成员，必须使用“子类名.成员名”来调用。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.加载非静态成员&#x2F;普通代码块，初始化构造方法：（实例块在创建对象时才会被加载。而静态成员在不创建对象时可以加载）</span><br><span class="line"></span><br><span class="line">先递归地加载父类的非静态成员&#x2F;代码块(Object的最先)，非静态成员和代码块按代码出现顺序加载，并在加载完非静态成员后初始化构造方法；再依次加载到本类的非静态成员，并初始化构造方法，默认为无参构造，当然也可以指定父类初始化构造方法，和本类初始化构造方法。在子类构造方法中用super(参数列表);可以指定初始化父类构造方法，默认不写super(参数列表)为初始化父类无参构造方法。</span><br><span class="line">同一个类里的非静态成员&#x2F;普通代码块，按写代码的顺序加载。同一个类里调用方法时，可以不理会写代码的顺序。</span><br><span class="line">但调用属性时，必须注意加载顺序。一般编译就会不通过。</span><br><span class="line">调用父类的非静态成员(private 除外)，也可以像调用自己的一样。</span><br></pre></td></tr></table></figure><p>问题：静态代码块只加载一次，静态方法先于静态代码块？<br>这里要看情况，我这里样例是 由于声明成员变量时调用到了静态方法 所以静态方法优先于静态代码块 但实际上这两者本没有优先区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">     <span class="keyword">static</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(<span class="string">"Static Init Base "</span> + a);</span><br><span class="line">         <span class="comment">//System.out.println("Null Init " + b);</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Init Base "</span> + <span class="keyword">this</span>.b);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *一级子类和基类包含的内容一样</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  <span class="comment">//静态变量、静态块执行顺序，按书写先后顺序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a1 = getSuperStaticNumber();</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> b1 = getSuperInstanceNumber();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Init SuperClass"</span> + <span class="keyword">this</span>.b1);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(<span class="string">"Static Init SuperClass"</span> + a1);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSuperStaticNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Static member init"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperInstanceNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Instance member init"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *二级子类为测试该代码的驱动类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a2 = getStaticNumber();</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> b2 = getInstanceNumber();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Init SubClass "</span> + <span class="keyword">this</span>.b2);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStaticNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Static member init Sub"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInstanceNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Instance member init Sub"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">2000</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(<span class="string">"Static Init "</span> + a2);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 程序入口,main</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> Sub();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><!-- ![在这里插入图片描述]() --><img src="https://img-blog.csdnimg.cn/20210527153502546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>几个面试常见问题：</p><ul><li>请解释hashCode()和equals()方法有什么联系？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java对象的eqauls方法和hashCode方法是这样规定的：</span><br><span class="line"></span><br><span class="line">➀相等（相同）的对象必须具有相等的哈希码（或者散列码）。</span><br><span class="line"></span><br><span class="line">➁如果两个对象的hashCode相同，它们并不一定相同。</span><br></pre></td></tr></table></figure></li><li>若对一个类不重写，它的equals()方法是如何比较的？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址</span><br></pre></td></tr></table></figure></li><li>请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。</span><br><span class="line">与此相对，方法覆盖是说子类重新定义了父类的方法。</span><br><span class="line">方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</span><br></pre></td></tr></table></figure></li><li>请判断，两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不对，如果两个对象x和y满足x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当相同。</span><br><span class="line">Java对于eqauls方法和hashCode方法是这样规定的：</span><br><span class="line">(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</span><br><span class="line">(2)如果两个对象的hashCode相同，它们并不一定相同。</span><br><span class="line">当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降</span><br><span class="line">（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）</span><br></pre></td></tr></table></figure></li><li>请判断当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是值传递。Java 编程语言只有值传递参数。</span><br><span class="line">当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。</span><br><span class="line">对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</span><br></pre></td></tr></table></figure>==Java是值传递== 就算传的是对象 也是传的对象地址<br><a href="https://www.zhihu.com/question/31203609/answer/164430457" target="_blank" rel="noopener">https://www.zhihu.com/question/31203609/answer/164430457</a><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要==实现接口里面所有的方法和属性==，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在Java中，继承是类与类之间的一种关系，分为父类和子类两种。这里和接口区分一下：一个类只能继承一个父类，而不能继承多个——即单继承关系；而</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ericzikun.github.io/tags/java/"/>
    
    <category term="OOP" scheme="https://ericzikun.github.io/tags/OOP/"/>
    
    <category term="继承" scheme="https://ericzikun.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="接口" scheme="https://ericzikun.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
</feed>
