<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EricKun</title>
  
  
  <link href="https://ericzikun.github.io/atom.xml" rel="self"/>
  
  <link href="https://ericzikun.github.io/"/>
  <updated>2021-11-06T08:22:58.611Z</updated>
  <id>https://ericzikun.github.io/</id>
  
  <author>
    <name>Eric kun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解JVM【垃圾回收机制】</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2021-11-06T08:20:51.000Z</published>
    <updated>2021-11-06T08:22:58.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三、JVM垃圾回收机制"><a href="#三、JVM垃圾回收机制" class="headerlink" title="三、JVM垃圾回收机制"></a>三、JVM垃圾回收机制</h1><h2 id="3-1-堆为什么要分成年轻代和老年代？"><a href="#3-1-堆为什么要分成年轻代和老年代？" class="headerlink" title="3.1 堆为什么要分成年轻代和老年代？"></a>3.1 堆为什么要分成年轻代和老年代？</h2><p><img src="https://img-blog.csdnimg.cn/90318ff2219b4046a6872637405b5965.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>因为年轻代和老年代不同的特点，需要采用不同的垃圾回收算法；</p><p>年轻代的对象，它的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法；</p><p>老年代的对象，它的特点是需要长期存活，所以需要另外一种垃圾回收算法 ；</p><p>所以需要分成两个区域来放不同的对象；</p><p><strong>1、绝大多数对象都是朝生夕灭的；</strong></p><p>如果一个区域中大多数对象都是朝生夕灭，那么把它们集中放在一起，每次回收时只关注如何保留少量存活对象，而不是去标记那些大量将要被回收的对象，就能以较低的代价回收到大量的空间；</p><p><strong>2、熬过越多次垃圾收集的对象就越难以回收；</strong></p><p>如果是需要长期存活的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用；</p><p><strong>3、JVM划分出新生代、老年代之后，垃圾收集器可以每次只回收其中某一个或者某些部分的区域 ，同时也有了“Minor GC”“Major GC”“Full GC”这样的回收类型的划分；</strong></p><p>Minor GC/Young GC ：新生代收集 </p><p>Major GC/Old GC：老年代收集</p><p>Full GC：整堆收集，收集整个Java堆和元空间/方法区的垃圾收集；</p><p>Mixed GC：混合收集，收集整个新生代以及部分老年代的垃圾收集，目前只有G1收集器会有这种行为； </p><p>4、针对不同的区域对象存亡特征采用不同的垃圾收集算法：</p><p>（1）复制算法</p><p>（2）标记-清除算法</p><p>（3）标记-整理算法</p><h2 id="3-2-JVM堆的年轻代为什么要有两个Survivor区？"><a href="#3-2-JVM堆的年轻代为什么要有两个Survivor区？" class="headerlink" title="3.2 JVM堆的年轻代为什么要有两个Survivor区？"></a>3.2 JVM堆的年轻代为什么要有两个Survivor区？</h2><p><strong>1、如果没有Survivor区会怎么样？</strong></p><p>此时每触发一次Minor GC，就会把Eden区的对象复制到老年代，这样当老年代满了之后会触发Major Gc/Full GC(通常伴随着MinorGC)，比较耗时，所以必须有Survivor区；</p><blockquote><p>解释：</p><p>会比较频繁的出发Full GC，开销太大</p></blockquote><p><strong>2、如果只有1个Survivor区会怎么样？</strong>【导致内存碎片】</p><p>刚刚创建的对象在Eden中，一旦Eden满了，触发一次Minor GC，Eden中存活的对象就会被移动到Survivor区，下一次Eden满了的时候，此时进行Minor GC，Eden和Survivor各有一些存活对象，因为只有一个Survivor，所以Eden区第二次GC发现的存活对象也是放入唯一的一个Survivor区域中，但此时把Eden区的存活对象硬放到Survivor区，很明显这两部分对象所占有的内存是不连续的，也就导致了内存碎片化问题，并且由于不连续的空间会导致再分配大对象的时候，由于没有连续的空间来分配，会导致提前垃圾回收；</p><p>如果将Survivor中的所有存活对象进行整理消除碎片，然后将所有的存活对象放入其中，这样做会降低效率；</p><p>如果把两个区域中的所有存活对象都复制转移到一个完全独立的空间中，也就是第二块Survivor中，这样就可以留出一块完全空着的Eden和Survivor了，下次GC的时候再重复这个流程，所以我们便要有两个Survivor区；</p><p><img src="https://img-blog.csdnimg.cn/8e18f9530d264d51868277c612a3c25f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：</p><p>如果只有一个Survivor区域，触发Minor GC后会有内存碎片问题的产生(内存不连续)，大大降低了效率</p><p>所以得有第二个Survivor区域来装要存活的对象，从而使得第一个Survivor空闲、Eden也空闲，保证了内存空间的连续性——需要2个Survivor区域的原因解析</p></blockquote><h2 id="3-3-Eden区与Survivor区的空间大小比值为什么默认是8-1-1？"><a href="#3-3-Eden区与Survivor区的空间大小比值为什么默认是8-1-1？" class="headerlink" title="3.3 Eden区与Survivor区的空间大小比值为什么默认是8:1:1？"></a>3.3 Eden区与Survivor区的空间大小比值为什么默认是8:1:1？</h2><p>一个eden区 ，新生代对象出生的地方；</p><p>两个survivor区，一个用来保存上次新生代GC存活下来的对象，还有一个空着，在新生代GC时把eden+survivor中存活对象复制到这个空的survivor中；</p><p>统计和经验表明，<strong>90%的对象朝生夕死存活时间极短</strong> ，每次gc会有90%对象被回收，剩下的10%要预留一个survivor空间去保存； </p><blockquote><p>解释</p><p>8：1：1原因在于每次gc会有90%的对象被回收 ，这是个统计的结果</p></blockquote><h2 id="3-4-请介绍下JVM中的垃圾回收算法？"><a href="#3-4-请介绍下JVM中的垃圾回收算法？" class="headerlink" title="3.4 请介绍下JVM中的垃圾回收算法？"></a>3.4 请介绍下JVM中的垃圾回收算法？</h2><p><img src="https://img-blog.csdnimg.cn/457179f481b940119c2e236eaed29b5b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-4-1-标记-清除算法"><a href="#3-4-1-标记-清除算法" class="headerlink" title="3.4.1 标记-清除算法"></a>3.4.1 标记-清除算法</h3><p>标记-清除算法是最基础的收集算法，后续的很多垃圾回收算法是基于该算法而发展出来的，它分为‘ 标记 ’和‘ 清除 ’两个阶段；</p><p><strong>1、标记</strong></p><p>标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记出所有存活的对象，在标记完成后，统一回收所有未被标记的对象，标记过程就是对象是否属于垃圾的判定过程，基于可达性分析算法判断对象是否可以回收；</p><p><strong>2、清除</strong></p><p>标记后，对所有被标记的对象进行回收；</p><p>该算法如下图所示：</p><p>会发现回收后，内存空间就不连续了，有内存碎片<br><img src="https://img-blog.csdnimg.cn/28fa94791cfc4ff18e7a928008ef8243.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>优点：</strong></p><p>基于最基础的可达性分析算法，实现简单，后续的收集算法都是基于这种思想实现的；</p><p><strong>缺点：</strong></p><p>1、执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</p><p>2、内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集；</p><h3 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2 复制算法"></a>3.4.2 复制算法</h3><p>复制算法是标记-复制算法的简称，将可用内存按容量分为大小相等的两块，每次只使用其中一块，当这一块的内存用完了，就将还存活的对象复制到另外一块内存上，然后再把已使用过的内存空间一次清理掉；</p><p><img src="https://img-blog.csdnimg.cn/4cc321ebb7484b3d8d35e09eba1e4b7c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>优点：</strong></p><p>实现简单，效率高，解决了标记-清除算法<strong>导致的内存碎片问题</strong>；</p><p><strong>缺点：</strong></p><p>1、代价太大，将可分配内存缩小了一半，<strong>空间浪费太多</strong>了；</p><p>2、对象存活率较高时就要进行较多的复制操作，效率将会降低；</p><h3 id="3-4-3-标记-整理算法"><a href="#3-4-3-标记-整理算法" class="headerlink" title="3.4.3 标记-整理算法"></a>3.4.3 标记-整理算法</h3><p>标记-整理算法是根据<strong>老年代</strong>的特点而产生的； </p><p><strong>1、标记</strong></p><p>标记过程与上面的标记-清理算法一致，也是基于可达性分析算法进行标记；</p><p><strong>2、整理</strong></p><p>和标记-清理不同的是，该算法不是针对可回收对象进行清理，而是根据存活对象进行整理，让存活对象都向一端移动，然后直接清理掉边界以外的内存；</p><p>而<strong>标记-清除算法</strong>不移动存活对象，导致有大量不连续空间，即内存碎片，而老年代这种每次回收都有大量存活对象的区域，移动存活对象并更新所有引用这些对象的引用，这是一种比较耗时的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，像这样的停顿我们也称为“Stop The World”即STW；</p><p>但是即便是移动存活对象是耗时的操作，但是如果不这么做，那么在充满内存碎片的空间中分配对象，又影响了对象的分配和访问的效率，所以JVM权衡两者之后，还是采用了<strong>移动存活对象的方式，也就是对内存进行了整理</strong>；</p><p>另外像cms垃圾收集器，平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间，所以像基于标记-清除算法的CMS收集器面临空间碎片过多时就会进行一次整理； </p><p><strong>优点：</strong></p><p>1、不会像复制算法那样划分两个区域，提高了空间利用率；</p><p>2、不会产生不连续的内存碎片；</p><p><strong>缺点：</strong></p><p>效率问题，除了像标记-清除算法的标记过程外，还多了一步整理过程，效率变低；</p><p>如下图所示：<br><img src="https://img-blog.csdnimg.cn/a551f71a551a48a9acd916a83ce47c39.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-4-4-分代收集算法"><a href="#3-4-4-分代收集算法" class="headerlink" title="3.4.4 分代收集算法"></a>3.4.4 分代收集算法</h3><p>现在一般虚拟机的垃圾收集都是采用“ <strong>分代收集</strong> ”算法；</p><p>根据对象存活周期的不同将内存划分为几块，一般把java堆分为<strong>新生代和老年代</strong>，JVM根据各个年代的特点采用不同的收集算法；</p><p>新生代中，每次进行垃圾回收都会发现大量对象死去，只有少量存活，因此采用<strong>复制算法</strong>，只需要付出少量存活对象的复制成本就可以完成收集；——只需要复制少于10%的对象，效率很高！</p><p>老年代中，因为对象存活率较高，采用<strong>标记-清理、标记-整理</strong>算法来进行回收；</p><h2 id="3-5-请介绍一下JVM垃圾收集器？"><a href="#3-5-请介绍一下JVM垃圾收集器？" class="headerlink" title="3.5 请介绍一下JVM垃圾收集器？"></a>3.5 请介绍一下JVM垃圾收集器？</h2><p><img src="https://img-blog.csdnimg.cn/083fe79ca2af48a9a0ff6d3df1576daf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如上图，一共有7种作用于不同分代的垃圾收集器，如果两个收集器之间存在连线，则说明它们可以搭配使用，垃圾收集器所处区域表示它是属于新生代收集器还是老年代收集器；</p><p>新生代收集器：Serial、ParNew、Parallel Scavenge [ˈpærəlel] [ˈskævɪndʒ] </p><p>老年代收集器：CMS、Serial Old、Parallel Old</p><p>整堆收集器： G1</p><p>垃圾收集器的最前沿成果：ZGC（Jdk11中引入了） 和 Shenandoah（Open JDK12，Oracle没引入，很前沿 ）</p><blockquote><p>解释：</p><p>目前在生产环境中，G1是比较先进的垃圾收集器了</p></blockquote><h3 id="3-5-1-Serial收集器-新生代、单线程"><a href="#3-5-1-Serial收集器-新生代、单线程" class="headerlink" title="3.5.1 Serial收集器[新生代、单线程]"></a>3.5.1 Serial收集器[新生代、单线程]</h3><p>新生代收集器，最早的收集器，单线程的，收集时需暂停用户线程的工作，所以有卡顿现象，效率不高，致使java语言的开发团队一直在改进垃圾收集器的算法和实现，但Serial收集器<strong>简单</strong>，不会有线程切换的开销，是Client模式下默认的垃圾收集器，-client， -server；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数： -XX:+UseSerialGC</span><br><span class="line"></span><br><span class="line">java -XX:+PrintFlagsFinal -version 打印jvm默认的参数值；</span><br></pre></td></tr></table></figure><p>垃圾收集时间线如下：</p><p>所有线程卡住（停下来），进行垃圾收集，收集完毕，然后再继续…<br><img src="https://img-blog.csdnimg.cn/e5e1db8a41cd4a6798c87112495fb211.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-5-2-ParNew收集器-新生代、多线程"><a href="#3-5-2-ParNew收集器-新生代、多线程" class="headerlink" title="3.5.2 ParNew收集器[新生代、多线程]"></a>3.5.2 ParNew收集器[新生代、多线程]</h3><p>它是新生代收集器，就是<strong>Serial收集器的多线程版本</strong>，大部分基本一样，单CPU下，ParNew还需要切换线程，可能还不如Serial；</p><p>Serial和ParNew收集器可以配合CMS收集器，前者收集新生代，后者CMS收集老年代，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;-XX:+UseConcMarkSweepGC&quot;：指定使用CMS后，会默认使用ParNew作为新生代垃圾收集器；</span><br><span class="line">&quot;-XX:+UseParNewGC&quot;：强制指定使用ParNew；</span><br><span class="line">&quot;-XX:ParallelGCThreads&#x3D;2&quot;：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/b9fab178b75e4d64ae51fdf65ee5874b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="3-5-3-Parallel-Scavenge收集器【新生代、多线程】"><a href="#3-5-3-Parallel-Scavenge收集器【新生代、多线程】" class="headerlink" title="3.5.3 Parallel Scavenge收集器【新生代、多线程】"></a>3.5.3 Parallel Scavenge收集器【新生代、多线程】</h3><p> <img src="https://img-blog.csdnimg.cn/628f0c5d16144edb9bdffc4296e5da31.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>简称Parallel，它是新生代收集器，基于<strong>复制算法</strong>，并行的多线程收集器（与ParNew收集器类似），侧重于达到一个可控的吞吐量，虚拟机运行100分钟，垃圾收集花1分钟，则吞吐量为99%，有时候我们也把该垃圾收集器叫吞吐量垃圾收集器或者是吞吐量优先的垃圾收集器；而且这个垃圾收集器是jvm默认的新生代的垃圾收集器；</p><p>它提供一个<strong>参数设置吞吐量：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis 该参数设置大于0的毫秒数，每次GC的时间将尽量保持不超过设置的值，但是这个值也不是设置得越小就越好，GC暂停时间越短，那么GC的次数会变得更频繁；</span><br><span class="line"></span><br><span class="line">-XX:+UseAdaptiveSizePolicy 自适应新生代大小策略，默认这个参数是开启的，当这个参数被开启之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间获得最大的吞吐量，这种调节方式称为垃圾收集的自适应的调节策略（GC Ergonomics）；</span><br></pre></td></tr></table></figure><p>如果我们不知道怎么对jvm调优，我们可以使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成也许是一个很不错的选择，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用-XX:MaxGCPauseMillis参数（最大停顿时间）给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成，自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">参数：-XX:+UseParallelGC 指定使用Parallel Scavenge垃圾收集器</span><br><span class="line"></span><br><span class="line">java -XX:+PrintCommandLineFlags -version 打印jvm默认初始堆和最大堆大小以及垃圾收集器</span><br><span class="line"></span><br><span class="line">java -XX:+PrintFlagsFinal -version 打印jvm所有的默认的参数值；</span><br><span class="line"></span><br><span class="line">-XX:+ </span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"></span><br><span class="line">-Xloggc:d:&#x2F;dev&#x2F;gc.log</span><br><span class="line"></span><br><span class="line">Parallel Scavenge垃圾收集器中的Ergonomics负责自动的调节gc暂停时间和吞吐量之间的平衡，自动优化虚拟机的性能；</span><br></pre></td></tr></table></figure><h3 id="GC日志"><a href="#GC日志" class="headerlink" title="GC日志"></a>GC日志</h3><p>这里常用一下JVM参数打印JVM的log:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line">-Xloggc:d:&#x2F;dev&#x2F;gc.log</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/470dfa56725548239ab8499dea1414f9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三、JVM垃圾回收机制&quot;&gt;&lt;a href=&quot;#三、JVM垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;三、JVM垃圾回收机制&quot;&gt;&lt;/a&gt;三、JVM垃圾回收机制&lt;/h1&gt;&lt;h2 id=&quot;3-1-堆为什么要分成年轻代和老年代？&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="JAVA虚拟机" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM【内存管理】</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2021-11-06T08:18:50.000Z</published>
    <updated>2021-11-06T08:27:55.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二、深入剖析JVM内存管理"><a href="#二、深入剖析JVM内存管理" class="headerlink" title="二、深入剖析JVM内存管理"></a>二、深入剖析JVM内存管理</h1><h2 id="2-1-Java代码到底是如何运行起来的？"><a href="#2-1-Java代码到底是如何运行起来的？" class="headerlink" title="2.1 Java代码到底是如何运行起来的？"></a>2.1 Java代码到底是如何运行起来的？</h2><p>1、Mall.java –&gt;javac –&gt; Mall.class –&gt; java Mall (jvm进程，也就是一个jvm虚拟机)</p><p>2、Mall.java –&gt;javac–&gt;Mall.class –&gt;Mall.jar –&gt; java -jar Mall.jar</p><p>3、Mall.java –&gt; javac –&gt; Mall.class –&gt;Mall.war –&gt; Tomcat –&gt; startup.sh –&gt; org.apache.catalina.startup.Bootstrap (jvm进程，也就是一个jvm虚拟机)</p><p>其实运行起来一个Java程序，都是通过D:\dev\Java\jdk1.8.0_251\bin\java 启动一个JVM虚拟机，在虚拟机里面运行Mall.class字节码文件；</p><p><img src="https://img-blog.csdnimg.cn/ea7c556c03de419baba584e11e510a2c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>总结：</p><p>java源文件通过javac命令转成java字节码文件，再通过java命令运行起来，JVM是用于屏蔽掉底层操作系统之间的差异，这里不同操作系统所装载的jdk是不同的，jdk中包含jvm</p></blockquote><blockquote><p>这里面的其他语言，如Groovy、Scala、Kotlin也是编译后为字节码，再通过JVM虚拟机处理。</p></blockquote><h2 id="2-2画一下JVM整个运行原理图？☆"><a href="#2-2画一下JVM整个运行原理图？☆" class="headerlink" title="2.2画一下JVM整个运行原理图？☆"></a>2.2画一下JVM整个运行原理图？☆</h2><p><img src="https://img-blog.csdnimg.cn/10d2679aef014bd0a5e2b8b5f1feacf7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-3-请介绍一下JVM的内存结构划分？"><a href="#2-3-请介绍一下JVM的内存结构划分？" class="headerlink" title="2.3 请介绍一下JVM的内存结构划分？"></a>2.3 请介绍一下JVM的内存结构划分？</h2><p>加载进来的.class字节码文件、代码执行创建的对象、代码执行调用方法，方法中有变量等数据需要一个地方存放，所以JVM划分出了几个区域，用于存放这些信息；<strong>hotspot</strong></p><p><img src="https://img-blog.csdnimg.cn/466092a41d3c4dd2999cc6cb69532305.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在JDK1.8之前，元空间就是原来的方法区（永久代）；</p><p>比如new User(),那么User这个变量在虚拟机栈中存储为局部变量，但是其值是在堆中存储的</p><p>程序计数器：表明代码执行到哪一行</p><p>当类加载后，Class文件首先会存储在元空间中，然后运行时才会涉及其他几个空间部分</p><h2 id="2-4-JVM哪些区域是线程私有的，哪些区域是线程共享的？☆"><a href="#2-4-JVM哪些区域是线程私有的，哪些区域是线程共享的？☆" class="headerlink" title="2.4 JVM哪些区域是线程私有的，哪些区域是线程共享的？☆"></a>2.4 JVM哪些区域是线程私有的，哪些区域是线程共享的？☆</h2><p>1、堆、元空间（方法区）是线程共享的；</p><p>2、其他区域是线程私有的；</p><p><img src="https://img-blog.csdnimg.cn/228fe4ea721744d88c221a55e4e2abaf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>线程私有的区域如虚拟机栈、本地方法栈、程序计数器，这些就不存在线程安全的问题，每个线程之间这些区域是隔离的，不共享变量，就不会导致冲突，没有安全问题</p><p>举例：两个线程对应就有两个虚拟机栈，一一对应。无论有几个线程，堆和元空间都是公用的一个</p><h2 id="2-5-从JVM角度剖析如下程序代码如何执行？"><a href="#2-5-从JVM角度剖析如下程序代码如何执行？" class="headerlink" title="2.5 从JVM角度剖析如下程序代码如何执行？"></a>2.5 从JVM角度剖析如下程序代码如何执行？</h2><p><img src="https://img-blog.csdnimg.cn/1172c5acc584401a90768850e3949891.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bf9aba7b51174d7db44c430b12949155.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>Config类在new的时候，对象存在堆中，该类的信息是在元空间里的</p><h2 id="2-6-JVM运行时数据区-程序计数器-的特点及作用？"><a href="#2-6-JVM运行时数据区-程序计数器-的特点及作用？" class="headerlink" title="2.6 JVM运行时数据区 程序计数器 的特点及作用？"></a>2.6 JVM运行时数据区 程序计数器 的特点及作用？</h2><p>1、程序计数器是一块较小的内存空间，几乎可以忽略；</p><p>2、是当前线程所执行的字节码的行号指示器；</p><p>3、Java多线程执行时，每条线程都有一个独立的程序计数器，各条线程之间计数器互不影响；</p><p>4、该区域是“线程私有”的内存，每个线程独立存储； </p><p>5、该区域不存在OutOfMemoryError；</p><p>6、无GC回收；</p><blockquote><p>总结：程序计数器是在线程产生的时候存在，在线程结束（销毁时候）消失，不需要垃圾回收（GC）</p></blockquote><h2 id="2-7-JVM运行时数据区-虚拟机栈的特点及作用？"><a href="#2-7-JVM运行时数据区-虚拟机栈的特点及作用？" class="headerlink" title="2.7 JVM运行时数据区 虚拟机栈的特点及作用？"></a>2.7 JVM运行时数据区 虚拟机栈的特点及作用？</h2><p>1、线程私有；</p><p>2、方法执行会创建栈帧，存储局部变量表等信息；</p><p>3、方法执行入虚拟机栈，方法执行完出虚拟机栈；（先进后出）</p><p>4、<strong>【深度过长】</strong> 栈深度大于虚拟机所允许StackOverflowError；</p><p>5、栈需扩展而无法申请空间OutOfMemoryError（比较少见）；hotspot虚拟机没有；</p><p>6、栈里面运行方法，存放方法的局部变量名，变量名所指向的值（常量值、对象值等）都存放到堆上的；</p><p>7、栈一般都不设置大小，栈所占的空间其实很小，可以通过-Xss1M进行设置，如果不设置默认为1M；</p><p>8、随线程而生，随线程而灭；</p><p>9、该区域不会有GC回收；</p><blockquote><p>解释：OutOfMemoryError一般少见，比如写个死循环不断的创建线程，当创建到一定程度，无法再继续给空间到新线程时，每个线程都会生成一个线程栈，每个线程栈会占用一定的内存区域，从而导致超出，会把会报此错误。</p></blockquote><p>如下，死循环中不断创建新的线程，而每个线程又不会结束，即不会销毁，从而导致大量内存占用。</p><p><img src="https://img-blog.csdnimg.cn/a8ca94b2a86543fb8012424b55060d55.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：递归调用时，有时会出现StackOverflowError，如下案例：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/174e439c54294adea990c98bfbde932a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输出结果：</p><p>解释栈大小设置：</p><p>一般1M足够大了，往往会将其设置小一点，在idea中添加JVM配置，默认是1M，也可以改为128k：</p><p><img src="https://img-blog.csdnimg.cn/14673c4fc962481b9436f76ea64bf89c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>改了栈大小之后，原来的栈深度35710就会减小，再报Stack Overflow：</p><p>相当于把栈变小了，压的栈就会相应变少。</p><p><img src="https://img-blog.csdnimg.cn/e43dc936d5ea4f598def559d401bf24f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>总结：实际项目中，一般也不会递归调用太多次，1M的话，调用个3w多次肯定是够用的！所以改小一点是有好处的，改小一点反而可以启动更多线程，比如原本10M的内存空间可以创建10个1M的线程，那么把栈大小改小后，线程所占用的内存空间就变小了，从而使得线程数量变多</p></blockquote><h2 id="2-8-JVM运行时数据区-本地方法栈的特点及作用？"><a href="#2-8-JVM运行时数据区-本地方法栈的特点及作用？" class="headerlink" title="2.8 JVM运行时数据区 本地方法栈的特点及作用？"></a>2.8 JVM运行时数据区 本地方法栈的特点及作用？</h2><p>1、与虚拟机栈基本类似；</p><p>2、区别在于本地方法栈为Native方法服务；</p><p>3、HotSpot虚拟机将虚拟机栈和本地方法栈合并；</p><p>4、有StackOverflowError和OutOfMemoryError（比较少见）；</p><p>5、随线程而生，随线程而灭；</p><p>6、GC不会回收该区域；</p><p><strong>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；</strong></p><p>解释：本地方法栈和虚拟机栈类似，只不过存储的是Native方法，也就是底层由C++写的方法；而HotSpot是把虚拟机栈和本地方法栈合并到一起了！</p><p><img src="https://img-blog.csdnimg.cn/0ec3e41627be41b5ab41cc45f81115da.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-9-JVM运行时数据区-Java堆的特点及作用？☆"><a href="#2-9-JVM运行时数据区-Java堆的特点及作用？☆" class="headerlink" title="2.9 JVM运行时数据区 Java堆的特点及作用？☆"></a>2.9 JVM运行时数据区 Java堆的特点及作用？☆</h2><p>1、线程共享的一块区域；</p><p>2、虚拟机启动时创建；</p><p>3、虚拟机所管理的内存中<strong>最大的一块区域</strong>；</p><p>4、存放所有实例<strong>对象或数组</strong>；</p><p>5、GC垃圾收集器的主要管理区域；</p><p>6、可分为新生代、老年代；</p><p>7、新生代更细化可分为Eden、From Survivor、To Survivor，Eden:Survivor = 8:1:1</p><p>8、可通过<strong>-Xmx、-Xms</strong>调节堆大小；</p><p>9、无法再扩展<strong>java.lang.OutOfMemoryError: Java heap space</strong></p><p>10、<strong>【TLAB】</strong> 如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率；</p><blockquote><p>解释：堆的年代划分</p></blockquote><p><img src="https://img-blog.csdnimg.cn/99db4806553041eeadea59a7c1e0f024.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：堆内存不足了，就会OOM，java.lang.OutOfMemoryError: Java heap space 堆溢出</p></blockquote><p><img src="https://img-blog.csdnimg.cn/11b3fa8d4f544029b771362463d76e2d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>输出结果：</p><p><img src="https://img-blog.csdnimg.cn/62e1f4b03635406f8e4f1ab69e81b7dd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如果改一下堆大小：<br><img src="https://img-blog.csdnimg.cn/55c7019bb71d4f6fb6d34e3e6da04ba7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/56c5710d4e924a89be55af07bc438056.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：TLAB：</p><p>因为堆是共享区域，所以当多个线程往堆里面放内容时，会产生一个竞争关系、冲突问题，那么最朴素的想法就是用锁去解决这个线程安全问题，但是用锁呢，又会导致效率比较低，所以干脆给每个线程一个默认区域，区域不大，但是供每个线程各自去放内容，也就是给每个线程分配了一个较小的缓冲区，当把缓冲区放满后，再去公共区放数据！</p></blockquote><h2 id="2-10-JVM中对象如何在堆内存分配？"><a href="#2-10-JVM中对象如何在堆内存分配？" class="headerlink" title="2.10 JVM中对象如何在堆内存分配？"></a>2.10 JVM中对象如何在堆内存分配？</h2><p>1、<strong>指针碰撞（Bump The Pointer）</strong>：内存规整的情况下；</p><p>2、<strong>空闲列表（Free List）</strong>：内存不规整的情况下；</p><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理（Compact）的能力决定；</p><p>因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；</p><p>而当使用CMS这种基于清除（Sweep）算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存；</p><p>3、<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer，TLAB）：对象创建在虚拟机中频繁发生，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况；</p><p>那么解决方案有两种：</p><p>（1）同步锁定，JVM是采用CAS配上失败重试的方式保证更新操作的原子性； </p><p>（2）线程隔离，把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定，虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定； </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:TLABSize&#x3D;512k 设置大小；</span><br></pre></td></tr></table></figure><blockquote><p>解释：指针碰撞：</p><p>当内存排列规整的时候，指针不断向右遍历，依次排列对象</p></blockquote><p><img src="https://img-blog.csdnimg.cn/d7dbb10ca5f1438d9ae5fcf9b7f9ae56.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>空闲列表:<br>和指针碰撞不同，该方式的内存排列不规整，有一个空闲列表去记录哪些区域是空闲的，那么当存储时去找对应的空闲内存进行存储</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c4819cc4f5e644a1a47bf5b28f035f7d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：具体用哪种方式，这个是根据垃圾回收器的空，间压缩整理能力来决定的，如果GC每次回收完后，将空内存排列的规整，那么就用指针碰撞</p></blockquote><p>一些JVM可以配置的参数：<br><img src="https://img-blog.csdnimg.cn/c1323e7f99184687868394628184dd0b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-11-JVM堆内存中的对象布局？"><a href="#2-11-JVM堆内存中的对象布局？" class="headerlink" title="2.11 JVM堆内存中的对象布局？"></a>2.11 JVM堆内存中的对象布局？</h2><p>在 HotSpot 虚拟机中，一个对象的存储结构分为3块区域：</p><p>对象头(Header)、实例数据(Instance Data) 和 对齐填充(Padding)；</p><ul><li>对象头(Header)：包含两部分，第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit，官方称为 ‘Mark Word’；<br><img src="https://img-blog.csdnimg.cn/0d8739fc506f4542ad2ce640f76bdfc8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第二部分是类型指针，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例，另外，如果是Java数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以；</li></ul><ul><li>实例数据(Instance Data)：程序代码中所定义的各种成员变量类型的字段内容(包含父类继承下来的和子类中定义的)；</li></ul><ul><li>对齐填充(Padding)：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍，HotSpot虚拟机，任何对象的大小都是8字节的整数倍；</li></ul><h2 id="2-12-JVM什么情况下会发生堆内存溢出？☆"><a href="#2-12-JVM什么情况下会发生堆内存溢出？☆" class="headerlink" title="2.12 JVM什么情况下会发生堆内存溢出？☆"></a>2.12 JVM什么情况下会发生堆内存溢出？☆</h2><p>Java堆中用于储存对象，只要不断地创建对象，并且保持<strong>GC Roots</strong>到对象之间有可达路径 </p><p>来避免垃圾回收机制清理这些对象，那么随着对象数量的增加，总容量达到最大堆的容量限制后就会产生内存溢出；</p><p>MAT工具分析xxx.hprof文件(相当于一个内存log)，排查溢出的原因；   </p><p>添加JVM参数 输出hprof文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath&#x3D;d:&#x2F;dev&#x2F;heapdump.hprof</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c59c2b4e6da54e2aac354e8fb56fab74.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b607a62acc6548faa40bcfa3a789a594.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>利用Eclipse的MAT工具来分析文件：</p><p>官网即可下载，open file，生成怀疑报告Leak suspects</p><p><img src="https://img-blog.csdnimg.cn/9560b3184aa747ae8e5a09b7e5e7e603.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-Xms3072M</span><br><span class="line"></span><br><span class="line">-Xmx3072M</span><br><span class="line"></span><br><span class="line">-Xmn1536M</span><br><span class="line"></span><br><span class="line">-Xss1M</span><br><span class="line"></span><br><span class="line">-XX:-UseCompressedClassPointers</span><br><span class="line"></span><br><span class="line">-XX:MetaspaceSize&#x3D;256M</span><br><span class="line"></span><br><span class="line">-XX:MaxMetaspaceSize&#x3D;256M</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio&#x3D;8</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;5</span><br><span class="line"></span><br><span class="line">-XX:PretenureSizeThreshold&#x3D;1M</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"></span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"></span><br><span class="line">-Xloggc:d:&#x2F;dev&#x2F;gc.log</span><br><span class="line"></span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line"></span><br><span class="line">-XX:HeapDumpPath&#x3D;d:&#x2F;dev&#x2F;heapdump.hprof</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/69ca5ae04bbb48f08da1850d89ffe88b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>解释：Java堆中用于储存对象，只要不断地创建对象，并且保持<strong>GC Roots</strong>到对象之间有可达路径 </p><p>比如这里的orderList是一个GC root根，然后引用了new ArrayList<Order>()这个List对象地址，然后这个List对象又在循环中，不断的去引用到了order对象，由于对象一直在创建，所以就能保持GC Roots到对象之间有可达路径!</p><p>如果这个List对象引用断了，那么就会将剩余的进行垃圾回收，从而不会导致堆内存溢出，也就是说，该List对象不再被引用了，就可以销毁了(被GC回收)，从而就不会占用堆内存了</p></blockquote><p><img src="https://img-blog.csdnimg.cn/92b64722c1e3442d9ac310556327beed.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>验证猜想：</p></blockquote><p>如果将order的引用注释掉：</p><p>这样一来，虽然orderList还是指向了堆内存中的List对象，但是List对象没有去引用新生成的order对象，导致order对象由于没有被引用，就会被GC回收，这样就不会导致堆内存溢出了.<br><img src="https://img-blog.csdnimg.cn/dcc1a44ff47a4892b9faf570372e05e4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以通过visualVM软件来可视化堆内存中对象的变化过程：</p><p>可以看出黄色的是每一个对象新生和销毁的过程，顶峰代表出生，下降到0代表销毁，所以就可以一直跑，不会堆溢出.<br><img src="https://img-blog.csdnimg.cn/248986e276794e50b98d0df6717a118c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对比溢出的情况：<br><img src="https://img-blog.csdnimg.cn/fdb13d45941348649229f5280c364b09.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>New区域不断的增加，到顶后，Old再累积</p><h2 id="2-13-JVM如何判断对象可以被回收？"><a href="#2-13-JVM如何判断对象可以被回收？" class="headerlink" title="2.13 JVM如何判断对象可以被回收？"></a>2.13 JVM如何判断对象可以被回收？</h2><p>在JVM堆里面存放着所有的Java对象，垃圾收集器在对堆进行回收前，首先要确定这些对象之中哪些还“存活”着，哪些已经“死去”；</p><p>Java通过 <strong>可达性分析（Reachability Analysis）</strong> 算法 来判定对象是否存活的；</p><p>该算法的基本思路：通过一系列称为“GC Roots”的根对象作为起始节点，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连（也称为不可达），则证明此对象是不可能再被使用的对象，就可以被垃圾回收器回收；<br><img src="https://img-blog.csdnimg.cn/e230558cf0b642d3a458ae89b8b7a670.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>对象object 5、object 6、object 7虽然有关联，但它们到GC Roots是不可达的，所以它们将会被判定为可回收的对象；</p><p><strong>哪些对象可以作为GC Roots呢？</strong> </p><p>1、在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等所引用的对象；</p><p>2、方法区/元空间中的类静态属性引用的对象；</p><p>3、方法区/元空间中的常量引用的对象；</p><p>4、在本地方法栈中JNI（即通常所说的Native方法）引用的对象； </p><p>5、Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 </p><p>NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器；</p><p>6、所有被同步锁（synchronized关键字）持有的对象；</p><p>7、反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等； </p><p>8、其他可能临时性加入的对象；</p><blockquote><p>总结：一般我们最常见的就是虚拟机栈中的局部变量引用的对象、临时变量，作为GC Root。</p></blockquote><h2 id="2-14-谈谈Java中不同的引用类型？"><a href="#2-14-谈谈Java中不同的引用类型？" class="headerlink" title="2.14 谈谈Java中不同的引用类型？"></a>2.14 谈谈Java中不同的引用类型？</h2><p>Java里有不同的引用类型，分别是强引用、软引用、弱引用 和 虚引用；</p><p>强引用：Object object = new Object(）;</p><p>软引用：SoftReference 内存充足时不回收，内存不足时则回收；</p><p>弱引用：WeakReference 不管内存是否充足，只要GC一运行就会回收该引用对象；</p><p>虚引用：PhantomReference这个其实暂时忽略也行，因为很少用，它形同虚设，就像没有引用一样，其作用就是该引用对象被GC回收时候触发一个系统通知，或者触发进一步的处理；</p><blockquote><p>解释：</p><p>强引用【大多用】，因为有变量指向对象，只要引用没有释放，即便是内存不足、溢出了，也不能回收这个引用</p><p>软引用【缓存用】，要看内存足不足，弱引用，一般用于缓存领域(内存充足就缓存起来，内存不足就清空缓存，比如mybatis中就用到过)</p><p>弱引用【很少用】：比如类库ThreadLocal用到过</p><p>虚引用【很少用】</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">References</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//强引用</span></span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//软引用</span></span><br><span class="line">        SoftReference softReference = <span class="keyword">new</span> SoftReference(object);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//弱引用</span></span><br><span class="line">        WeakReference weakReference = <span class="keyword">new</span> WeakReference(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-15-JVM堆内存分代模型？"><a href="#2-15-JVM堆内存分代模型？" class="headerlink" title="2.15 JVM堆内存分代模型？"></a>2.15 JVM堆内存分代模型？</h2><p>JVM堆内存的分代模型：年轻代、老年代；</p><p>大部分对象朝生夕死，少数对象长期存活；</p><p><img src="https://img-blog.csdnimg.cn/6814a9e209ec4beebc5c7b4f595071d2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>From Survivor区也叫S0区，To Survivor 也叫S1区</p><p>大小也可以通过参数去调整</p><h2 id="2-16-JVM堆中新生代的垃圾回收过程？☆☆☆☆"><a href="#2-16-JVM堆中新生代的垃圾回收过程？☆☆☆☆" class="headerlink" title="2.16 JVM堆中新生代的垃圾回收过程？☆☆☆☆"></a>2.16 JVM堆中新生代的垃圾回收过程？☆☆☆☆</h2><p><img src="https://img-blog.csdnimg.cn/bc2645bcf46742fe81a85eb407c70c24.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>JVM里垃圾回收针对的是 <strong>新生代，老年代，还有元空间/方法区（永久代）</strong>，</p><p>不会针对方法的栈帧进行回收，方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存里清理掉，也就是<strong>虚拟机栈不存在垃圾回收</strong>；</p><p>代码里创建出来的对象，一般就是两种：</p><p>1、一种是短期存活的，分配在Java堆内存之后，迅速使用完就会被垃圾回收；</p><p>2、一种是长期存活的，需要一直生存在Java堆内存里，让程序后续不停的去使用；</p><p>第一种短期存活的对象，是在Java堆内存的新生代里分配；</p><p>第二种长期存活的对象，通过在新生代S0区和S1区来回被垃圾回收15次后，进入Java堆内存的老年代中，这里的15次，我们也称为对象的年龄，即对象的年龄为15岁；</p><p>java -XX:+PrintFlagsFinal 打印jvm默认参数值；</p><blockquote><p>总结：<strong>垃圾回收针对的是堆和元空间</strong></p></blockquote><p><strong>过程详解：</strong></p><p>新创建的对象先进Eden空间，满了后，再就触发Minor GC就会去回收Eden区域里面的对象，这里面有些需要存活、有些需要回收，先把要存活的移到From Survivor区域，把要回收的对象清除掉。<br><img src="https://img-blog.csdnimg.cn/870f4346c35c43068d98a8f2ab22194b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第二轮：当Eden区域第二次再满的时候，这时又要出发Minor GC，这时候处理回收的就是Eden和S0两个区域的对象了</p><p>先将不能回收的对象移到S1区域，把要回收的对象清空掉，此时Eden区域空闲了。<br><img src="https://img-blog.csdnimg.cn/18ee3ee769424e268e2d65fa5ad9163a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后再处理S0区域中的对象，把要回收的清除，要存活的移到S1区域。<br><img src="https://img-blog.csdnimg.cn/1094d8f91e724c72b2bab0d1659a4d2b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3f6349966c7b44a6a71263e21297d05f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>第三轮：当Eden区域再次满载状态时，再次触发Minor GC，这时处理的就是已满的Eden以及S1区域，先处理Eden：将回收的清除，需要存活的移至S0，针对S1区域做同理操作。<br><img src="https://img-blog.csdnimg.cn/7baf9572459f44568b4f5e697b067125.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4d5adeb8062b4b7eb384c5c2e5f883a2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>然后再回收S1区域的对象，其中不能回收的移到S0区域，要回收的清除掉。<br><img src="https://img-blog.csdnimg.cn/5cf03084c84740008af73897fa365c3f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">如此，循环往复，已存在于S0、S1的对象经过Minor GC后，要继续存活的就移到另一个区域(S0 or S1)，要回收的清除即可，要回收的对象就会在S0、S1两个区域中间来回移动，当移动的次数大于15次后，那之后就放进老年代，表示这个对象是需要长期存活的对象。</p><p>在中间每次清理S0、S1后，每次处理后都会有一个是空闲状态的，下一次把需要存活的移到空闲的区域</p><p><strong>年龄阈值</strong></p><p>关于年龄阈值，如果是并行GC，默认值是15，如果是CMS垃圾处理器的，就是6，详细可以看官方文档：</p><p>一般不指定垃圾处理器，那就是并行的，所以默认15次</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC</a></p><p><img src="https://img-blog.csdnimg.cn/656d20e0fc544965af0f785bf29deca9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以执行命令来看JVM的默认参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal 打印jvm默认参数值；</span><br></pre></td></tr></table></figure><h2 id="2-17-JVM对象动态年龄判断是怎么回事？☆☆☆"><a href="#2-17-JVM对象动态年龄判断是怎么回事？☆☆☆" class="headerlink" title="2.17 JVM对象动态年龄判断是怎么回事？☆☆☆"></a>2.17 JVM对象动态年龄判断是怎么回事？☆☆☆</h2><p>虚拟机<strong>并不是永远</strong>地要求对象的年龄必须达到了MaxTenuringThreshold=15才能晋升老年代；</p><p><strong>结论</strong><br>动态年龄判断：Survivor区的对象年龄从小到大进行累加，当累加到X年龄（某个年龄）时占用空间的总和大于50%（可以使用-XX:TargetSurvivorRatio=? 来设置保留多少空闲空间，默认值是50），那么比X年龄大的对象都会晋升到老年代；</p><p>1、Survivor区分布如下图：</p><p>这里是三轮后的的一个分布结果<br><img src="https://img-blog.csdnimg.cn/642f3d684c4f40f9b82a341303c2d2f1.png" alt="在这里插入图片描述"></p><blockquote><p>解释：也就是还有45%的对象还在存活，只要大于50%，才会触发动态年龄判断</p></blockquote><p>2、此时新生代GC后，有6%的对象进入Survivor区，Survivor区分布如下图：<br><img src="https://img-blog.csdnimg.cn/292de29e8215408a814dbad57aae85c0.png" alt="在这里插入图片描述"><br>这时从1岁加到4岁时,总和51% 大于50%，但此时没有大于四岁的对象，即没有对象晋升</p><blockquote><p>解释：动态年龄判断是在大于50%后触发，然后针对的是50%以后的大年龄对象，也就是4岁以后的，5岁 6岁…此处没有</p></blockquote><p>3、又经过一次新生代GC后，有40%的对象进入Survivor区，Survivor区分布如下图：<br><img src="https://img-blog.csdnimg.cn/05aab638f83447baa0ceaf497fa4b74c.png" alt="在这里插入图片描述"><br>Survivor区的对象年龄从小到大进行累加，当累加到 3 年龄时的总和大于50%，那么比3大的都会晋升到老年代，即<strong>4岁的20%、5岁的20%晋升到老年代</strong>；</p><blockquote><p>总结：并不是严格的到了15岁，就会到达老年代，也有动态年龄判断机制！</p></blockquote><h2 id="2-18-什么是老年代空间分配担保机制"><a href="#2-18-什么是老年代空间分配担保机制" class="headerlink" title="2.18 什么是老年代空间分配担保机制"></a>2.18 什么是老年代空间分配担保机制</h2><p><img src="https://img-blog.csdnimg.cn/016cc3b2804c45188544b456bfdb6ae7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>Eden：800m –&gt;300m</p><p>S0：100m</p><p>S1：100m</p><p>老年代：1000m，剩350m、200m</p><p>新生代Minor GC后剩余存活对象太多，无法放入Survivor区中，此时就必须将这些存活对象直接转移到老年代去，如果此时老年代空间也不够怎么办？</p><p>1、执行任何一次Minor GC之前，JVM会先检查一下老年代可用内存空间，是否大于新生代所有对象的总大小，因为在极端情况下，可能新生代Minor GC之后，新生代所有对象都需要存活，那就会造成新生代所有对象全部要进入老年代；</p><p>2、如果老年代的可用内存大于新生代所有对象总大小，此时就可以放心大胆的对新生代发起一次Minor GC，因为Minor GC之后即使所有对象都存活，Survivor区放不下了，也可以转移到老年代去； </p><p>3、如果执行Minor GC之前，检测发现老年代的可用空间已经小于新生代的全部对象总大小，那么就会进行下一个判断，判断老年代的可用空间大小，是否大于之前每一次Minor GC后进入<strong>老年代的对象的平均大小</strong>，如果判断发现老年代的内存大小，大于之前每一次Minor GC后进入老年代的对象的平均大小，那么就是说可以冒险<strong>尝试一下Minor GC</strong>，但是此时真的可能有风险，那就是Minor GC过后，剩余的存活对象的大小，大于Survivor空间的大小，也大于老年代可用空间的大小，老年代都放不下这些存活对象了，此时就会触发一次“Full GC”； </p><p>所以老年代空间分配担保机制的目的？也是为了<strong>避免频繁进行Full GC</strong>；</p><p>4、如果Full GC之后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致“OOM”内存溢出 ；</p><p>在JDK6的时候有一个参数-XX:+HandlePromotionFailure用于开启是否要进行空间担保;</p><blockquote><p>解释：</p><p>简单来说，就是往老年代放对象的时候，这个空间够不够，有一个担保机制。</p><p>当Eden新生代区域装满对象后，触发Minor GC，这里的核心在于做一个判断：</p><p>判断老年代的可用空间能不能大于新生代的对象大小总和，（这里相当于假设新生代对象全部都不可回收 并且S0 S1也不够，那么就得往老年代里面放，如果老年代可以全覆盖了，说明可以直接Minor GC，是没有OOM风险的）；如果老年代空间不足以覆盖全部新生代对象，那么就再作第二个判断：看历史往老年代放对象的平均大小和老年代的可用空间做比较(这里相当于是个评估，用历史平均去预算一下，但是也可能这一次比历史平均的都大，那么最终还得Full GC，Full GC指的是对老年代做回收，如果仍然不够则OOM)，这样的目的还是为了避免Full GC</p></blockquote><p><img src="https://img-blog.csdnimg.cn/034ec2ed49e84d10a32b1037e7e6172b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>核心关键：</strong><br>避免频繁的Full GC，所以每次判断都是先尽量走Minor GC，实在不行再Full GC。</p><h2 id="2-19-什么情况下对象会进入老年代？"><a href="#2-19-什么情况下对象会进入老年代？" class="headerlink" title="2.19 什么情况下对象会进入老年代？"></a>2.19 什么情况下对象会进入老年代？</h2><p>1、躲过15次GC之后进入老年代，可通过JVM参数“-XX:MaxTenuringThreshold”来设置年龄，默认为15岁；</p><p>2、动态对象年龄判断；</p><p>3、老年代空间担保机制；</p><p>4、<strong>大对象直接进入老年代</strong>；</p><p>大对象是指需要大量连续内存空间的Java对象，比如很长的字符串或者是<strong>很大的数组或者List集合</strong>，大对象在分配空间时，容易导致内存明明还有不少空间时就提前触发垃圾回收以获得足够的连续空间来存放它们，而当复制对象时，大对象又会引起<strong>高额的内存复制开销，</strong>为了避免新生代里出现那些大对象，然后屡次躲过GC而进行来回复制，此时JVM就直接把该大对象放入老年代，而不会经过新生代；</p><p>我们可以通过JVM参数“-XX:PretenureSizeThreshold”设置多大的对象直接进入老年代，该值为字节数，比如“1048576”字节就是1MB，该参数表示如果创建一个大于这个大小的对象，比如一个超大的数组或者List集合，此时就直接把该大对象放入老年代，而不会经过新生代； </p><p>-XX:PretenureSizeThreshold参数只对Serial和ParNew两款新生代收集器有效，其他新生代垃圾收集器不支持该参数，如果必须使用此参数进行调优，可考虑 ParNew+CMS的收集器组合；</p><blockquote><p>解释：对于大对象来说，一般大概率是不会被回收的，那么如果在S0和S1区域来回的移动，这样的内存开销是很大的，为了避免这一个巨大开销，就直接将过大的对象直接放入到老年代中存储</p></blockquote><h2 id="2-20-JVM运行时数据区-元空间的特点及作用？"><a href="#2-20-JVM运行时数据区-元空间的特点及作用？" class="headerlink" title="2.20 JVM运行时数据区 元空间的特点及作用？"></a>2.20 JVM运行时数据区 元空间的特点及作用？</h2><p>1、在JDK1.8开始才出现元空间的概念，之前叫方法区/永久代；</p><p>2、元空间与Java堆类似，是线程共享的内存区域；</p><p>3、<strong>存储被加载的类信息、常量、静态变量、常量池、即时编译后的代码等数据</strong>；</p><p>4、元空间采用的是本地内存，本地内存有多少剩余空间，它就能扩展到多大空间，也可以设置元空间大小；</p><p>-XX:MetaspaceSize=20M -XX:MaxMetaspaceSize=20m</p><p>5、元空间很少有GC垃圾收集，一般该区域回收条件苛刻，能回收的信息比较少，所以GC很少来回收；</p><p>6、元空间内存不足时，将抛出OutOfMemoryError；</p><blockquote><p>解释：</p><p>jdk1.8前都叫方法区，目前都叫元空间，这个区域和堆是并列的，也属于线程共享的内存区域，其存储的主要是类的信息，静态变量、常量等等一系列静态的量，比如下图，类加载后，类的信息就会存储在元空间中；</p><p>元空间的内存是不需要垃圾回收的，能回收的信息比较少</p><p>当元空间内存不足时候也会报OOM</p><p>元空间的大小占用的是本地内存，所以本地内存还剩多少，就可以给它扩展到多少，一般来说都是绝对足够的</p></blockquote><p> <img src="https://img-blog.csdnimg.cn/53665f46da0e434687e874ea7e83afe3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>测试元空间溢出</strong></p><p>这里采用了动态代理方式，来不断的创建类到元空间中</p><p>死循环，这里当超出了内存大小后就会溢出，如果不设置参数的话，就是根据机器剩余的内存来扩展，这时候需要等待很久才会溢出，如下图修改元空间大小参数，大小设置为20m，会马上内存溢出：</p><p><img src="https://img-blog.csdnimg.cn/e79ae98560b44d228a49e2e0a243f23a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/19ac30138e4d497089b0c551074be655.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元空间溢出测试</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaSpace</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);<span class="comment">//缓存</span></span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> methodProxy.invokeSuper(o, objects);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建动态代理类class</span></span><br><span class="line">            UserService userService = (UserService)enhancer.create();</span><br><span class="line">            userService.find();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"创建了"</span> + (++counter) + <span class="string">"个动态代理对象"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"UserService类加载......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"find......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-21-JVM本机直接内存的特点及作用？"><a href="#2-21-JVM本机直接内存的特点及作用？" class="headerlink" title="2.21 JVM本机直接内存的特点及作用？"></a>2.21 JVM本机直接内存的特点及作用？</h2><p>1、直接内存（Direct Memory）不属于JVM运行时数据区，是本机直接物理内存；</p><p>2、像在JDK 1.4中新加入了NIO（New Input/Output）类，一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的 DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据；</p><p>3、可能导致OutOfMemoryError异常出现； netty</p><h2 id="2-22-JVM本机直接内存溢出问题？"><a href="#2-22-JVM本机直接内存溢出问题？" class="headerlink" title="2.22 JVM本机直接内存溢出问题？"></a>2.22 JVM本机直接内存溢出问题？</h2><p><strong>直接内存（Direct Memory）</strong> 的容量大小可通过-XX:MaxDirectMemorySize参数来指定，该参数表示设置新I / O（java.nio程序包）直接缓冲区分配的最大总大小（以字节为单位）;默认情况下，大小设置为0，这意味着JVM自动为NIO直接缓冲区分配选择大小；</p><p>由直接内存导致的内存溢出，<strong>无法生成Heap Dump文件</strong>，如果程序中直接或间接使用了NIO技术，那就可以重点考虑检查一下直接内存方面的原因；</p><p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dev/heapdump.hprof</p><blockquote><p>解释</p><ol><li><p>如果想输出原因文件，则要输入JVM参数XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dev/heapdump.hprof</p></li><li><p>测试NIO的直接内存溢出：</p></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectBufferOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        List&lt;ByteBuffer&gt; buffers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</span><br><span class="line">            buffers.add(byteBuffer);</span><br><span class="line">            System.out.println(count++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报直接内存溢出(物理内存)</p><p> <img src="https://img-blog.csdnimg.cn/38e79a5bd5ca40aeba133f00e707e012.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>修改直接内存参数<br><img src="https://img-blog.csdnimg.cn/1eadedc438334164bf0b84758a0fd24e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4728feee8d2f4b81acd1bd3d3918cc0d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>如果想输出原因文件，则要输入JVM参数XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/dev/heapdump.hprof</p><ol><li>先配置</li><li>运行程序，报Direct buffer memory错误</li><li>发现在D:/dev/下没有生成heapdump.hprof文件</li></ol><p>这个步骤可以用来<strong>排查出是直接内存</strong>溢出，再进一步考虑是否直接或者间接的使用到了NIO技术</p><h2 id="2-23-几个与JVM内存相关的核心参数？"><a href="#2-23-几个与JVM内存相关的核心参数？" class="headerlink" title="2.23 几个与JVM内存相关的核心参数？"></a>2.23 几个与JVM内存相关的核心参数？</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-Xms Java堆内存的大小；</span><br><span class="line">-Xmx Java堆内存的最大大小；</span><br><span class="line"></span><br><span class="line">-Xmn Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小；</span><br><span class="line"></span><br><span class="line">-XX:MetaspaceSize 元空间大小；</span><br><span class="line"></span><br><span class="line">-XX:MaxMetaspaceSize 元空间最大大小；</span><br><span class="line"></span><br><span class="line">-Xss 每个线程的栈内存大小；</span><br><span class="line"></span><br><span class="line">-XX:SurvivorRatio&#x3D;8 设置eden区 和survivor 区大小的比例，默认是8:1:1；</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;5 年龄阈值；</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC 指定CMS垃圾收集器；</span><br><span class="line"></span><br><span class="line">-XX:+UseG1GC 指定使用G1垃圾回收器</span><br></pre></td></tr></table></figure><p>–查看默认的堆大小及默认的垃圾收集器</p><p>java -XX:+PrintCommandLineFlags -version</p><h2 id="2-24-查看一个对象的大小"><a href="#2-24-查看一个对象的大小" class="headerlink" title="2.24 查看一个对象的大小"></a>2.24 查看一个对象的大小</h2><p>导入Lucene库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.lucene<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lucene-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">//1024kb = 1m</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      Order order = <span class="keyword">new</span> Order();</span><br><span class="line">      <span class="comment">//计算指定对象及其引用树上所有对象的综合大小，单位字节</span></span><br><span class="line">      <span class="keyword">long</span> size = RamUsageEstimator.sizeOf(order);</span><br><span class="line">      <span class="comment">//计算指定对象及其引用树上所有对象的综合大小，返回可读的结果，如：2KB</span></span><br><span class="line">      String humanSize = RamUsageEstimator.humanSizeOf(order);</span><br><span class="line">      </span><br><span class="line">      System.out.println(size);</span><br><span class="line">      System.out.println(humansize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/e5b64d5d802d489ca62aeb2e03760e28.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二、深入剖析JVM内存管理&quot;&gt;&lt;a href=&quot;#二、深入剖析JVM内存管理&quot; class=&quot;headerlink&quot; title=&quot;二、深入剖析JVM内存管理&quot;&gt;&lt;/a&gt;二、深入剖析JVM内存管理&lt;/h1&gt;&lt;h2 id=&quot;2-1-Java代码到底是如何运行起来的？</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="JAVA虚拟机" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>深入理解JVM【JVM类加载机制】</title>
    <link href="https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM/"/>
    <id>https://ericzikun.github.io/2021/11/06/deep11-%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E9%80%90%E6%AD%A5%E7%90%86%E8%A7%A3JVM/</id>
    <published>2021-11-06T07:55:12.000Z</published>
    <updated>2021-11-06T08:22:24.123Z</updated>
    
    <content type="html"><![CDATA[<p>概述：</p><ul><li>JVM类加载机制</li><li>深入剖析JVM内存管理</li><li>JVM垃圾回收机制</li><li>JVM故障诊断性能调优</li></ul><h1 id="一、JVM类加载机制"><a href="#一、JVM类加载机制" class="headerlink" title="一、JVM类加载机制"></a>一、JVM类加载机制</h1><h2 id="1-1-Java运行时一个类是什么时候被加载的？"><a href="#1-1-Java运行时一个类是什么时候被加载的？" class="headerlink" title="1.1 Java运行时一个类是什么时候被加载的？"></a>1.1 Java运行时一个类是什么时候被加载的？</h2><p>一个类在什么时候开始被加载，《Java虚拟机规范》中并没有进行强制约束，交给了虚拟机自己去自由实现，HotSpot虚拟机是按需加载，在需要用到该类的时候加载这个类；</p><p>1、Sun公司最早的 Classic虚拟机；</p><p>2、Sun/Oracle公司的HotSpot虚拟机；</p><p>3、BEA公司的JRockit虚拟机；</p><p>4、IBM公司的IBM J9虚拟机；</p><p>官方：<a href="https://docs.oracle.com/javase/8/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/</a> </p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>-XX:+TraceClassLoading</p><p>测试类的详细载入：</p><p> <img src="https://img-blog.csdnimg.cn/5bd24ce438114ca6931b59bb58529a42.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/2e6b46a24d774bd1bdc32c2d084e0dd3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/d43ad7b91ce94a3ebfb0e9137c23ee83.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-2-JVM一个类的加载过程？"><a href="#1-2-JVM一个类的加载过程？" class="headerlink" title="1.2 JVM一个类的加载过程？"></a>1.2 JVM一个类的加载过程？</h2><p>一个类从加载到jvm内存，到从jvm内存卸载，它的整个生命周期会经历7个阶段：</p><p>1、加载（Loading）</p><p>2、验证（Verification）</p><p>3、准备（Preparation）</p><p>4、解析（Resolution）</p><p>5、初始化（Initialization）</p><p>6、使用（Using）</p><p>7、卸载（Unloading）</p><p>其中验证、准备、解析三个阶段统称为连接（Linking）；<br><img src="https://img-blog.csdnimg.cn/13fa5bffb22047db8449f3846761b42e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>加载：</strong> classpath、jar包、网络、某个磁盘位置下的类的class二进制字节流读进来，在内存中生成一个代表这个类的java.lang.Class对象放入元空间，此阶段我们程序员可以干预，我们可以自定义类加载器来实现类的加载；</p><p><strong>验证：</strong> 验证Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证虚拟机的安全；</p><p><strong>准备：</strong> 类变量赋默认初始值，int为0，long为0L，boolean为false，引用类型为null；常量赋正式值；</p><p><strong>解析：</strong> 把符号引用翻译为直接引用；</p><p><strong>初始化：</strong> 当我们new一个类的对象，访问一个类的静态属性，修改一个类的静态属性，调用一个类的静态方法，用反射API对一个类进行调用，<strong>初始化当前类，其父类也会被初始化</strong>…… 那么这些都会触发类的初始化；</p><p><strong>使用：</strong> 使用这个类；</p><p><strong>卸载：</strong></p><p>1.该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例；</p><p>2.加载该类的ClassLoader已经被GC； （ClassLoader：类加载器，用于加载class）</p><p>3.该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法；</p><p><strong>准备阶段：</strong></p><p>​    对于final常量来说，准备阶段直接赋值a为123，对于类变量，是在类初始化（new）的时候才会进行赋值，所以先赋0，而对于实例变量abc来说，也是先赋0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123; <span class="comment">// java.lang.Class</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">222</span>;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"sdfsdf"</span>; <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> abc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -XX:+TraceClassLoading 监控类的加载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.working();</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解析阶段：</p><p>把一个类的class文件读进来之后，变成java.lang.class对象，在元空间里面</p></blockquote><h2 id="1-3一个类被初始化的过程？☆☆☆"><a href="#1-3一个类被初始化的过程？☆☆☆" class="headerlink" title="1.3一个类被初始化的过程？☆☆☆"></a>1.3一个类被初始化的过程？☆☆☆</h2><p><img src="https://img-blog.csdnimg.cn/b81a91c6b2e745eba65d3991c8d1eef5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>类的初始化阶段，Java虚拟机才真正开始执行类中编写<strong>Java程序代码</strong>；</p><p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，</p><p>而在初始化阶段，才真正初始化类变量和其他资源；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态常量  ==准备</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String staticConstantField = <span class="string">"静态常量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量 ==准备阶段赋值为 null，初始化阶段赋值为 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticField = <span class="string">"静态变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量 == 创建对象的时候赋值</span></span><br><span class="line">    <span class="keyword">public</span> String field = <span class="string">"变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块 ==初始化阶段执行</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(staticConstantField);</span><br><span class="line">        System.out.println(staticField);</span><br><span class="line">        System.out.println(<span class="string">"静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块 == 创建对象的时候执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">"初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器 == 创建对象的时候执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java Test02</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test02();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、rt.jar charset.jar</span></span><br><span class="line">        <span class="comment">// 2、InitialOrderTest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证初始化：</p><ol><li>当main方法中new对象时，执行空：<br><img src="https://img-blog.csdnimg.cn/b904b3f0c0ac458da6908208327572f4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>此时会执行静态代码块中的语句，同时静态常量、静态变量都得到了初始化，所以main方法执行后，会初始化Test02类中的静态常量、静态变量、静态代码块</li></ol><ol start="2"><li>main中new Test02对象时：<br><img src="https://img-blog.csdnimg.cn/cf00cf501e374fa9bf1a8c9af9501425.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>同样也会先初始化Test02中的静态常量、静态变量、静态代码块，和第一个验证一致，其次再去初始化类的成员变量、代码块、构造方法</li></ol><h2 id="1-4-继承时父子类的初始化顺序是怎样的？"><a href="#1-4-继承时父子类的初始化顺序是怎样的？" class="headerlink" title="1.4 继承时父子类的初始化顺序是怎样的？"></a>1.4 继承时父子类的初始化顺序是怎样的？</h2><p>父类–静态变量</p><p>父类–静态初始化块</p><p>子类–静态变量</p><p>子类–静态初始化块</p><p>父类–变量</p><p>父类–初始化块</p><p>父类–构造器</p><p>子类–变量</p><p>子类–初始化块</p><p>子类–构造器</p><p>父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String p_StaticField = <span class="string">"父类--静态变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">public</span> String p_Field = <span class="string">"父类--变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(p_StaticField);</span><br><span class="line">        System.out.println(<span class="string">"父类--静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(p_Field);</span><br><span class="line">        System.out.println(<span class="string">"父类--初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParentClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"父类--构造器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">", j="</span> + j);</span><br><span class="line">        i = <span class="number">1</span>; j = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String s_StaticField = <span class="string">"子类--静态变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量</span></span><br><span class="line">    <span class="keyword">public</span> String s_Field = <span class="string">"子类--变量"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(s_StaticField);</span><br><span class="line">        System.out.println(<span class="string">"子类--静态初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(s_Field);</span><br><span class="line">        System.out.println(<span class="string">"子类--初始化块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChildClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"子类--构造器"</span>);</span><br><span class="line">        System.out.println(<span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 程序入口 java ChildClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ChildClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试验证：</p><ol><li><p>main方法中不执行任何语句：<br><img src="https://img-blog.csdnimg.cn/85865c3977de490c9c7d1144bb0fcc10.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当在子类的main中执行时，会先初始化父类的静态变量+静态代码块，然后再初始化子类的静态变量+静态代码块</p></li><li><p>main方法中new子类对象时：<br><img src="https://img-blog.csdnimg.cn/da506d9c8bd349e9bcc61a301ffde44d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>前面的依旧，先初始化父类子类的静态变量、静态代码块，然后由于new了子类，所以还会先执行父类的成员变量、代码块、构造器，再执行子类的成员变量、代码块、构造器。</p></li><li><p>如果在子类main中new父类对象<br><img src="https://img-blog.csdnimg.cn/003ee5bee17c42ca9300c6b2addc1d85.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>结果可想而知，由于是子类的main，会先初始化父类子类静态变量、静态代码块，然后由于new了父类，所以还会初始化父类的成员变量、代码块、构造器</p></li></ol><h2 id="1-5-究竟什么是类加载器？"><a href="#1-5-究竟什么是类加载器？" class="headerlink" title="1.5 究竟什么是类加载器？"></a>1.5 究竟什么是类加载器？</h2><p><img src="https://img-blog.csdnimg.cn/ebe3963d9cb549828b27307c07336cdf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在类“加载”阶段，通过一个类的全限定名来获取描述该类的二进制字节流的这个动作的“代码”被称为“类加载器”（Class Loader），这个 <strong>动作是可以自定义实现</strong> 的；</p><p>类加载器可以由C++、Java语言实现</p><p><strong>简单来说，就是把.class文件以二进制形式读进来</strong></p><h2 id="1-6-JVM有哪些类加载器？"><a href="#1-6-JVM有哪些类加载器？" class="headerlink" title="1.6 JVM有哪些类加载器？"></a>1.6 JVM有哪些类加载器？</h2><p>站在Java虚拟机的角度来看，只存在两种不同的类加载器：</p><p>1、启动类加载器（Bootstrap ClassLoader），使用C++语言实现，是虚拟机自身的一部分；</p><p>2、其他所有的类加载器，由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader；</p><p>站在Java开发者的角度来看，自JDK 1.2开始，Java一直保持着三层类加载器架构；<br><img src="https://img-blog.csdnimg.cn/30454650ccfb4aeb9bad631755a2d745.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-7-JVM中不同的类加载器加载哪些文件？"><a href="#1-7-JVM中不同的类加载器加载哪些文件？" class="headerlink" title="1.7 JVM中不同的类加载器加载哪些文件？"></a>1.7 JVM中不同的类加载器加载哪些文件？</h2><p>1、启动类加载器（Bootstrap ClassLoader）：（根的类加载器）C++语言实现的，在java中通过getClassLoader方法是获取不到的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;JAVA_HOME&gt;\jre\lib\rt.jar，resources.jar、charsets.jar</span><br><span class="line"></span><br><span class="line">被-Xbootclasspath参数所指定的路径中存放的类库；</span><br></pre></td></tr></table></figure><p>2、扩展类加载器（Extension ClassLoader）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sun.misc.Launcher$ExtClassLoader，</span><br><span class="line"></span><br><span class="line">&lt;JAVA_HOME&gt;\jre\lib\ext，</span><br><span class="line"></span><br><span class="line">被java.ext.dirs系统变量所指定的路径中所有的类库；</span><br></pre></td></tr></table></figure><p>3、应用程序类加载器（Application ClassLoader）：系统的类加载器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader</span><br><span class="line"></span><br><span class="line">加载用户类路径（ClassPath）上所有的类库；</span><br></pre></td></tr></table></figure><blockquote><p>测试验证：</p></blockquote><p>比如在</p><ul><li><p><JAVA_HOME>\jre\lib\rt.jar下找到一个类BufferReader类，查看其classLoader，为空，由于是c++语言编写的，所以Java中获取不到，是正常的；</p><p>输出为null则表明<strong>根的类加载器</strong></p></li></ul><p><img src="https://img-blog.csdnimg.cn/38a1011b414d4e08a616e481e7cb6f79.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>AppClassLoader，包括自己写的代码以及项目中涉及到的第三方jar包（如Springboot）<br><img src="https://img-blog.csdnimg.cn/84656823250941ce9128e7b206304cbc.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>继承结构：<br><img src="https://img-blog.csdnimg.cn/b935dacc92ad46c49fc9a53da03119b6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="1-8-JVM三层类加载器之间的关系是继承吗？"><a href="#1-8-JVM三层类加载器之间的关系是继承吗？" class="headerlink" title="1.8 JVM三层类加载器之间的关系是继承吗？"></a>1.8 JVM三层类加载器之间的关系是继承吗？</h2><img src="https://img-blog.csdnimg.cn/89bda791bb7e4bd08962b8042fc80e3b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>不是继承关系。</li></ul><p>解释：<br><img src="https://img-blog.csdnimg.cn/2bccbcf820094c25a44338b7f9da2292.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/b1c78fa1a84f44038119bdb37527e16b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7f9a344f09134651b3e479ca0b70a9ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2f33361c23e04775b0519a8fb63d9156.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>换个角度思考这个问题，前面提到过BootstrapClassLoader是C++语言实现的，ExtClassLoader是Java实现的，怎么可能继承呢？</p><p>如果我们自定义一个类加载器，那么则是继承共同的父类ClassLoader(抽象类)</p><h2 id="1-9-JVM类加载的双亲委派模型-☆☆☆"><a href="#1-9-JVM类加载的双亲委派模型-☆☆☆" class="headerlink" title="1.9 JVM类加载的双亲委派模型 ☆☆☆"></a>1.9 JVM类加载的双亲委派模型 ☆☆☆</h2><p><img src="https://img-blog.csdnimg.cn/9ff291a01cf941ef812669baa1d7a41f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>官方描述：</strong></p><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当上一层类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到这个类）时，下一层类加载器才会尝试自己去加载；</p><blockquote><p><strong>过程分析：</strong></p><p>如：我要加载String这个类，来自rt.jar,首先让App ClassLoader去加载，但它自己不加载，委派给上一层加载，ExtClassLoader也不去加载，再继续委派给Bootstrap ClassLoader，再往上就没有了，那么此时BootstrapClassLoader就要去尝试加载，它主要是加载jre下内部库的jar包，而String这个类正好在rt.jar中，所以就return了，从而把String这个类加载到JVM内存中了。</p></blockquote><blockquote><p>当BootstrapClassLoader加载内库后，找不到所要加载的类，那么就让第二层ExtClassLoader去尝试加载，找得到就return，找不到就继续让AppClassLoader去加载后找。</p><p>当这个类几个类加载器都找不到时，报ClassNotFoundException</p><p>解释一下为啥叫双亲：因为AppClassLoader上面有两层，所以叫双亲</p><p>总结：先自底向上委派，再自顶向下去尝试加载</p></blockquote><h2 id="1-10-JDK为什么要设计双亲委派模型，有什么好处？"><a href="#1-10-JDK为什么要设计双亲委派模型，有什么好处？" class="headerlink" title="1.10 JDK为什么要设计双亲委派模型，有什么好处？"></a>1.10 JDK为什么要设计双亲委派模型，有什么好处？</h2><p>1、确保安全，避免Java核心类库被修改；</p><p>2、避免重复加载；</p><p>3、保证类的唯一性；</p><p>如果你写一个jaa.lang.String的类去运行，发现会抛出如下异常；</p><p>解释：</p><p> 比如即使自己写了个String类，也不会被加载，因为最先会加载rt.jar下的String，能够避免核心内库被修改，要保证安全。<br> <img src="https://img-blog.csdnimg.cn/fb14a61393854f4fa0828b5f99db626f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/01b32ddb909044a88ca3e70d7ad9999a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>自定义的包理论上是最终被APPClassLoader去加载的，但是这里为啥会报错，是因为包和核心内库重名了，所以报安全异常</p><h2 id="1-11-可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？"><a href="#1-11-可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？" class="headerlink" title="1.11 可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？"></a>1.11 可以打破JVM双亲委派模型吗？如何打破JVM双亲委派模型？</h2><p>可以；</p><p>想要打破这种模型，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可；</p><h2 id="1-12-如何自定义自己的类加载器？"><a href="#1-12-如何自定义自己的类加载器？" class="headerlink" title="1.12 如何自定义自己的类加载器？"></a>1.12 如何自定义自己的类加载器？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、继承ClassLoader</span><br><span class="line">2、覆盖findClass(String name)方法 或者 loadClass() 方法；</span><br></pre></td></tr></table></figure><p>findClass(String name)方法 不会打破双亲委派；</p><p>loadClass() 方法 可以打破双亲委派（如何去加载可以自己去实现）；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义ClassLoader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span></span><br><span class="line">        <span class="comment">//name = 包名 + 类名</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// User.class</span></span><br><span class="line">            String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">            InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">            <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            is.read(b);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line"></span><br><span class="line">        Class clazz = myClassLoader.findClass(<span class="string">"com.bjpowernode.loader.User"</span>);</span><br><span class="line">        System.out.println(clazz.getClassLoader());</span><br><span class="line">        Object instance = clazz.newInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line"></span><br><span class="line">        System.out.println(User<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>())</span>;</span><br><span class="line">        Class claz2 = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Object o2 = claz2.newInstance();</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来com.bjpowernode.loader.User应该去AppClassLoader中加载的，但由于自定义了myClassLoader，并调用了findClass方法，所以会使用自定义的方法去加载。</p><p><img src="https://img-blog.csdnimg.cn/0b3754f67b0c4c15a6f33ed513605403.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-13-ClassLoader中的loadClass-、findClass-、defineClass-区别？"><a href="#1-13-ClassLoader中的loadClass-、findClass-、defineClass-区别？" class="headerlink" title="1.13 ClassLoader中的loadClass()、findClass()、defineClass()区别？"></a>1.13 ClassLoader中的loadClass()、findClass()、defineClass()区别？</h2><p>loadClass() 就是主要进行类加载的方法，默认的双亲委派机制就实现在这个方法中；</p><p>findClass() 根据名称或位置加载.class字节码；</p><p>definclass() 把字节码转化为java.lang.Class；</p><p>1、当我们想要自定义一个类加载器的时候，并且想破坏双亲委派模型时，我们会重写loadClass()方法；</p><p>2、如果我们想定义一个类加载器，但是不想破坏双亲委派模型的时候呢？可以可以重写findClass方法()，findClass()方法是JDK1.2之后的ClassLoader新添加的一个方法，这个方法只抛出了一个异常，没有默认实现；</p><p>JDK1.2之后已不再提倡用户直接覆盖loadClass()方法，而是建议把自己的类加载逻辑实现到findClass()方法中；</p><p>因为覆盖即打破双亲委派，所以建议改findClass</p><p>所以，如果你想定义一个自己的类加载器，并且要遵守双亲委派模型，那么可以继承ClassLoader，并且在findClass()中实现你自己的加载逻辑即可；</p><blockquote><p>经典案例：Tomcat就打破了双亲委派机制</p></blockquote><h2 id="1-14-加载一个类采用Class-forName-和ClassLoader有什么区别"><a href="#1-14-加载一个类采用Class-forName-和ClassLoader有什么区别" class="headerlink" title="1.14 加载一个类采用Class.forName()和ClassLoader有什么区别"></a>1.14 加载一个类采用Class.forName()和ClassLoader有什么区别</h2><p><img src="https://img-blog.csdnimg.cn/f13857d9007a481b8a80a13c63409d6a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> Class.forName(<span class="string">"com.jvm.demo.loader.ChildClass"</span>)</span><br><span class="line">       </span><br><span class="line">     Class clazz = Test05.class.getClassLoader().loadClass("com.jvm.demo.loader.ChildClass")</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/7f6d9e55388c40669dbb6cae7585ee94.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/91d105129ccf47e893c53bfe3220b152.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>分析区别：<br>由此可见，ClassLoader这种方式，只经过了加载-&gt;链接，但是没有初始化，但是forName方式会初始化<br>如果继续对类实例化，则会初始化，并会创建对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test05</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  </span><br><span class="line">     Class clazz = Test05.class.getClassLoader().loadClass("com.jvm.demo.loader.ChildClass");</span><br><span class="line">    clazz.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/bcca71557c23441dbf196a7344a96128.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>看看两个方法底层实现：</p><p>forName底层会初始化类：</p><p>调用了一个本地C++方法<br><img src="https://img-blog.csdnimg.cn/21090b3adde84d84ab47d39e7ceffafb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>ClassLoader底层：</p><p>双亲委派类加载，没有对类进行初始化<br><img src="https://img-blog.csdnimg.cn/6446910b0afa4f88b61c9ee328a53227.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="1-15-了解Tomcat-的类加载机制"><a href="#1-15-了解Tomcat-的类加载机制" class="headerlink" title="1.15 了解Tomcat 的类加载机制"></a>1.15 了解Tomcat 的类加载机制</h2><p><img src="https://img-blog.csdnimg.cn/ec833dac95374d2bacc77b42dec35f0e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>可以看到，在原来的Java的类加载机制基础上，Tomcat新增了3个基础类加载器和每个Web应用的类加载器+JSP类加载器；</p><p>3个基础类加载器在 conf/catalina.properties 中进行配置：</p><p>common.loader=”${catalina.base}/lib”,”${catalina.base}/lib/<em>.jar”,”${catalina.home}/lib”,”${catalina.home}/lib/</em>.jar”<br> server.loader=<br> shared.loader=</p><p>Tomcat自定义了WebAppClassLoader类加载器，打破了双亲委派的机制，即如果收到类加载的请求，首先会尝试自己去加载，如果找不到再交给父加载器去加载，目的就是为了优先加载Web应用自己定义的类，我们知道ClassLoader默认的loadClass方法是以双亲委派的模型进行加载类的，那么Tomcat打破了这个规则，重写了loadClass方法，我们可以看到WebAppClassLoader类中重写了loadClass方法；</p><h2 id="1-16-有没有听说过热加载和热部署，如何自己实现一个热加载？"><a href="#1-16-有没有听说过热加载和热部署，如何自己实现一个热加载？" class="headerlink" title="1.16 有没有听说过热加载和热部署，如何自己实现一个热加载？"></a>1.16 有没有听说过热加载和热部署，如何自己实现一个热加载？</h2><p><strong>热加载</strong> 是指可以在不重启服务的情况下让更改的代码生效，热加载可以显著的提升开发以及调试的效率，它是基于Java的类加载器实现的，但是由于热加载的不安全性，一般不会用于正式的生产环境；</p><p><strong>热部署</strong> 是指可以在不重启服务的情况下重新部署整个项目，比如Tomcat热部署就是在程序运行时，如果我们修改了War包中的内容，那么Tomcat就会删除之前的War包解压的文件夹，重新解压新的War包生成新的文件夹；</p><p>1、热加载是在运行时重新加载class，后台会启动一个线程不断检测你的class是否发生改变；</p><p>2、热部署是在运行时重新部署整个项目，耗时相对较高；</p><p>如何实现热加载呢？</p><p>在程序代码更改且重新编译后，让运行的进程可以实时获取到新编译后的class文件，然后重新进行加载；</p><p><strong>重点步骤</strong></p><p>1、实现自己的类加载器；</p><p>2、从自己的类加载器中加载要热加载的类；</p><p>3、不断轮训要热加载的类class文件是否有更新，如果有更新，重新加载；</p><p>类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义一个类加载器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * bootstrap ClassLoader jdk/jre/目录下的jar包加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ext ClassLoader  jdk/ext/目录下的jar包加载</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * App ClassLoader --我们应用的ClassLoader</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> File classPathFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Class&gt; clazzCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="comment">//缓存 保存加载的类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String classPath = MyClassLoader.class.getResource("").getPath();</span><br><span class="line">        <span class="keyword">this</span>.classPathFile = <span class="keyword">new</span> File(classPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.findClass(name, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name, <span class="keyword">boolean</span> force) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//force是否强制加载</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//之前有没有加载过这个class</span></span><br><span class="line">        Class cls = clazzCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (force) &#123;</span><br><span class="line">            <span class="comment">//如果强制加载 则缓存值值为空，后面重新加载一遍</span></span><br><span class="line">            cls = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String className = MyClassLoader.class.getPackage().getName() + "." + name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个cls不为空则直接return了</span></span><br><span class="line">        <span class="keyword">if</span> (cls == <span class="keyword">null</span> &amp;&amp; classPathFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            File classFile = <span class="keyword">new</span> File(classPathFile + <span class="string">"\\"</span> + name.replaceAll(<span class="string">"\\."</span>, <span class="string">"/"</span>) + <span class="string">".class"</span>);</span><br><span class="line">            <span class="keyword">if</span> (classFile.exists()) &#123;</span><br><span class="line">                FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">                ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis = <span class="keyword">new</span> FileInputStream(classFile);</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4096</span>];</span><br><span class="line">                    bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                    <span class="keyword">int</span> len;</span><br><span class="line">                    <span class="keyword">while</span> ((len = fis.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                        bos.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">                    &#125;</span><br><span class="line">                    cls = defineClass(className, bos.toByteArray(), <span class="number">0</span>, bos.size());</span><br><span class="line">                    clazzCache.put(name, cls);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            fis.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(bos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            bos.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> clazzCache.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写一个定时任务去轮询：</p><p>观察狗 线程：</p><blockquote><p>思路：遍历文件，去拿到每个文件的时间，判断是否被修改，如果修改则重新触发加载类(自定义类加载器)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察狗</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchDog</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, FileDefine&gt; fileDefineMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WatchDog</span><span class="params">(Map&lt;String, FileDefine&gt; fileDefineMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileDefineMap = fileDefineMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.getClass().getResource(<span class="string">""</span>).getPath());</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File watchFile : files) &#123;</span><br><span class="line">            <span class="keyword">long</span> newTime = watchFile.lastModified();</span><br><span class="line">            FileDefine fileDefine = fileDefineMap.get(watchFile.getPath());</span><br><span class="line">            <span class="keyword">long</span> oldTime = fileDefine.getLastDefine();</span><br><span class="line">            <span class="comment">//如果文件被修改了,那么重新生成累加载器加载新文件</span></span><br><span class="line">            <span class="keyword">if</span> (newTime != oldTime) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件被修改......"</span>);</span><br><span class="line">                fileDefine.setLastDefine(newTime);</span><br><span class="line">                <span class="comment">//重新触发类加载</span></span><br><span class="line">                loadMyClass(watchFile.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadMyClass</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">            myClassLoader.findClass(className.replace(<span class="string">".class"</span>, <span class="string">""</span>), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;String, FileDefine&gt; fileDefineMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        File file = new File(Test.class.getResource("").getPath());</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File watchFile : files) &#123;</span><br><span class="line">            FileDefine fileDefine = <span class="keyword">new</span> FileDefine();</span><br><span class="line">            fileDefine.setLastDefine(watchFile.lastModified());</span><br><span class="line">            fileDefineMap.put(watchFile.getPath(), fileDefine);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定时任务</span></span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> WatchDog(fileDefineMap), <span class="number">3</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        MyClassLoader w = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Class clazz = w.findClass(<span class="string">"MyLog"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ILog myLog = (ILog) clazz.newInstance();</span><br><span class="line">                myLog.log();</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试其中一个修改类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLog</span> <span class="keyword">implements</span> <span class="title">ILog</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"log, version 1.0"</span>); 、</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处修改 System.out.println(“log, version 1.0”);为 System.out.println(“log, version 2.0”); 文件发生修改，但是要编译一下，点击build-&gt;Recompile ‘’MyLog.java’，那么轮询时就会发现文件的修改</p><p><img src="https://img-blog.csdnimg.cn/9fb916ae1aff4c37b5dba37591bd7dea.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAcG9wb2Z6aw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM类加载机制&lt;/li&gt;
&lt;li&gt;深入剖析JVM内存管理&lt;/li&gt;
&lt;li&gt;JVM垃圾回收机制&lt;/li&gt;
&lt;li&gt;JVM故障诊断性能调优&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;一、JVM类加载机制&quot;&gt;&lt;a href=&quot;#一、JVM类加载机</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="JAVA虚拟机" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/JAVA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="JVM" scheme="https://ericzikun.github.io/tags/JVM/"/>
    
    <category term="JAVA" scheme="https://ericzikun.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂云计算精髓MapReduce</title>
    <link href="https://ericzikun.github.io/2021/08/05/deep10-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%BA%91%E8%AE%A1%E7%AE%97%E7%B2%BE%E9%AB%93MapReduce/"/>
    <id>https://ericzikun.github.io/2021/08/05/deep10-%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%BA%91%E8%AE%A1%E7%AE%97%E7%B2%BE%E9%AB%93MapReduce/</id>
    <published>2021-08-05T03:06:47.000Z</published>
    <updated>2021-09-28T06:07:09.729Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MapReduce-简介"><a href="#MapReduce-简介" class="headerlink" title="MapReduce 简介"></a>MapReduce 简介</h1><p>核心思想：“分而治之”<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce思想在生活中处处可见。或多或少都曾接触过这种思想。MapReduce的思想核心 是“分而治之”，适用于大量复杂的任务处理场景(大规模数据处理场景)。</p><ul><li>Map负责——<strong>分</strong>，把复杂的任务分解为若干个“简单的任务”来并行处理。可以进行拆分的 前提是这些小任务可以并行计算，彼此间几乎没有<strong>依赖关系。</strong></li><li>Reduce负责——<strong>合</strong>，对map阶段的结果进行全局汇总。 MapReduce运行在yarn集群</li></ul><p>有两个阶段：</p><ol><li>ResourceManager</li><li>NodeManager</li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这两个阶段合起来正是MapReduce思想的体现。后面再细说这两个阶段。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce的执行流程用下面这张图一目了然：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简而言之：首先将一个文件分成n片小文件，对每个小部分做map处理，最后再reduce汇总计算结果到一起<br><img src="https://img-blog.csdnimg.cn/5e3af54cd8bd441b83d6973bada83f0f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中的Reduce操作这里画了两个，可能是在汇总计算操作时对不同类型的数据做汇总处理。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有一个比较形象的语言解释MapReduce: 我们要数图书馆中的所有书。你数1号书架，我数2号书架。这就是“Map”。我们人越多，数书<br>就更快。 现在我们到一起，把所有人的统计数加在一起。这就是“Reduce”。</p><h1 id="MapReduce-设计构思"><a href="#MapReduce-设计构思" class="headerlink" title="MapReduce 设计构思"></a>MapReduce 设计构思</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce是一个分布式运算程序的编程框架，核心功能是将用户编写的业务逻辑代码和自带默认组件整合成一个完整的分布式运算程序，并发运行在Hadoop集群上。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。 为程序员提供一个抽象和高层的编程接口和框架。程序员<strong>仅需要关心其应用层的具体计算问题</strong>，仅需编写少量的处理应用本身计算问题的程序代码。如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来,交给计算框架去处理:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Map和Reduce为程序员提供了一个清晰的操作接口抽象描述。MapReduce中定义了如下的Map 和Reduce两个抽象的编程接口，由用户去编程实现.Map和Reduce,MapReduce处理的数据类型是&lt;key,value&gt;键值对。</p><p>Map: (k1; v1) → [(k2; v2)]<br>Reduce: (k2; [v2]) → [(k3; v3)]</p><p>这里以wordcount来举例：</p><img src="https://img-blog.csdnimg.cn/e869575151bc4750a0b9c66664dd4158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>一个完整的mapreduce程序在分布式运行时有三类实例进程:</p><ol><li>MRAppMaster 负责整个程序的过程调度及状态协调 </li><li>MapTask 负责map阶段的整个数据处理流程</li><li>ReduceTask 负责reduce阶段的整个数据处理流程</li></ol><img src="https://img-blog.csdnimg.cn/b44ab181fd084ebe9fe72ebb01f75140.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>总结：记住两点：必须由ResourceManager来接受计算任务并资源分配，由App Master来执行具体任务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MapReduce-简介&quot;&gt;&lt;a href=&quot;#MapReduce-简介&quot; class=&quot;headerlink&quot; title=&quot;MapReduce 简介&quot;&gt;&lt;/a&gt;MapReduce 简介&lt;/h1&gt;&lt;p&gt;核心思想：“分而治之”&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nb</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="云计算" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
    <category term="云计算" scheme="https://ericzikun.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="MapReduce" scheme="https://ericzikun.github.io/tags/MapReduce/"/>
    
    <category term="hadoop" scheme="https://ericzikun.github.io/tags/hadoop/"/>
    
    <category term="分布式" scheme="https://ericzikun.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>弄懂服务端、客户端【手写一个socket聊天室】</title>
    <link href="https://ericzikun.github.io/2021/08/02/deep9-%E5%BC%84%E6%87%82%E6%9C%8D%E5%8A%A1%E7%AB%AF%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%90%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAsocket%E8%81%8A%E5%A4%A9%E5%AE%A4%E3%80%91/"/>
    <id>https://ericzikun.github.io/2021/08/02/deep9-%E5%BC%84%E6%87%82%E6%9C%8D%E5%8A%A1%E7%AB%AF%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%90%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAsocket%E8%81%8A%E5%A4%A9%E5%AE%A4%E3%80%91/</id>
    <published>2021-08-02T08:15:50.000Z</published>
    <updated>2021-08-02T09:36:17.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见架构："><a href="#常见架构：" class="headerlink" title="常见架构："></a>常见架构：</h2><p>C/S架构：Client/Server(客户端/服务器)结构<img src="https://img-blog.csdnimg.cn/4eb987112f954ccfacc5390c87394ea3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>B/S架构：Browser/Server(浏览器/服务器)结构<br><img src="https://img-blog.csdnimg.cn/3ddc8a3513924c2dbca0b5c8f740f1a9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="服务端和客户端"><a href="#服务端和客户端" class="headerlink" title="服务端和客户端"></a>服务端和客户端</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简单地说：一般客户端负责和用户的交互，也就是屏幕显示(UI/UE)，服务端负责数据存储，也就是你的用户数据，而计算能力，客户端和服务端一般各负责一部分。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 微信、qq这种聊天功能一般在用户之间通信时，用户的数据先是发送到服务器上的，然后通过服务器进行转发给指定用户，从而完成一次用户间的通信，那么如何证明这一点呢？比如一下几种场景：</p><ol><li>当A用户不在线时，B用户给A发送，A是接收不到的，当A一上线，信息会立马发送给他，可推理出B用户发送的数据会保存在服务器中。</li><li>当A用户给B传输文件时，上传完后，B需要下载才可传输到本地，说明下载之前已经上传到服务器了，如果清空本地的该文件，在一定时间范围内仍然可以重新下载回来，说明服务器上文件还在。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于一个简单的群聊功能，实现的基本原理就是，客户端给服务器发送数据，服务器再将请求发送给其他客户端，从而完成转发，单聊那就是在客户端传服务器的过程中加入了目标用户识别码。</li></ol><h2 id="TCP-IP、UDP？"><a href="#TCP-IP、UDP？" class="headerlink" title="TCP/IP、UDP？"></a>TCP/IP、UDP？</h2><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里有一张图，表明了这些协议的关系。   <strong>TCP/IP协议族包括运输层、网络层、链路层。</strong><br><img src="https://img-blog.csdnimg.cn/3f62427555804da288d52f933babf2f1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h2 id="Socket技术"><a href="#Socket技术" class="headerlink" title="Socket技术"></a>Socket技术</h2><img src="https://img-blog.csdnimg.cn/e43ecb011edf4531883da487a41db724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 简单来说，socket就是对tcp/ip协议的封装，在java中是一个类，方便用户去完成通信。</p><img src="https://img-blog.csdnimg.cn/6541003ddc4843e7a5ed40cac608c162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h3 id="Socket建立通信的流程："><a href="#Socket建立通信的流程：" class="headerlink" title="Socket建立通信的流程："></a>Socket建立通信的流程：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 服务端的ServerSocket通过绑定ip和port，从而完成初始化，以保证在port下监听待接入的客户端,accept()函数使得监听到接入的客户端，这里可以采用死循环【建立新的线程】保持服务端一直在监听并接受新的客户端的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">Socket socket = ss.accept();</span><br></pre></td></tr></table></figure><p>客户端：<br>同样通过绑定ip port建立Socket</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket = <span class="keyword">new</span> Socket(host, port);</span><br></pre></td></tr></table></figure><p>服务端accept得到的Socket相当于是在客户端自建的Socket基础之上构建的新的Socket</p><p>服务端得到了与客户端连接的Socket之后便可以拿到该Socket的输入、输出流；<br>对于客户端也是一样，需要通过Socket拿到输入输出流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream is= socket.getInputStream();</span><br><span class="line">OutputStream os = socket.getOutputStream();</span><br></pre></td></tr></table></figure><h2 id="群聊代码："><a href="#群聊代码：" class="headerlink" title="群聊代码："></a>群聊代码：</h2><p>思路：<br><img src="https://img-blog.csdnimg.cn/83a0c801c17448c3a6acc2351603f43f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 服务端和客户端通信必须构建一个管道，管道的两端分别是InputStream、OutputStream，当服务端输出时用OutputStream，某一个客户端对应的就是InputStream来接受服务端的输出，即每个管道的输入输出一一对应。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么对于服务端来说，他的输入流，应该是客户端的输出流，有多少个客户端，就应该有多少个线程来维护这个管道，所以每连接一个客户端，就应该启动一个输入流给服务端。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么，服务端的输出流（输出的线程）应该有多少个呢，如果要实现转发 群发功能，那么服务端的输出流线程只能是一个 里面有多个输出流，因为它要给每一个客户端去发消息，消息可以存在消息列表里面，每次从msgQueue里面拿出第一个消息，然后发送给每一个客户端，所以对于服务端的输出线程，它理应包含一个list去装载每一个客户端的socket，这样才能在群发时 遍历每一个客户端的socket 并且拿到socket对应的输出流，将消息群发出去。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于1个客户端来说，比服务端简单很多，输入流（输入线程）就只用构建一个，用于接受客户端输出的数据，输出流（输出线程）也是构建一个，用于发送给服务端。具体的代码架构如下图所示，将客户端和服务端代码分离，便于维护和后期拓展功能</p><img src="https://img-blog.csdnimg.cn/28bbdcce6692413599f38399e62be2bf.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.client.InputThread;</span><br><span class="line"><span class="keyword">import</span> chatroom.client.OutputThread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 10:42 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义Socket对象</span></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//服务器的Ip地址和服务器所使用的端口号</span></span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">8082</span>;</span><br><span class="line">    <span class="keyword">private</span> String label = <span class="string">"客户端"</span>;</span><br><span class="line">    <span class="keyword">private</span> String clientName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">        createCient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createCient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(host, port);</span><br><span class="line">            createInput(socket,label);</span><br><span class="line">            createOutput(socket,label);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createOutput</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        OutputThread outputThread = <span class="keyword">new</span> OutputThread(socket,label);</span><br><span class="line">        outputThread.setClientName(clientName);</span><br><span class="line">        <span class="keyword">new</span> Thread(outputThread).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createInput</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        InputThread inputThread = <span class="keyword">new</span> InputThread(socket,label);</span><br><span class="line">        <span class="keyword">new</span> Thread(inputThread).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"客户端1"</span>);</span><br><span class="line">        Client client2 = <span class="keyword">new</span> Client(<span class="string">"客户端2"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:24 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputThread</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = is.read(b);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//客户端输入：接受服务端的输出</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(b, <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:26 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String label; <span class="comment">// 记录是客户端 or 服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String clientName; <span class="comment">//记录客户端的名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputThread</span><span class="params">(Socket socket, String label)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.label = label;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientName</span><span class="params">(String clientName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//客户端 接受用户的输入 发送到服务端</span></span><br><span class="line">            System.out.println(<span class="string">"请输入要发送的内容"</span>);</span><br><span class="line">            Scanner ss = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String ans = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> curTime = System.currentTimeMillis();</span><br><span class="line">                curTime = curTime;</span><br><span class="line">                ans = clientName + <span class="string">"："</span> + ss.nextLine();</span><br><span class="line"></span><br><span class="line">                os.write(ans.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (</span><br><span class="line">                IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.client.Client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 3:42 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：客户端1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"客户端1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.client.Client;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 3:42 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Client client = <span class="keyword">new</span> Client(<span class="string">"客户端2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> chatroom.server.InputThread;</span><br><span class="line"><span class="keyword">import</span> chatroom.server.OutputThread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 10:43 上午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">8082</span>;</span><br><span class="line">    <span class="keyword">private</span> String label = <span class="string">"服务端"</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> LinkedBlockingDeque&lt;String&gt; msgQueue;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Socket&gt; sockets;<span class="comment">//维护每一个与客户端连接的socket</span></span><br><span class="line">    <span class="keyword">public</span> Integer clientNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        createServer();</span><br><span class="line">        <span class="keyword">this</span>.clientNum = sockets.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//服务器套接字</span></span><br><span class="line">            ServerSocket ss = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            System.out.println((<span class="string">"服务器已经启动,监听端口为"</span> + port));</span><br><span class="line">            <span class="comment">//初始化一个msgQueue用于存放客户端传来的数据</span></span><br><span class="line">            <span class="keyword">this</span>.msgQueue = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();</span><br><span class="line">            <span class="keyword">this</span>.sockets = <span class="keyword">new</span> ArrayList&lt;Socket&gt;();</span><br><span class="line"></span><br><span class="line">            createOutput(sockets, msgQueue);</span><br><span class="line">            <span class="comment">// 给客户端发送信息 只需要维护一个OutputThread即可 以保证每次从msgQueue里取一次msg</span></span><br><span class="line">            <span class="comment">// 都能将该msg群发个多个客户端</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">                Socket socket = ss.accept();</span><br><span class="line">                sockets.add(socket);</span><br><span class="line">                createInput(socket, msgQueue);<span class="comment">//每一个与客户端之间的socket都需要建立一个inputThread去接收</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//服务器套接字等待一个客服端socket连入，如果连接成功的话，就会创建一个套接字，不然在这里一直等待</span></span><br><span class="line">                System.out.println(<span class="string">"已经接受连接"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程 OutputThread：服务端输出到客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOutput</span><span class="params">(ArrayList&lt;Socket&gt; sockets, LinkedBlockingDeque&lt;String&gt; msgQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        OutputThread outputThread = <span class="keyword">new</span> OutputThread(msgQueue, sockets);</span><br><span class="line">        <span class="keyword">new</span> Thread(outputThread).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程 InputThread：服务端接受客户端的输入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createInput</span><span class="params">(Socket socket, LinkedBlockingDeque&lt;String&gt; msgQueue)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputThread inputThread = <span class="keyword">new</span> InputThread(socket, msgQueue);</span><br><span class="line">        <span class="keyword">new</span> Thread(inputThread).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:24 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line">    <span class="keyword">public</span>   LinkedBlockingDeque&lt;String&gt; msgQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputThread</span><span class="params">(Socket socket,LinkedBlockingDeque&lt;String&gt; msgQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgQueue</span><span class="params">(LinkedBlockingDeque&lt;String&gt; msgQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is= socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="keyword">int</span> len = is.read(b);</span><br><span class="line">                <span class="comment">//接受客户端传来的信息</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(b , <span class="number">0</span>, len));</span><br><span class="line">                <span class="comment">//再把信息传到集合中去，再在outputThread中输出给其他客户端</span></span><br><span class="line">                msgQueue.add(<span class="keyword">new</span> String(b , <span class="number">0</span>, len));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> chatroom.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ：erickun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> ：Created in 2021/8/1 1:26 下午</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@modified</span> By：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span>: $</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Socket&gt; sockets;</span><br><span class="line">    <span class="keyword">public</span> LinkedBlockingDeque&lt;String&gt; msgQueue;</span><br><span class="line">    <span class="keyword">private</span> String label; <span class="comment">// 记录是客户端 or 服务端</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OutputThread</span><span class="params">(LinkedBlockingDeque&lt;String&gt; msgQueue, ArrayList&lt;Socket&gt; sockets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sockets = sockets;</span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (msgQueue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    String poll = msgQueue.poll();</span><br><span class="line">                    <span class="comment">//群发给所有客户端</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sockets.size(); i++) &#123;</span><br><span class="line">                        Socket curSocket = sockets.get(i);</span><br><span class="line">                        os = curSocket.getOutputStream();</span><br><span class="line">                        os.write(poll.getBytes());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;常见架构：&quot;&gt;&lt;a href=&quot;#常见架构：&quot; class=&quot;headerlink&quot; title=&quot;常见架构：&quot;&gt;&lt;/a&gt;常见架构：&lt;/h2&gt;&lt;p&gt;C/S架构：Client/Server(客户端/服务器)结构&lt;img src=&quot;https://img-blog.c</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="socket" scheme="https://ericzikun.github.io/tags/socket/"/>
    
    <category term="服务端" scheme="https://ericzikun.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
    <category term="客户端" scheme="https://ericzikun.github.io/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>深入线程池【手写线程池！阿里弃用之辨析】</title>
    <link href="https://ericzikun.github.io/2021/07/01/deep8-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://ericzikun.github.io/2021/07/01/deep8-%E6%89%8B%E5%86%99%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2021-07-01T05:40:40.000Z</published>
    <updated>2021-07-01T05:44:23.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 线程池和<strong>数据库连接池</strong>非常类似，可以统一管理和维护线程，减少没有必要的开销。 </p><h1 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为频繁的开启线程或者停止线程，线程需要从新被 cpu 从就绪到运行状态调度，需要发生<br>cpu 的上下文切换，效率非常低。<br><img src="https://img-blog.csdnimg.cn/20210630105323135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><blockquote><p>当线程从run中sleep后，会到达阻塞状态，这时候要想再回到run状态，得先就绪再到run状态，成本极高；</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 分析：如果这里有100个线程，则会新建100个newThread，100次start，100次的就绪，100次的CPU调度，才能被运行，必然也有100次的销毁，整个的成本非常高！<br>所以我们提前创建好100个线程，都在<strong>运行状态</strong>，只要有请求过来了，直接再run方法中进行执行就行了！而不是又经过创建-&gt;就绪-&gt;运行 这个耗时的过程！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </p><h1 id="哪里使用到线程池"><a href="#哪里使用到线程池" class="headerlink" title="哪里使用到线程池"></a>哪里使用到线程池</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 实际开发项目中 禁止自己 new 线程。必须使用线程池来维护和创建线程。<br><img src="https://img-blog.csdnimg.cn/20210630111710128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>实际企业开发中，如果像这样去new线程，那一定会被开除！！</p><blockquote><p>如果别人找到了这个bug，比如你这个接口有每次创建线程的bug，那么别人可以通过这个bug给你服务器攻击！造成CPU飙高，线程池就可以很好的管理，管理线程创建的数量，而不是无限制的创建！</p></blockquote><h1 id="线程池有哪些作用"><a href="#线程池有哪些作用" class="headerlink" title="线程池有哪些作用"></a>线程池有哪些作用</h1><p>核心点：复用机制 提前创建好固定的线程一直在运行状态 实现复用 限制线程创建数量。<br>1.<strong>降低资源消耗</strong>：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。<br>2.<strong>提高响应速度</strong>：任务到达时，无需等待线程创建即可立即执行。<br>3.<strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。<br>4.<strong>提供更多更强大的功能</strong>：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池 ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。</p><p>总结：<strong>统一维护管理</strong></p><h1 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h1><p>Executors.newCachedThreadPool(); 可缓存线程池<br>Executors.newFixedThreadPool()；可定长度 限制最大线程数<br>Executors.newScheduledThreadPool() ； 可定时<br>Executors.newSingleThreadExecutor(); 单例<br>底层都是基于 ThreadPoolExecutor 构造函数封装</p><blockquote><p>前面四个基本上实际生产不会去用，阿里巴巴不推荐，因为底层都是由ThreadPoolExecutor 构造封装的，而构造函数中是一个无界的队列（后面解释）</p></blockquote><h3 id="Executors-newCachedThreadPool-："><a href="#Executors-newCachedThreadPool-：" class="headerlink" title="Executors.newCachedThreadPool()："></a>Executors.newCachedThreadPool()：</h3> <img src="https://img-blog.csdnimg.cn/2021063011395861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" />下面是它的源码部分<img src="https://img-blog.csdnimg.cn/20210630114057781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" />核心线程数传的0，最大是无限，没有界限，如果用这个无限的去创建，而不是复用机制，故不去用！这个api实际开发不用！ 可以改成可定长度线程池，这样即使for循环有10个线程创建，但是会被传入的nThread所限制。<img src="https://img-blog.csdnimg.cn/20210630114422898.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /># 线程池底层是如何实现复用的本质思想：创建一个线程，不会立马停止或者销毁而是一直实现复用。1. 提前创建固定大小的线程一直保持在正在运行状态；（可能会非常消耗 cpu 的资源）2. 当需要线程执行任务，将该任务提交缓存在并发队列中；如果缓存队列满了，则会执行拒绝策略；3. 正在运行的线程从并发队列中获取任务执行从而实现多线程复用问题；<p><img src="https://img-blog.csdnimg.cn/2021063011505721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>线程的核心点：复用机制——</p><ol><li>提前创建好固定的线程一直在运行状态—-死循环实现</li><li>提交的线程任务缓存到一个并发队列集合中，交给我们正在运行的线程执行</li><li>正在运行的线程就从队列中获取该任务执行</li></ol><p>如何保证线程一直在运行，而不会停掉被销毁呢？———加一个<strong>while死循环</strong>即可</p><img src="https://img-blog.csdnimg.cn/2021063011531157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h1 id="手写线程池"><a href="#手写线程池" class="headerlink" title="手写线程池"></a>手写线程池</h1><p>思路：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先线程池得定义一系列线程，并且构造的时候让这些线程都处于一个运行状态，用workThreads代替，构造的时候可以给定限制的工作线程数量以及任务集合中的size上限，运行状态通过改写每一个工作线程的run方法即可，利用死循环让其处于一直运行的状态！具体每一个工作线程要做的任务是什么，就通过拿取runnableDeque这个队列中的每一个任务即可，poll方法拿取后便删除该任务。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果想控制线程池使得结束，可以通过控制工作线程中while循环的条件，设置一个isRun的Boolean变量，并且当任务队列中没有任务了之后线程池才停止工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExecutors</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;WorkThread&gt; workThreads;</span><br><span class="line">    <span class="comment">// 缓存我们线程任务</span></span><br><span class="line">    <span class="keyword">private</span> BlockingDeque&lt;Runnable&gt; runnableDeque;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRun = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大线程数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxThreadCount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyExecutors</span><span class="params">(<span class="keyword">int</span> maxThreadCount, <span class="keyword">int</span> dequeSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.限制队列容量缓存</span></span><br><span class="line">        runnableDeque = <span class="keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;(dequeSize);</span><br><span class="line">        <span class="comment">//2.提前创建好固定的线程一直在运行状态----死循环实现</span></span><br><span class="line">        workThreads = <span class="keyword">new</span> ArrayList&lt;WorkThread&gt;(maxThreadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxThreadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> WorkThread().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WorkThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (isRun||runnableDeque.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                Runnable runnable = runnableDeque.poll();</span><br><span class="line">                <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runnableDeque.offer(command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyExecutors myExecutors = <span class="keyword">new</span> MyExecutors(<span class="number">2</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            myExecutors.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">","</span> + finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        myExecutors.isRun = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadPoolExecutor核心参数"><a href="#ThreadPoolExecutor核心参数" class="headerlink" title="ThreadPoolExecutor核心参数"></a>ThreadPoolExecutor核心参数</h1><p>corePoolSize：核心线程数量 一直正在保持运行的线程<br>maximumPoolSize：最大线程数，线程池允许创建的最大线程数。<br>keepAliveTime：超出 corePoolSize 后创建的线程的存活时间。<br>unit：keepAliveTime 的时间单位。<br>workQueue：任务队列，用于保存待执行的任务。<br>threadFactory：线程池内部创建线程所用的工厂。<br>handler：任务无法执行时的处理器。</p><h2 id="线程池创建的线程会一直在运行状态吗？"><a href="#线程池创建的线程会一直在运行状态吗？" class="headerlink" title="线程池创建的线程会一直在运行状态吗？"></a>线程池创建的线程会一直在运行状态吗？</h2><p>不会<br>例如：配置核心线程数 corePoolSize 为 2 、最大线程数 maximumPoolSize 为 5<br>我们可以通过配置超出 corePoolSize 核心线程数后创建的线程的存活时间例如为 60s，在 60s 内非核心线程一直没有任务执行，则会停止该线程。<br>总结：核心线程数是一直在运行的，但最大线程数是不一定的，看具体任务，如果任务的情况下补给到最大线程范围内更多的线程进来工作，最大线程减去核心线程的这部分线程在工作完后再销毁。<br>目的：为了节约服务器资源</p><h2 id="为什么阿里巴巴不建议使用-Executors"><a href="#为什么阿里巴巴不建议使用-Executors" class="headerlink" title="为什么阿里巴巴不建议使用 Executors"></a>为什么阿里巴巴不建议使用 Executors</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 因为默认的 Executors 线程池底层是基于 ThreadPoolExecutor构造函数封装的，采用<strong>无界队列存放缓存任务</strong>，会无限缓存任务容易发生内存溢出，会导致我们最大线程数会失效。<br><img src="https://img-blog.csdnimg.cn/20210630151105463.png"  style="zoom:50%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【强制】线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，</span><br><span class="line">这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 </span><br><span class="line">说明：Executors各个方法的弊端：</span><br><span class="line"><span class="number">1</span>）newFixedThreadPool和newSingleThreadExecutor:</span><br><span class="line">  主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至<span class="number">1</span>OOM。</span><br><span class="line"><span class="number">2</span>）newCachedThreadPool和newScheduledThreadPool:</span><br><span class="line">  主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至<span class="number">1</span>OOM。</span><br></pre></td></tr></table></figure><h2 id="线程池底层-ThreadPoolExecutor-底层实现原理"><a href="#线程池底层-ThreadPoolExecutor-底层实现原理" class="headerlink" title="线程池底层 ThreadPoolExecutor 底层实现原理"></a>线程池底层 ThreadPoolExecutor 底层实现原理</h2><p>1.当线程数小于核心线程数时，创建线程。<br>2.当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。<br>3.当线程数大于等于核心线程数，且任务队列已满<br>3.1 若线程数小于最大线程数，创建线程<br>3.2 若线程数等于最大线程数，抛出异常，拒绝任务<br>看例子：<br>分析：首先创建了一个线程池，有2个核心线程，4个最大线程，并且blockingQueue的容量为5（用于缓存任务队列），然后我们再for中提交了10个任务进行执行，第一个和第二个任务直接被2个核心线程来执行，3、4、5、6、7就被缓存到容量为5的blockingQueue队列中了，然后遍历到第八个新任务的时候，当前的线程数已经大于了核心线程数，并且任务队列已经装满了，那就再创建（最大线程数-核心线程数）个线程，这里也就是2个新的工作线程被创建去执行第8、第9个任务，当遍历到第10个任务的时候，就已经没有工作线程来执行了，并且任务队列之前也装满了，从而拒绝任务！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.提交的线程任务数&lt;核心线程数  （核心线程数任务复用）</span></span><br><span class="line">        <span class="comment">//2.提交的线程任务数&gt;核心线程数 且我们队列容量没有满 将该任务缓存到我们队列中</span></span><br><span class="line">        <span class="comment">// 循环3 4 5 6 7 缓存到我们队列中</span></span><br><span class="line">        <span class="comment">//3.提交的线程任务数&gt;核心线程数 且我们队列容量满了</span></span><br><span class="line">        <span class="comment">//8,9，10</span></span><br><span class="line">        <span class="comment">// 最多在额外创建两个线程 4-2 2个线程</span></span><br><span class="line">        <span class="comment">// 2个线程 8 ,9</span></span><br><span class="line">        <span class="comment">// 10个任务----拒绝</span></span><br><span class="line">        ExecutorService executorService = MyThreadPoolExecutor.newFixedThreadPool(<span class="number">2</span>, <span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> finalI = i;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">","</span> + finalI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实际上最多执行多少个任务 核心线程数+缓存队列的容量+最大线程数-核心线程数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己重写的一个ExecutorService，限制了传入的核心线程数、最大线程数、以及任务队列的容量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">int</span> blockingQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize,</span><br><span class="line">                <span class="number">60L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(blockingQueue), (RejectedExecutionHandler) <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy ());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池队列满了，任务会丢失吗"><a href="#线程池队列满了，任务会丢失吗" class="headerlink" title="线程池队列满了，任务会丢失吗"></a>线程池队列满了，任务会丢失吗</h2><p>如果队列满了，且任务总数&gt;最大线程数则当前线程走拒绝策略。<br>可以自定义异拒绝异常，将该任务缓存到 redis、本地文件、mysql 中后期项目启动实现补偿。<br>1.AbortPolicy 丢弃任务，抛运行时异常<br>2.CallerRunsPolicy 执行任务<br>3.DiscardPolicy 忽视，什么都不会发生<br>4.DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务</p><h2 id="线程池拒绝策略类型有哪些呢"><a href="#线程池拒绝策略类型有哪些呢" class="headerlink" title="线程池拒绝策略类型有哪些呢"></a>线程池拒绝策略类型有哪些呢</h2><p>1.AbortPolicy 丢弃任务，抛运行时异常<br>2.CallerRunsPolicy 执行任务<br>3.DiscardPolicy 忽视，什么都不会发生<br>4.DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务<br>5.实现 RejectedExecutionHandler 接口，可自定义处理器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是线程池&quot;&gt;&lt;a href=&quot;#什么是线程池&quot; class=&quot;headerlink&quot; title=&quot;什么是线程池&quot;&gt;&lt;/a&gt;什么是线程池&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 线程池和&lt;strong</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="线程池" scheme="https://ericzikun.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>别再问我字符串了！彻底理解Java中的字符串（==、equals、堆内存、常量池）</title>
    <link href="https://ericzikun.github.io/2021/06/29/deep7-%E6%B7%B1%E5%85%A5Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://ericzikun.github.io/2021/06/29/deep7-%E6%B7%B1%E5%85%A5Java%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2021-06-29T03:41:40.000Z</published>
    <updated>2021-07-01T05:41:52.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="equals、"><a href="#equals、" class="headerlink" title="equals、=="></a>equals、==</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 首先明确一点，==比较的是引用，equals比较的是内容，在类库没有定义equals方法重写的情况下，自然继承的是Object类的equals方法，上源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么对于String类来说，官方已封装了复写之后的equals方法，比较的是具体内容，判断：如果是引用相同，也就是堆内的地址相同，那么就是同一个对象，直接返回true，否则就遍历字符串中的每一个字符进行比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，字符串还有个常量池，也就是说如果先定义了一个”ABC”字符串，再定义一个相同字符串的时候，会首先去常量池里面找之前有没有定义，如果有，则直接指向常量池的同一地址。</p><h2 id="常量池介绍"><a href="#常量池介绍" class="headerlink" title="常量池介绍"></a>常量池介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化</p><ul><li><p>为字符串开辟一个字符串常量池，类似于缓存区</p></li><li><p>创建字符串常量时，首先坚持字符串常量池是否存在该字符串</p></li><li><p>存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</p></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了以上的铺垫，后面几个问题就好解释了：</p><h1 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"ABC"</span>);</span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">        System.out.println(str2 == str3);<span class="comment">// flase</span></span><br><span class="line">        System.out.println(str1.equals(str2)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(str2.equals(str3)); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;str1与str2都指向的是常量池中同一个字符串的地址，所以==为true，而str3是new了一个新的对象，会在堆中新建一个内存地址，所以比较str3和str3的地址时则为flase，equals就简单了，比较的均为字符串内容，故均为true。<br><img src="https://img-blog.csdnimg.cn/20210629134246186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h1 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"ABC"</span>);</span><br><span class="line">        String str3_1=str3.intern();</span><br><span class="line">        System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">        System.out.println(str2 == str3);<span class="comment">// flase</span></span><br><span class="line">        System.out.println(str3_1 == str1);<span class="comment">// true</span></span><br><span class="line">        System.out.println(str3_1 == str3);<span class="comment">// flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们新定义一个str3_1变量，让他取str3的intern()方法，此方法是这样定义的：</p><blockquote><p>这是一个native的方法，书上是这样描述它的作用的：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回常量池池中这个字符串的String对象；否则，将此String对象包含的字符添加到常量池中，并返回此String对象的引用。</p></blockquote><p>所以str3_1拿到的是常量池中的”ABC“地址，和str1、str2的地址肯定是相同的，</p><h1 id="案例3"><a href="#案例3" class="headerlink" title="案例3"></a>案例3</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        str1 +=<span class="string">"D"</span>;</span><br><span class="line">        String str5 = <span class="string">"ABCD"</span>;<span class="comment">// 肯定在常量池中生成一个</span></span><br><span class="line">        System.out.println(str5 == str1);<span class="comment">//flase</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里如果给str1拼接了一个D字符串，这里通过javap命令查看字节码文件，会发现+=操作在String源码中调用的其实是apped方法，生成的是一个新的对象堆地址，str5指向的常量池的地址与str1指向的堆对象地址不一，如果我在str1拼接之后加上str1 = str1.intern(); 这时候由于str1指向的是常量池中的ABCD，==就为true了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">"ABC"</span>;</span><br><span class="line">        String str2 = <span class="string">"ABC"</span>;</span><br><span class="line">        str1 +=<span class="string">"D"</span>;</span><br><span class="line">        str1 = str1.intern();</span><br><span class="line">        String str5 = <span class="string">"ABCD"</span>;<span class="comment">// 肯定在常量池中生成一个</span></span><br><span class="line">        System.out.println(str5 == str1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里intern调用之后，如果常量池中没有”ABCD“，则会在常量池生成，如果有则直接指向它。所以此处的str1指向的是常量池中的”ABCD“，后面定义的str5在构造时则会直接指向常量池中的”ABCD“</p><p>如果这里把str1 += ”D“修改一下成常量与常量的拼接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        str1 =<span class="string">"ABC"</span> +<span class="string">"D"</span>;</span><br><span class="line">        String str5 = <span class="string">"ABCD"</span>;<span class="comment">// 肯定在常量池中生成一个</span></span><br><span class="line">        System.out.println(str5 == str1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果两个常量进行拼接，编译器会自动优化成”ABCD”，也就是存到了常量池中去了，str5指向的也是常量池中的值。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>原则：</p><p>（1）常量+常量：结果是常量池</p><p>（2）常量与变量 或 变量与变量：结果是堆</p><p>（3）拼接后调用intern方法：结果在常量池</p><p>new 出来的是在堆空间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;equals、&quot;&gt;&lt;a href=&quot;#equals、&quot; class=&quot;headerlink&quot; title=&quot;equ</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="字符串" scheme="https://ericzikun.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="堆内存" scheme="https://ericzikun.github.io/tags/%E5%A0%86%E5%86%85%E5%AD%98/"/>
    
    <category term="常量池" scheme="https://ericzikun.github.io/tags/%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Mac Alfred 工作流 Python开发，可自定义任何接口，全自动化办公</title>
    <link href="https://ericzikun.github.io/2021/06/29/Mac-Alfred-%E5%B7%A5%E4%BD%9C%E6%B5%81-Python%E5%BC%80%E5%8F%91%EF%BC%8C%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E4%BD%95%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/"/>
    <id>https://ericzikun.github.io/2021/06/29/Mac-Alfred-%E5%B7%A5%E4%BD%9C%E6%B5%81-Python%E5%BC%80%E5%8F%91%EF%BC%8C%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%BB%E4%BD%95%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%85%A8%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/</id>
    <published>2021-06-29T03:40:49.000Z</published>
    <updated>2021-06-29T06:10:41.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 用Mac的人应该大多都知道这个，但是workflow工作流，应该是很多人没自己写过，得知支持Python脚本后，自己花了几个小时研究了一下如何把接口融合到Alfred快捷方式中，这里给大家提供一个模板，以这样的形式，无论是免费api还是自己封装的工具接口，均可集成到Alfred中！</p><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="https://img-blog.csdnimg.cn/20210629100429404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210629100454129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="申请接口"><a href="#申请接口" class="headerlink" title="申请接口"></a>申请接口</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 市面上有很多免费接口，这里以聚合数据的头条新闻api为例，链接：<a href="https://www.juhe.cn/docs/api/id/235，在官网注册申请api即可，得到一个key，发送请求参数时带上key和其他参数即可。" target="_blank" rel="noopener">https://www.juhe.cn/docs/api/id/235，在官网注册申请api即可，得到一个key，发送请求参数时带上key和其他参数即可。</a></p><h1 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h1><h2 id="建立空白workflow"><a href="#建立空白workflow" class="headerlink" title="建立空白workflow"></a>建立空白workflow</h2><p><img src="https://img-blog.csdnimg.cn/20210629092138388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210629092200330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>填上基本信息即可，也可以设置一个图标<br>再在里面空白处右键选择script filter<br><img src="https://img-blog.csdnimg.cn/20210629092344177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210629100110687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在script filter里面，我们去运行Python脚本，接受的参数就是”{query}”可以进行传参，这里采用了一个免费的头条新闻api，只要接口能测成功即可，不赘述:<br><img src="https://img-blog.csdnimg.cn/20210629095727194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Python代码，整体思路就是，定义好获取接口数据的方法，并将结果返回给workflow的具体字段即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">Project Name: alfredProjects</span></span><br><span class="line"><span class="string">File Name: alfredTest.py</span></span><br><span class="line"><span class="string">Author: apple</span></span><br><span class="line"><span class="string">Create Date: 2021/6/28</span></span><br><span class="line"><span class="string">-------------------------------------------------</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">from</span> workflow <span class="keyword">import</span> Workflow, web, ICON_WEB</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">reload(sys)</span><br><span class="line"></span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">query_map = dict(</span><br><span class="line">    inner=<span class="string">u"输入in搜索头条国内新闻"</span>,</span><br><span class="line">    outter=<span class="string">'输入out搜索头条国际新闻'</span>,</span><br><span class="line">    top=<span class="string">u'输入top搜索热点新闻'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_recent_news</span><span class="params">(query)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> query == <span class="string">"in"</span>:</span><br><span class="line">        url = <span class="string">"http://v.juhe.cn/toutiao/index?"</span></span><br><span class="line">        params = &#123;<span class="string">"key"</span>: <span class="string">"dd0fb509ac5407213bc6a0fddd48f234"</span>,</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"guonei"</span>&#125;</span><br><span class="line">    <span class="keyword">elif</span> query == <span class="string">"out"</span>:</span><br><span class="line">        url = <span class="string">"http://v.juhe.cn/toutiao/index?"</span></span><br><span class="line">        params = &#123;<span class="string">"key"</span>: <span class="string">"dd0fb509ac5407213bc6a0fddd48f234"</span>,</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"guoji"</span>&#125;</span><br><span class="line">    <span class="keyword">elif</span> query == <span class="string">"top"</span>:</span><br><span class="line">        url = <span class="string">"http://v.juhe.cn/toutiao/index?"</span></span><br><span class="line">        params = &#123;<span class="string">"key"</span>: <span class="string">"dd0fb509ac5407213bc6a0fddd48f234"</span>,</span><br><span class="line">                  <span class="string">"type"</span>: <span class="string">"top"</span>&#125;</span><br><span class="line"></span><br><span class="line">    r = web.post(url, data=params)</span><br><span class="line">    print(r)</span><br><span class="line">    <span class="comment"># throw an error if request failed, Workflow will catch this and show</span></span><br><span class="line">    <span class="comment"># it to the user</span></span><br><span class="line">    r.raise_for_status()</span><br><span class="line">    <span class="comment"># result = r.json()</span></span><br><span class="line">    <span class="keyword">return</span> r.json()[<span class="string">"result"</span>][<span class="string">'data'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(wf)</span>:</span></span><br><span class="line">    query = wf.args[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> query:</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> [<span class="string">"inner"</span>, <span class="string">"outter"</span>, <span class="string">"top"</span>]:</span><br><span class="line">            wf.add_item(</span><br><span class="line">                title=query_map[key],</span><br><span class="line">                valid=<span class="literal">True</span>,</span><br><span class="line">            )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> get_recent_news(query)</span><br><span class="line"></span><br><span class="line">        news = wf.cached_data(query, wrapper, max_age=<span class="number">300</span>)</span><br><span class="line">        <span class="comment"># news = get_recent_news(query)</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> news:</span><br><span class="line">            wf.add_item(title=<span class="string">u"【&#123;&#125;】&#123;&#125;"</span>.format(r[<span class="string">"author_name"</span>], r[<span class="string">'title'</span>]),</span><br><span class="line">                        arg=r[<span class="string">'url'</span>],</span><br><span class="line">                        valid=<span class="literal">True</span>,</span><br><span class="line">                        icon=ICON_WEB)</span><br><span class="line">    <span class="comment"># Send output to Alfred. You can only call this once.</span></span><br><span class="line">    <span class="comment"># Well, you *can* call it multiple times, but Alfred won't be listening</span></span><br><span class="line">    <span class="comment"># any more...</span></span><br><span class="line">    wf.send_feedback()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    wf = Workflow()</span><br><span class="line">    sys.exit(wf.run(main))</span><br></pre></td></tr></table></figure><p>最后说一下脚本和相关库放在哪里：<br> <img src="https://img-blog.csdnimg.cn/20210629100050804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>点击后，会在finder显示该工作流的文件夹，将workflow库以及Python脚本放在此下即可：<br><img src="https://img-blog.csdnimg.cn/20210629100136563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="跳转页面"><a href="#跳转页面" class="headerlink" title="跳转页面"></a>跳转页面</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于返回的json数据里面，每个新闻有个url，我们将url设为workflow的item args即可，代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wf.add_item(title=<span class="string">u"【&#123;&#125;】&#123;&#125;"</span>.format(r[<span class="string">"author_name"</span>], r[<span class="string">'title'</span>]),</span><br><span class="line">                       arg=r[<span class="string">'url'</span>],</span><br><span class="line">                       valid=<span class="literal">True</span>,</span><br><span class="line">                       icon=ICON_WEB)</span><br></pre></td></tr></table></figure><p>再在script filter之后接一个url即可：<br><img src="https://img-blog.csdnimg.cn/20210629100833240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Alfred&quot;&gt;&lt;a href=&quot;#Alfred&quot; class=&quot;headerlink&quot; title=&quot;Alfred&quot;&gt;&lt;/a&gt;Alfred&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 用Mac的人应该大多都</summary>
      
    
    
    
    <category term="技巧" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E5%B7%A7/"/>
    
    <category term="提升效率" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E5%B7%A7/%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87/"/>
    
    
    <category term="效率" scheme="https://ericzikun.github.io/tags/%E6%95%88%E7%8E%87/"/>
    
    <category term="学术" scheme="https://ericzikun.github.io/tags/%E5%AD%A6%E6%9C%AF/"/>
    
    <category term="Mac" scheme="https://ericzikun.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>多线程中的wait与sleep ,synchronize与lock有啥子区别?死锁辨析</title>
    <link href="https://ericzikun.github.io/2021/06/26/deep6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84wait%E4%B8%8Esleep-synchronize%E4%B8%8Elock%E6%9C%89%E5%95%A5%E5%AD%90%E5%8C%BA%E5%88%AB-%E6%AD%BB%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81%E8%BE%A8%E6%9E%90/"/>
    <id>https://ericzikun.github.io/2021/06/26/deep6-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84wait%E4%B8%8Esleep-synchronize%E4%B8%8Elock%E6%9C%89%E5%95%A5%E5%AD%90%E5%8C%BA%E5%88%AB-%E6%AD%BB%E9%94%81-%E4%B9%90%E8%A7%82%E9%94%81-%E6%82%B2%E8%A7%82%E9%94%81%E8%BE%A8%E6%9E%90/</id>
    <published>2021-06-26T13:55:47.000Z</published>
    <updated>2021-06-29T06:01:58.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wait与sleep"><a href="#wait与sleep" class="headerlink" title="wait与sleep"></a>wait与sleep</h1><ol><li>来自不同的类<br>首先，wait和sleep都不是一个类下的方法：<br>wait来自：Object<br>sleep来自：Thread<img src="https://img-blog.csdnimg.cn/20210626221030902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/20210626221053496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></li></ol><p>因为java中所有的类都是继承自object的，所以所有类都可以调用wait方法，这是一个final的方法，同时不是一个静态方法，所以调用该方法需要先实例化一个Object对象才可以</p><ol start="2"><li>释放锁的不同<br>wait 会释放锁，sleep 睡觉了，抱着锁睡觉，不会释放!  也就是说，如果有两个线程，其中一个锁住了某个对象时，中间sleep了，这时候另一个线程时拿不到该对象的锁的，得等第一个线程sleep完并释放锁才可。<br>wait会释放这个锁，并把这个wait的线程加入到这个锁的等待队列中去</li><li>使用的范围不同<br>wait必须在同步代码块中使用</li><li>使用sleep不需要被唤醒，但是wait是需要notify()或者notifyAll()去唤醒的，除了wait(1000)这种形式.</li></ol><p>举例说明问题：</p><h1 id="synchronized与lock"><a href="#synchronized与lock" class="headerlink" title="synchronized与lock"></a>synchronized与lock</h1><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized如果加在了非静态方法上，表示的是synchronized(调用方法的类的对象) {}，如果加在了静态方法上，表示的是synchronized(类.class) {}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferSynchronizedAndLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123; ticket.sale();</span><br><span class="line">            &#125; &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性、方法</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">        <span class="comment">// 卖票的方式</span></span><br><span class="line">        <span class="comment">// synchronized 本质: 队列，锁</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"卖出了"</span>+(number--)+<span class="string">"票,剩余:"</span>+number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210627101008598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>此处如果不对方法加synchronized修饰（不加锁）：<br><img src="https://img-blog.csdnimg.cn/20210627101419402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>Lock是一个接口，实现类有一下几个：<br><img src="https://img-blog.csdnimg.cn/20210627102346313.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>先看可重入锁（ReentrantLock）：<br><img src="https://img-blog.csdnimg.cn/20210627102525603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>这里的可重入锁构造时候除非传入fair公平，否则默认为不公平锁。<br>公平锁：十分公平:可以先来后到<br>非公平锁：十分不公平:可以插队 (默认)<a href="https://blog.csdn.net/lsgqjh/article/details/63685058" target="_blank" rel="noopener">深入剖析ReentrantLock公平锁与非公平锁源码实现</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DifferSynchronizedAndLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123; ticket.sale();</span><br><span class="line">            &#125; &#125;,<span class="string">"A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">40</span> ; i++) &#123;</span><br><span class="line">                ticket.sale(); &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 属性、方法</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">30</span>;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        <span class="comment">// 卖票的方式</span></span><br><span class="line">        <span class="comment">// synchronized 本质: 队列，锁</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (number&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"卖出了"</span>+(number--)+<span class="string">"票,剩余:"</span>+number);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized-与-lock区别"><a href="#synchronized-与-lock区别" class="headerlink" title="synchronized 与 lock区别"></a>synchronized 与 lock区别</h2><ol><li>synchronized 内置的Java关键字， Lock 是一个Java类</li><li>synchronized无法判断获取锁的状态，Lock 可以判断是否获取到了锁<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread提供了holdLock()方法检测当前线程是否持有锁，注意，是当前线程</span><br></pre></td></tr></table></figure></li><li>synchronized 会自动释放锁，lock 必须要手动释放锁!如果不释放锁，死锁</li><li>synchronized 线程 1(获得锁，阻塞)、线程2(只能等待);Lock锁就不一定会等待下去了，这里有个<strong>lock.tryLock()方法，尝试获取锁，可以做个判断让其尝试不到锁时不等待！！</strong></li><li>synchronized 可重入锁，不可以中断的，非公平;Lock ，可重入锁，可以 判断锁，非公平(可以在构造ReentrantLock()中自行设置boolean fair，true为公平，默认flase非公平</li><li>synchronized 适合锁少量的代码同步问题，Lock 适合锁大量的同步代码!<h1 id="生产消费模型"><a href="#生产消费模型" class="headerlink" title="生产消费模型"></a>生产消费模型</h1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 说白了就是多线程之间的通信，场景如下：有两个线程分别负责同一个资源类里变量的增加和减少，即生产与消费，对于增加和减少的逻辑：当资源中为0的时候，减少的方法就应该等待，不能再减少了；那么当资源不等于0 或者大于某个值时，增加方法就应该不再继续增加了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 具体方法总结：判断等待–&gt;业务–&gt;通知<h2 id="synchronized实现"><a href="#synchronized实现" class="headerlink" title="synchronized实现"></a>synchronized实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程之间的通信问题：生产者和消费者问题！  等待唤醒，通知唤醒</span></span><br><span class="line"><span class="comment"> * 线程交替执行  A   B 操作同一个变量   num = 0</span></span><br><span class="line"><span class="comment"> * A num+1</span></span><br><span class="line"><span class="comment"> * B num-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">            <span class="comment">// 等待</span></span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">        <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210627120837300.png"  style="zoom:50%;" /></li></ol><h3 id="此处存在的问题"><a href="#此处存在的问题" class="headerlink" title="此处存在的问题"></a>此处存在的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 案例这样，如果只是两个线程通信，一个增加一个减少，必然不会出错，如果再增加几个呢？那notify之后，哪个线程来抢占呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/2021062714180563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过结果可以看出，有个值变成了2，也就是两个加法被唤醒了，且使得值均加了1。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于这里的资源类中增加和减少的方法使用的是if判断，所以也就只有一次判断，而wait之后，重新被唤醒要执行的是wait之后的语句，所以必须让他反复的判断一下值，这样才能保证线程安全！！将if改成while即可！！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if在官方文档中存在一个<strong>虚假唤醒的问题</strong><br><img src="https://img-blog.csdnimg.cn/20210627142330902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><h2 id="lock锁实现"><a href="#lock锁实现" class="headerlink" title="lock锁实现"></a>lock锁实现</h2><p>Lock提供了condition.await(); 来替换等待，condition.signalAll(); 来替换唤醒全部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断等待，业务，通知</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data2</span></span>&#123; <span class="comment">// 数字 资源类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//condition.await(); // 等待</span></span><br><span class="line">    <span class="comment">//condition.signalAll(); // 唤醒全部</span></span><br><span class="line">    <span class="comment">//+1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务代码</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">0</span>)&#123;  <span class="comment">//0</span></span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我+1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>)&#123; <span class="comment">// 1</span></span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;"</span>+number);</span><br><span class="line">            <span class="comment">// 通知其他线程，我-1完毕了</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前面实现的都是随机的状态，也就是没有人为的去控制线程执行顺序，<strong>Condition可以精准的通知和唤醒！！</strong><br>这里提供一个场景：<strong>A 执行完调用B，B执行完调用C，C执行完调用A</strong>！！<br>这里如果num为1时，让A执行，num=2–&gt;B, num=3–&gt;C</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data3 data = <span class="keyword">new</span> Data3();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printA();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printB();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10</span> ; i++) &#123;</span><br><span class="line">                data.printC();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data3</span></span>&#123; <span class="comment">// 资源类 Lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>; <span class="comment">// 1A  2B  3C</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;AAAAAAA"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，B</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">2</span>)&#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;BBBBBBBBB"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，c</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="comment">// 业务，判断-&gt; 执行-&gt; 通知</span></span><br><span class="line">            <span class="keyword">while</span> (number!=<span class="number">3</span>)&#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"=&gt;BBBBBBBBB"</span>);</span><br><span class="line">            <span class="comment">// 唤醒，唤醒指定的人，c</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210627144412929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70#pic_center =200x400"  style="zoom:50%;" /><p>输出结果即：A执行完通知B执行，B执行完通知C……..</p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="为什么需要锁？"><a href="#为什么需要锁？" class="headerlink" title="为什么需要锁？"></a>为什么需要锁？</h2><p>多线程操作共享资源，存在同时对资源的读写 ，会导致资源的原子性遭到不一致处理 </p><p>需要锁操作来控制多个线程对象资源操作的原子性（安全性）</p><h2 id="锁的工作模式："><a href="#锁的工作模式：" class="headerlink" title="锁的工作模式："></a>锁的工作模式：</h2><p> 对于一个共享资源，我们有 lock 与 unlock 两个原子操作 </p><p>在一个线程对于一个资源进行操作的时候，实行lock 操作 ，这个时候其他线程就不能再操作这个资源对象了进入阻塞状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">有两个资源对象</span></span><br><span class="line"><span class="comment">一个是碗  一个是米饭</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">有两个线程  T1  T2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">T1 拿了一个碗 想去盛饭 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">T2 拿了一份米饭  想拿这个碗来装</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">T1 可以拿到饭吗？ 不能 </span></span><br><span class="line"><span class="comment">T2 可以拿到碗吗？ 不能</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">package</span> com.thread0622;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str1 = <span class="string">"米饭"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str2 = <span class="string">"碗"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程1 持有米饭的监视器锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 持有 "</span> + str1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 想持有 "</span> + str2);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T1 End...."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 持有 "</span> + str2);</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁 的情况下想获取 米饭的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 想持有 "</span> + str1);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T2 End...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决死锁的办法"><a href="#解决死锁的办法" class="headerlink" title="解决死锁的办法"></a>解决死锁的办法</h1><p>1、在申请一个对象资源锁的时候  加入一个时间判断，释放手头所有的资源锁 </p><p>2、写代码时候，尽量避免这种情况的写法 ，嵌套资源锁 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thread0622;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str1 = <span class="string">"米饭"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String str2 = <span class="string">"碗"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程1 持有米饭的监视器锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 持有 "</span> + str1);</span><br><span class="line">&#125;<span class="comment">// 使用完一个资源之后就立即释放锁 </span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T1 想持有 "</span> + str2);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T1 End...."</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str2) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 持有 "</span> + str2);</span><br><span class="line"><span class="comment">// 线程2 持有碗 的监视器锁 的情况下想获取 米饭的锁</span></span><br><span class="line"><span class="keyword">synchronized</span> (str1) &#123;</span><br><span class="line">System.out.println(<span class="string">"T2 想持有 "</span> + str1);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"T2 End...."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、finally 关键字  能够保证 finally 块中的代码   执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  lock.lock();</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;wait与sleep&quot;&gt;&lt;a href=&quot;#wait与sleep&quot; class=&quot;headerlink&quot; title=&quot;wait与sleep&quot;&gt;&lt;/a&gt;wait与sleep&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;来自不同的类&lt;br&gt;首先，wait和sleep都不是一个类下的方</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="https://ericzikun.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Springboot项目docker部署配置文件外挂载</title>
    <link href="https://ericzikun.github.io/2021/06/26/Springboot%E9%A1%B9%E7%9B%AEdocker%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%96%E6%8C%82%E8%BD%BD/"/>
    <id>https://ericzikun.github.io/2021/06/26/Springboot%E9%A1%B9%E7%9B%AEdocker%E9%83%A8%E7%BD%B2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%96%E6%8C%82%E8%BD%BD/</id>
    <published>2021-06-26T13:49:57.000Z</published>
    <updated>2021-06-26T13:53:27.106Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 利用docker对一个Springboot打包时会遇到要及时更改相关数据库或者外部接口的ip及port，如果每次都进到容器内部修改，那一定非常麻烦，这里我想到了两种解决方案，并最终使用了后者。两种方法类似，无论哪种，都必须经过外挂载的步骤，也就是要把配置文件放到一个和宿主机映射的目录下：如图，这里采用的是docker-compose.yaml容器编排方式，不赘述：<br><img src="https://img-blog.csdnimg.cn/20210626214430420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>将配置文件放在宿主机目录的config下，代码中写到“/usr/app_file/config/config/json”即可被容器访问到!</p><h2 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h2><p>容器内运行jar包的CMD采用指定外部application.yml的命令：<br>类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup jdk1<span class="number">.8</span><span class="number">.0_131</span>/bin/java -jar -Dspring.config.location=tmp/springboottmp/xxx.yaml tmp/service.jar --spring.profiles.active=test &gt; logs/xxxlog.log <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure><h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h2><p>不使用application.yml，用最原始的方式读取一个json文件的键值对，并替换代码变量即可,在Springboot config下定义一个JsonConfig类即可，代码简单，关键是要把地址写到容器内的与宿主机映射的<strong>外挂载目录下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String json_file = <span class="string">"/usr/app_file/config/es.json"</span>;</span><br><span class="line">        JSONObject configJ = <span class="keyword">this</span>.readJsonFile(json_file);</span><br><span class="line">        <span class="keyword">if</span>(configJ.containsKey(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> configJ.getString(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JSONObject <span class="title">readJsonFile</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">        String readJson = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">            InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(fileInputStream, <span class="string">"UTF-8"</span>);</span><br><span class="line">            reader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">            String tempString = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((tempString = reader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                readJson += tempString;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (reader != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    reader.close();</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        JSONObject jsonObject = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        <span class="comment">// 获取json</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jsonObject = JSONObject.parseObject(readJson);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (JSONException e)&#123;</span><br><span class="line">            e.getMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jsonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 利用docker对一个Springboot打包时会遇到要及时更改相关数据库或者外部接口的ip及port，如果每次都进到容器内部修改，那一定非常麻烦，这里我想到了两种解决方案，并最终使用了后</summary>
      
    
    
    
    <category term="技术栈" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="Springboot" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/Springboot/"/>
    
    
    <category term="Springboot" scheme="https://ericzikun.github.io/tags/Springboot/"/>
    
    <category term="Docker" scheme="https://ericzikun.github.io/tags/Docker/"/>
    
    <category term="JSON" scheme="https://ericzikun.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Websocket通信实战</title>
    <link href="https://ericzikun.github.io/2021/06/26/Websocket%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98/"/>
    <id>https://ericzikun.github.io/2021/06/26/Websocket%E9%80%9A%E4%BF%A1%E5%AE%9E%E6%88%98/</id>
    <published>2021-06-26T07:35:32.000Z</published>
    <updated>2021-06-26T07:39:04.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 最近给实验室做的个系统需要用docker打包到对方服务器上，并提供多个URL页面以及接口，需求是要将提供的URL页面通过Iframe方式集成到他们的系统去，他们向我们的后端接口发送数据请求，渲染结果到我们的URL页面上，不了解WebSocket前把我难住了，我想到了设置时间间隔 不断向后端请求 也可以解决问题，但是并不优雅，请求数据过大时，时间间隔也不好设定。直到实验室李师兄通过WebSocket技术给我做了示范，原来前后端Http通信除了Ajax之外 还有WebSocket这种客户端和服务端的双向长连接通信。</p><h1 id="WebSocket与Ajax轮询"><a href="#WebSocket与Ajax轮询" class="headerlink" title="WebSocket与Ajax轮询"></a>WebSocket与Ajax轮询</h1><p><img src="https://img-blog.csdnimg.cn/20210626152619628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WebSocket  允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器<strong>只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的<strong>带宽等资源。</strong></p><p>HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</p><h1 id="前端代码"><a href="#前端代码" class="headerlink" title="前端代码"></a>前端代码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> websocket = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'WebSocket'</span> <span class="keyword">in</span> <span class="built_in">window</span>)&#123;</span><br><span class="line">    <span class="comment">// websocket = new WebSocket("ws://localhost:8081/acl/websocket");</span></span><br><span class="line">    websocket = <span class="keyword">new</span> WebSocket(finalurlip);</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    alert(<span class="string">"浏览器不支持websocket，请更换浏览器！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接发生错误的回调方法</span></span><br><span class="line">websocket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setMessageInnerHTML(<span class="string">"建立websocket连接出错！"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接成功建立的回调方法</span></span><br><span class="line">websocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//setMessageInnerHTML("open");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收到消息的回调方法</span></span><br><span class="line"><span class="comment">//消息內包含桑基图数据</span></span><br><span class="line">websocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">    data = <span class="built_in">JSON</span>.parse(msg.data);</span><br><span class="line">    <span class="keyword">var</span> nodes = <span class="built_in">JSON</span>.parse(data.nodes);</span><br><span class="line">    <span class="keyword">var</span> links = <span class="built_in">JSON</span>.parse(data.links);</span><br><span class="line">    <span class="built_in">console</span>.log(nodes);</span><br><span class="line">    <span class="built_in">console</span>.log(links);</span><br><span class="line">    <span class="keyword">var</span> sankeyData = &#123;&#125;;</span><br><span class="line">    sankeyData[<span class="string">"nodes"</span>] = nodes;</span><br><span class="line">    sankeyData[<span class="string">"links"</span>] = links;</span><br><span class="line">    vm2.sankeyData = sankeyData;</span><br><span class="line">    <span class="built_in">console</span>.log(vm2.sankeyData);</span><br><span class="line">    vm2.setTopicSankey_2(<span class="number">1</span>,<span class="string">"acl"</span>,<span class="string">"数据演化图"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接关闭的回调方法</span></span><br><span class="line">websocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setMessageInnerHTML(<span class="string">"websocket连接关闭！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。</span></span><br><span class="line"><span class="built_in">window</span>.onbeforeunload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    websocket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将消息显示在网页上</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setMessageInnerHTML</span>(<span class="params">innerHTML</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//alert(innerHTML);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closeWebSocket</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    websocket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>).value;</span><br><span class="line">    websocket.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后端Java代码"><a href="#后端Java代码" class="headerlink" title="后端Java代码"></a>后端Java代码</h1><h2 id="WebSocketConfig"><a href="#WebSocketConfig" class="headerlink" title="WebSocketConfig"></a>WebSocketConfig</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.irlab.agriculture.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.standard.ServerEndpointExporter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入WebSocket Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocketServer"><a href="#WebSocketServer" class="headerlink" title="WebSocketServer"></a>WebSocketServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.irlab.agriculture.service.acl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.irlab.agriculture.controller.ACLController;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.websocket.*;</span><br><span class="line"><span class="keyword">import</span> javax.websocket.server.ServerEndpoint;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ServerEndpoint</span>(<span class="string">"/acl/websocket"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WebSocketServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录当前在线链接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger onlineCount = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放每个客户端对应的mywebsocket对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketServers = <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与某个客户端的链接会话，需要通过它来给客户端发送数据</span></span><br><span class="line">    <span class="keyword">private</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sid = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接建立成功的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        onlineCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        sid = session.getId();</span><br><span class="line">        webSocketServers.add(<span class="keyword">this</span>);</span><br><span class="line">        logger.info(<span class="string">"有新窗口开始监听:&#123;&#125;,当前在线人数为&#123;&#125;"</span>,session.getId(),webSocketServers.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接关闭的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>&#123;</span><br><span class="line">        onlineCount.decrementAndGet();</span><br><span class="line">        webSocketServers.remove(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        logger.info(<span class="string">"有窗口关闭,当前在线人数为&#123;&#125;"</span>,webSocketServers.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 收到客户端消息后调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(String message,Session session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">        logger.info(<span class="string">"收到来自窗口：&#123;&#125;的信息：&#123;&#125;"</span>,sid,message);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Session session,Throwable error)</span></span>&#123;</span><br><span class="line">        logger.error(<span class="string">"websocket发生错误："</span>,error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器主动推送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器群发消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendInfoToMany</span><span class="params">(String info)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">            logger.info(<span class="string">"推送消息到多个窗口"</span>);</span><br><span class="line">            <span class="keyword">if</span>(webSocketServers.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                logger.error(<span class="string">"没有注册的窗口！"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(WebSocketServer item:webSocketServers)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    item.sendMessage(info);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CopyOnWriteArraySet&lt;WebSocketServer&gt; <span class="title">getWebSocketServers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> webSocketServers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 最近给实验室做的个系统需要用docker打包到对方服务</summary>
      
    
    
    
    <category term="技术栈" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="Springboot" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/Springboot/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="WebSocket" scheme="https://ericzikun.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>实验室学姐问到可见性细节，被批浮于表面【可见性的原理初探】</title>
    <link href="https://ericzikun.github.io/2021/06/13/Deep4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>https://ericzikun.github.io/2021/06/13/Deep4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/</id>
    <published>2021-06-13T12:32:33.000Z</published>
    <updated>2021-06-26T07:36:25.763Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 之前也只是知道有可见性这么回事，但是原理不算很明白！今天把多线程的可见性原理梳理一下，原理弄懂，而非死记硬背！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 先看多线程例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 启动线程</span></span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.主线程继续</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (MyThread.a ==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"主线程读到了a=1"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程启动，休息2s..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"将a的值改为1"</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210613191915845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里启动了一个MyThread线程，并在主线程里面不断的去判断该成员变量a的值是否进行了修改，而实际情况是MyThread线程对值修改之后，主线程中并没有拿到这个最新的值而跳出while循环，那么这又是为啥呢？<br><img src="https://img-blog.csdnimg.cn/20210613192254802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当一个线程启动后，会单独建立一个栈供使用，那么这里就有主线程和新线程两个栈，启动线程后，栈内调用的成员变量、成员方法这些都是从同一个方法区中获取的，比如这里的MyThread.class静态区，拿到的都是方法区中的副本存到自己线程的栈内存当中，所以这个值就应该是线程启动当时的副本状态！只要不修改这个副本文件，就会一直使用这个副本，也不会重新去方法区拿。<br>当修改了副本后，他会立刻同步到方法区中，比如这里的新线程修改使得a=1，那么就会立刻去改方法区中MyThread.class静态区a的值为1，那么这个新线程今后用的值都是这个修改后的副本了，但是对于主线程，它拿到的一直是a修改之前的最开始的那个副本文件，所以对于主线程来说a=0。</p><blockquote><p><strong>总结1：</strong> 每个线程去使用共享内容时候，是把共享的内容复制一份副本到自己的栈内存<br><strong>总结2：</strong> 副本中的值发生改变时，立刻同步到方法区中<br><strong>总结3：</strong> 如果当前线程没有重新从方法区中拷贝副本，那么使用的资源还是上一次拿到的副本文件</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么，如何让主线程也拿到最新修改的方法区呢？也就是说如何再次获取一个最新的副本呢？有以下几个方法：</p><ol><li>让主线程<strong>sleep</strong>一下，那么线程休眠后再启动则会重新复制资源副本到主线程栈内存中。</li><li>给成员变量a设置<strong>volatile</strong>修饰符，保证其可见性！</li><li>使用<strong>同步代码块synchronized</strong>：只要遇到<strong>同步</strong>，那么线程也会重新去方法区拿最新的资源副本</li></ol><p>方法一：让主线程sleep而重新获取资源副本到栈内存当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 启动线程</span></span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.主线程继续</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (MyThread.a ==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"主线程读到了a=1"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程启动，休息2s..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"将a的值改为1"</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210613201001340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>方法二：使用volatile，直接给a变量加即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>方法三：使用同步代码块 synchronized，这里随便对什么加锁都行，都会重新向方法区请求最新资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//1. 启动线程</span></span><br><span class="line">        MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.主线程继续</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//            Thread.sleep(1);</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Demo<span class="class">.<span class="keyword">class</span>) </span>&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span> (MyThread.a ==<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"主线程读到了a=1"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程启动，休息2s..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"将a的值改为1"</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"线程结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 之前也只是知道有可见性这么回事，但是原理不算很明白！今天把多线程的可见性原理梳理一下，原理弄懂，而非死记硬背！&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="https://ericzikun.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
    <category term="可见性" scheme="https://ericzikun.github.io/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>对多线程稍作整理【多线程】</title>
    <link href="https://ericzikun.github.io/2021/06/11/Deep3-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://ericzikun.github.io/2021/06/11/Deep3-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-06-11T03:11:09.000Z</published>
    <updated>2021-06-29T05:58:55.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><ul><li><p>并发:指两个或多个事件在同一个时间段内发生。</p></li><li><p>并行:指两个或多个事件在同一时刻发生(同时发生)。</p></li></ul><p>注意辨析宏观与微观的理解</p><p><img src="https://img-blog.csdnimg.cn/20210611124507184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="&lt;img src=&quot;多线程笔记.assets/image-20210605152309555.png&quot; alt=&quot;image-20210605152309555&quot; style=&quot;zoom:50%;&quot; /&gt;"></p><p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有<strong>多个程序</strong>同时运行，这在单 CPU 系统中，每 一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分 时交替运行的时间是非常短的。</p><p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上(CPU)，实现多任务并行执行， 即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p><blockquote><p>注意:单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理,线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个 线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p></blockquote><h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><ul><li><p>进程:是指一个内存中运行的应用程序（比如打开一个软件 至少占用1个进程），每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程;进程也是程序的一次执行过程，是系统运行程序的基本单位;系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p></li><li><p>线程:线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。</p></li></ul><p><strong>简而言之:一个程序运行后至少有一个进程，一个进程中可以包含多个线程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">线程：CPU 可执行的最小任务单元 </span><br><span class="line"></span><br><span class="line">八核CPU -八核16线程  </span><br><span class="line">单核 单线程 CPU </span><br><span class="line"></span><br><span class="line">线程 让程序节省时间，提高效率</span><br><span class="line">多线程的CPU 可以看作可以并行运算的机器 </span><br><span class="line"></span><br><span class="line">单线程 - - 交替运行  不能节省时间提高效率</span><br><span class="line"> --同时运行的效果 </span><br><span class="line">CPU 运算速度特别快 </span><br><span class="line">在两个线程之间实现快速切换执行 </span><br><span class="line"></span><br><span class="line">进程：线程的老大 -- 程序运行</span><br></pre></td></tr></table></figure><h1 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度:"></a>线程调度:</h1><h2 id="分时调度"><a href="#分时调度" class="headerlink" title="分时调度"></a>分时调度</h2><p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</p><h2 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h2><p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为 <strong>抢占式调度</strong>。</p><ul><li><p>设置线程的优先级</p></li><li><p>抢占式调度详解</p><p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如:现在我们一边使用编辑器，一边使用腾讯会议软件，同时还开着qq、微信、IDEA等软件。此时，这些程序是 在同时运行，”<strong>感觉这些软件好像在同一时刻运行着“</strong>。</p><p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着<strong>高速的切换</strong>。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，<strong>让CPU的使用率更高</strong>。</p></li></ul><h1 id="Java实现线程的三个方法："><a href="#Java实现线程的三个方法：" class="headerlink" title="Java实现线程的三个方法："></a>Java实现线程的三个方法：</h1><h2 id="Thread-类"><a href="#Thread-类" class="headerlink" title="Thread 类"></a>Thread 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、创建一个类 继承 Thread </span><br><span class="line">2、重写run方法</span><br><span class="line">3、此类创建对象调用 start()方法</span><br><span class="line">每个线程对象都只能启动一次</span><br></pre></td></tr></table></figure><h2 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h2><pre><code>1、创建一个类  implements Runnable接口 2、重写run方法3、此类创建对象 交给Thread类对象调用 start()方法4、此类创建对象 交给线程池 调用 start()方法    每个线程对象都可以被Thread类对象重复启动         更轻量 方便 </code></pre><h2 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、创建一个类  implements Callable接口 </span><br><span class="line">2、重写call方法</span><br><span class="line">3、此类创建对象 交给线程池 调用 start()方法</span><br><span class="line">可以带有返回值</span><br></pre></td></tr></table></figure><p>三个方法之间的区别，优缺点：</p><table><thead><tr><th>&lt;!– 特点</th><th>Thread</th><th>Runnable</th><th>Callable</th></tr></thead><tbody><tr><td>优点</td><td>方便实现，代码简单</td><td>每个线程对象都可以被Thread类对象重复启动。<br/>实现接口，线程类就还能继承其它类，线程之间资源共享方便，不用加static进行修饰</td><td>实现接口，线程类就还能继承其它类,线程之间资源共享方便，不用加static进行修饰,线程可以有返回值,线程可以抛出异常</td></tr><tr><td>缺点</td><td>每个线程对象都只能启动一次 <br/>必须重写run方法run，方法不能有返回值，run方法不能抛出异常</td><td>必须重写run方法,run方法不能有返回值,run方法不能抛出异常</td><td>线程创建比较麻烦，代码比较复杂 –&gt;</td></tr></tbody></table><!-- ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210611150520309.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70) --><h1 id="线程状态："><a href="#线程状态：" class="headerlink" title="线程状态："></a>线程状态：</h1><p>一共有T1、T2、T3三个时间段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动 T1</span><br><span class="line"></span><br><span class="line">运行 </span><br><span class="line">等待消耗小T2</span><br><span class="line">计时等待</span><br><span class="line"></span><br><span class="line">终止 T3</span><br></pre></td></tr></table></figure><p>线程池：–  减少 T1 T3 所占的时间和资源<br><img src="https://img-blog.csdnimg.cn/2021061113283062.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和<strong>预期</strong>的是一样的，就是<strong>线程安全的</strong>。<br>这里以小球绘制为例：<br>背景：给画板添加点击事件，点击一次画板屏幕则创建一个小球线程<br>不加锁的情况下：<br>面板绘制主函数：<br>给画板添加点击事件ballLiten</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BallUI</span> <span class="keyword">extends</span> <span class="title">JFrame</span></span>&#123;</span><br><span class="line"></span><br><span class="line">BallUI()&#123;</span><br><span class="line">setTitle(<span class="string">"运动小球"</span>);</span><br><span class="line">setSize(<span class="number">600</span>,<span class="number">600</span>);</span><br><span class="line">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">setVisible(<span class="keyword">true</span>);</span><br><span class="line">Graphics g = getGraphics();<span class="comment">// 获取画笔对象</span></span><br><span class="line">BallListener ballLiten =<span class="keyword">new</span> BallListener(g);</span><br><span class="line">addMouseListener(ballLiten);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> BallUI();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写点击方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BallListener</span> <span class="keyword">implements</span> <span class="title">MouseListener</span></span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 点击一次 创建一个球 运动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Graphics g;</span><br><span class="line"></span><br><span class="line">BallListener(Graphics g)&#123;</span><br><span class="line"><span class="keyword">this</span>.g = g;</span><br><span class="line">&#125;</span><br><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseClicked</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">Color color = <span class="keyword">new</span> Color(random.nextInt(Integer.MAX_VALUE/<span class="number">200</span>));</span><br><span class="line">DrawBallThread dbt = <span class="keyword">new</span> DrawBallThread(g, e.getX(), e.getY(), <span class="number">30</span>,color);</span><br><span class="line">dbt.num=<span class="number">0</span>;</span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(dbt);</span><br><span class="line">t.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制运动的小球线程类(不加锁)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * implements Runnable每个线程 实际运行的内容是独立的</span></span><br><span class="line"><span class="comment"> * 成员属性是共享的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawBallThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">Graphics g;<span class="comment">// 保证可见</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">50</span>;</span><br><span class="line">Color color = Color.RED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DrawBallThread</span><span class="params">(Graphics g, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> size, Color color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.g = g;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> speedX=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> copynum = num;</span><br><span class="line"><span class="comment">//Random ran = new Random();</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//-------------------------不加锁的情况下--------------------</span></span><br><span class="line"><span class="comment">//g.setColor(new Color(238,238,238)); //灰色 先画背景 相当于清屏</span></span><br><span class="line"><span class="comment">//g.fillOval(x, y, size, size);</span></span><br><span class="line"><span class="keyword">if</span> (copynum ** <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;<span class="number">500</span>) &#123;</span><br><span class="line">speedX =-speedX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y&lt;<span class="number">0</span>||y&gt;<span class="number">500</span>) &#123;</span><br><span class="line">speedX =-speedX;</span><br><span class="line">&#125;</span><br><span class="line">x += speedX;</span><br><span class="line">y += speedX;</span><br><span class="line">&#125;</span><br><span class="line">g.setColor(color);</span><br><span class="line">g.fillOval(x, y, size, size);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">30</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210611135324644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p><strong>分析</strong>：<br>由图可见，在线程执行的方法中由于每个点击事件触发的线程拿到的都是同一个Graphics g对象，在一个线程启动后不久，另外点击而新开的线程拿到的仍然是同一个Graphics g对象，这里的Graphics g对象属于共享变量，它的color属性也是在不断变化的！从而导致各个线程之间的球颜色混乱！如果要解决此问题，则要将线程执行方法中的<strong>Graphics g对象这个共享变量加锁，保证它在当前线程运行结束的情况下才可被其他线程所调用</strong>，如下为加锁情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * implements Runnable每个线程 实际运行的内容是独立的</span></span><br><span class="line"><span class="comment"> * 成员属性是共享的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawBallThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">Graphics g;<span class="comment">// 保证可见</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> size = <span class="number">50</span>;</span><br><span class="line">Color color = Color.RED;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DrawBallThread</span><span class="params">(Graphics g, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> size, Color color)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.g = g;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line"><span class="keyword">this</span>.size = size;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> speedX=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> copynum = num;</span><br><span class="line"><span class="comment">//Random ran = new Random();</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//-------------------------加锁的情况下-------------------- synchronized (g) &#123;</span></span><br><span class="line"><span class="comment">//g.setColor(new Color(238,238,238)); //灰色 先画背景 相当于清屏</span></span><br><span class="line"><span class="comment">//g.fillOval(x, y, size, size);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">if</span> (copynum ** <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>||x&gt;<span class="number">500</span>) &#123;</span><br><span class="line">speedX =-speedX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y&lt;<span class="number">0</span>||y&gt;<span class="number">500</span>) &#123;</span><br><span class="line">speedX =-speedX;</span><br><span class="line">&#125;</span><br><span class="line">x += speedX;</span><br><span class="line">y += speedX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (g) &#123;</span><br><span class="line"><span class="comment">//g.setColor(Color.white);</span></span><br><span class="line"><span class="comment">//g.fillRect(0, 0, 500, 500);</span></span><br><span class="line"></span><br><span class="line">g.setColor(color);</span><br><span class="line"><span class="comment">//for (int i = 0; i &lt; 300; i++) &#123;</span></span><br><span class="line"><span class="comment">//g.fillOval(x, y, size, size);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">g.fillOval(x, y, size, size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">30</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210611135114185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>小结：<br>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量<strong>只有读操作，而无写</strong>操作，一般来说，这个全局变量是<strong>线程安全</strong>的;若有<strong>多个线程同时执行写</strong>操作，一般都需要考虑<strong>线程同步</strong>， 否则的话就可能影响线程安全。</p><h3 id="同步代码块、锁"><a href="#同步代码块、锁" class="headerlink" title="同步代码块、锁"></a>同步代码块、锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前面先引出了小球的案例，已对锁有了初步了解，现在详细介绍一下同步代码块、锁：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要解决上述多线程并发访问一个资源的安全性问题，Java中提供了同步机制 (synchronized)来解决。</p><p><strong>同步代码块</strong>: synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。<br>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">synchronized</span>(同步锁)&#123; 需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步锁: 对象的同步锁只是一个概念,可以想象为在对象上<strong>标记了一个锁</strong>。</p><ol><li><strong>锁对象</strong> 可以是任意类型。</li><li>多个线程对象 要使用同一把锁。<blockquote><p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 (BLOCKED)。</p></blockquote></li></ol><p><strong>同步方法</strong>: 使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外<br>等着。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123; 可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Lock锁</strong>：<code>java.util.concurrent.locks.Lock</code>机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,<br>同步代码块/同步方法具有的功能Lock都有,除此之外更强大,更体现面向对象。 Lock锁也称同步锁，加锁与释放锁方法化了，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> :加同步锁。 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> :释放同步锁。</span></span><br></pre></td></tr></table></figure><p>举例：<br>在线程执行方法的前后<strong>执行锁对象的lock、unlock</strong>方法达到加锁和释放锁的目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123; <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">/*</span></span><br><span class="line"><span class="comment">* 执行卖票操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//每个窗口卖票的操作 //窗口 永远开启 while(true)&#123;</span></span><br><span class="line">lock.lock(); </span><br><span class="line"><span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;<span class="comment">//有票 可以卖</span></span><br><span class="line"><span class="comment">//出票操作 //使用sleep模拟一下出票时间 try &#123;</span></span><br><span class="line">Thread.sleep(<span class="number">50</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto‐generated catch block</span></span><br><span class="line">e.printStackTrace(); &#125;</span><br><span class="line"><span class="comment">//获取当前线程对象的名字</span></span><br><span class="line">String name = Thread.currentThread().getName(); </span><br><span class="line">System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">&#125;</span><br><span class="line">lock.unlock(); </span><br><span class="line">&#125;</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p>几个安全相关的概念普及：</p><p><strong>原子性</strong>：即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</p><p><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<strong>常采用volatile</strong>去修饰变量，能够保证各个线程的一致可见性，也就是当一个线程修改了变量值后，别的线程能够看到</p><p><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。</p><pre><code>num=1;  -- 1 num++  2 num++  数据安全不能保证 volatile    -- 一致可见性 不能保证线程数据安全synchronized -- 重量级锁 性能优秀 -- 不方便 -- 实现锁机制 --  保证原子性 final 原子操作：载入 堆中共享变量  写回变量  lock unlock     保证数据原子性的操作：        一个个来    文件操作：        读 写     所有线程 只读 -- 共享     线程 一个读   一个写 -- 必须实现 锁 排队     所有线程  写 写 - 必须实现 锁        JUC     ArrayList -- 增删查改 -- 原子操作的是：增删改 Redis -- 单线程 方法 ：分别对哪些资源对象进行加锁     方法中使用的变量     方法所在类的对象 </code></pre><p>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​<br>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发与并行&quot;&gt;&lt;a href=&quot;#并发与并行&quot; class=&quot;headerlink&quot; title=&quot;并发与并行&quot;&gt;&lt;/a&gt;并发与并行&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;并发:指两个或多个事件在同一个时间段内发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并行:指两个或多个</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Java" scheme="https://ericzikun.github.io/tags/Java/"/>
    
    <category term="多线程" scheme="https://ericzikun.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="并发" scheme="https://ericzikun.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>二维码也不过如此嘛，手写二维码玩一下【计算机基础：二进制+字节+移位运算】</title>
    <link href="https://ericzikun.github.io/2021/06/09/Deep5-%E6%89%8B%E5%86%99%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>https://ericzikun.github.io/2021/06/09/Deep5-%E6%89%8B%E5%86%99%E4%BA%8C%E7%BB%B4%E7%A0%81/</id>
    <published>2021-06-09T10:11:01.000Z</published>
    <updated>2021-06-26T07:35:54.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其实二维码就是由URL字符串转换得到的，那么手写一个最简单的字符与图像的转换如何实现呢？下面请看</p><h2 id="字符串转二维码"><a href="#字符串转二维码" class="headerlink" title="字符串转二维码"></a>字符串转二维码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Color;</span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryString</span> <span class="keyword">extends</span> <span class="title">JFrame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">setTitle(<span class="string">"二维码"</span>);</span><br><span class="line">setSize(<span class="number">800</span>, <span class="number">600</span>);</span><br><span class="line">setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">setVisible(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.paint(g);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] binaryArray = stringToBinaryArray(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">int</span>[][] imgdata = <span class="keyword">new</span> <span class="keyword">int</span>[binaryArray.length/<span class="number">16</span>][<span class="number">16</span>]; <span class="comment">//</span></span><br><span class="line">BufferedImage buffimg = <span class="keyword">new</span> BufferedImage(<span class="number">160</span>,(binaryArray.length/<span class="number">16</span>)*<span class="number">10</span>,BufferedImage.TYPE_INT_ARGB);</span><br><span class="line">Graphics g2 = buffimg.getGraphics();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgdata.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgdata[i].length; j++) &#123;</span><br><span class="line">imgdata[i][j] = binaryArray[i*<span class="number">16</span>+j];</span><br><span class="line"><span class="keyword">if</span>(imgdata[i][j]==<span class="number">48</span>) &#123;</span><br><span class="line">g2.setColor(Color.white);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">g2.setColor(Color.black);</span><br><span class="line">&#125;</span><br><span class="line">g2.fillRect(j*<span class="number">10</span>, i*<span class="number">10</span>,<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">g.drawImage(buffimg, <span class="number">100</span>, <span class="number">100</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] stringToBinaryArray(String srcStr) &#123;</span><br><span class="line">String link = <span class="string">"http://www.bilibili.com 天气不错"</span>; <span class="comment">//28个字符</span></span><br><span class="line"><span class="comment">//String link = "http://www.baidu.com 天气"; //28个字符</span></span><br><span class="line"><span class="comment">// 二进制 Str -&gt; 二进制码</span></span><br><span class="line"><span class="comment">// 转成char</span></span><br><span class="line"><span class="keyword">int</span> strLength = link.length();</span><br><span class="line"><span class="keyword">int</span>[] binaryData = <span class="keyword">new</span> <span class="keyword">int</span>[strLength * <span class="number">16</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLength; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> c = link.charAt(i);</span><br><span class="line"></span><br><span class="line">String binaryStr = Integer.toBinaryString(c);</span><br><span class="line">System.out.println(<span class="string">"------缺码------"</span>);</span><br><span class="line">System.out.println(c);</span><br><span class="line">System.out.println(binaryStr);<span class="comment">// 缺码</span></span><br><span class="line"><span class="comment">// 补码：在前补 0</span></span><br><span class="line"><span class="keyword">int</span> binaryStrLength = binaryStr.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (binaryStrLength &lt; <span class="number">16</span>) &#123;</span><br><span class="line">binaryStr = <span class="string">"0"</span> + binaryStr;</span><br><span class="line">binaryStrLength++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"------全码------"</span>);</span><br><span class="line">System.out.println(binaryStr);<span class="comment">// 全码</span></span><br><span class="line">System.out.println(<span class="string">"--存入binaryData--"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">16</span>; j++) &#123;</span><br><span class="line">System.out.println(binaryStr.charAt(j));</span><br><span class="line">binaryData[i * <span class="number">16</span> + j] = binaryStr.charAt(j);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"------binaryData-------"</span>);</span><br><span class="line">System.out.println(binaryData);</span><br><span class="line">System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryData.length; i++) &#123;</span><br><span class="line">System.out.print(binaryData[i]);</span><br><span class="line">System.out.print(<span class="string">" "</span>);</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">16</span>) &#123;</span><br><span class="line">System.out.println();</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> binaryData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>BinaryString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20210613223458780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70#pic_center" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20210613223458780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70#pic_center</a> =200x400)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里输入的字符串为：”<a href="http://www.bilibili.com" target="_blank" rel="noopener">http://www.bilibili.com</a> 天气不错“，由图可以清晰看出由于是16位，那么前面字母部分的二进制则均为0，只有后面才有黑色的1，英文字母只占满了后8位，而最后四个中文字符，才有16位进行二进制编码，占满了全部16位，不懂为啥英文占8位，中文得16位的请看另一篇讲字符串二进制的文章 <a href="https://blog.csdn.net/popofzk/article/details/117712441?spm=1001.2014.3001.5501" target="_blank" rel="noopener">计算机基础：二进制+字节+移位运算</a></p><h2 id="二维码转字符串"><a href="#二维码转字符串" class="headerlink" title="二维码转字符串"></a>二维码转字符串</h2><p>大致思路：</p><ol><li>读取到二维码图片，用数组存储rgb像素值，再把黑白色转成0、1二进制</li><li>每一个字符得到整理成一个二进制字符串（16位）。</li><li>再把二进制字符串转String字符串（二进制字符串先转十进制数字，十进制再转字符串）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code2String</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public String picPath;</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setH</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setW</span><span class="params">(<span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] getImagePix(String picPath)&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(picPath);</span><br><span class="line">        BufferedImage img = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            img = ImageIO.read(file);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> w = img.getWidth();</span><br><span class="line">        <span class="keyword">int</span> h = img.getHeight();</span><br><span class="line">        setH(h);</span><br><span class="line">        setW(w);</span><br><span class="line">        System.out.println(</span><br><span class="line">                <span class="string">"图片宽度为："</span>+ w+ <span class="string">" 图片长度为："</span>+h</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">int</span>[][] imgArr = <span class="keyword">new</span> <span class="keyword">int</span> [h][w];</span><br><span class="line">        System.out.println(<span class="string">"---------imgArr----length"</span>);</span><br><span class="line">        System.out.println(imgArr.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imgArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; imgArr[i].length; j++) &#123;</span><br><span class="line">                imgArr[i][j] =img.getRGB(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> imgArr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">binaryToString</span><span class="params">(ArrayList&lt;String&gt; binaryStringList)</span></span>&#123;</span><br><span class="line">        String resultString = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryStringList.size(); i++) &#123;</span><br><span class="line">            String binaryString = binaryStringList.get(i);</span><br><span class="line"><span class="comment">//            System.out.println("------二进制转十进制数字------");</span></span><br><span class="line">            <span class="keyword">int</span> binaryInt=Integer.parseInt(binaryString, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> [] arrayS = &#123;binaryInt&#125;;</span><br><span class="line"><span class="comment">//            System.out.println("------十进制转字符串-------");</span></span><br><span class="line">            String s = <span class="keyword">new</span> String(arrayS,<span class="number">0</span>,arrayS.length);</span><br><span class="line">            resultString += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultString;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">codeParsing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [][] imgArr = getImagePix(<span class="string">"img/pic1.png"</span>);</span><br><span class="line">        <span class="keyword">int</span> zoom = Math.round((<span class="keyword">float</span>)w/<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">int</span> [][] binaryArr = <span class="keyword">new</span> <span class="keyword">int</span>[h/zoom][<span class="number">16</span>]; <span class="comment">//28x16</span></span><br><span class="line">        System.out.println(<span class="string">"---zoom---"</span>);</span><br><span class="line">        System.out.println(zoom);</span><br><span class="line">        System.out.println(<span class="string">"---------binaryArr.length---------"</span>);</span><br><span class="line">        System.out.println(binaryArr.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryArr.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; binaryArr[i].length; j++) &#123;</span><br><span class="line"><span class="comment">//                System.out.println("---------binaryArr[i].length--------");</span></span><br><span class="line"><span class="comment">//                System.out.println(binaryArr[i].length);</span></span><br><span class="line"><span class="comment">//                System.out.println("第" + i + " 第"+j);</span></span><br><span class="line"><span class="comment">//                System.out.println(j);</span></span><br><span class="line"><span class="comment">//                System.out.println("---------imgArr[i*zoom][j*zoom]---------");</span></span><br><span class="line"><span class="comment">//                System.out.println(imgArr[i*zoom][j*zoom]);</span></span><br><span class="line">                <span class="keyword">int</span> rgbValue = imgArr[i*zoom][j*zoom];</span><br><span class="line">                <span class="keyword">int</span> red,green,blue;</span><br><span class="line">                red = rgbValue &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">                green = rgbValue &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">                blue = rgbValue &gt;&gt; <span class="number">0</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">                <span class="keyword">int</span> gray = (red + green + blue) / <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (gray == <span class="number">0</span>)&#123;<span class="comment">//黑色</span></span><br><span class="line">                    binaryArr[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    binaryArr[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                System.out.println("存入的值"+ gray);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"--------------binaryArr二进制字符串-------------"</span>);</span><br><span class="line">        ArrayList&lt;String&gt; binaryStringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; binaryArr.length; i++) &#123;</span><br><span class="line">            String curString = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; binaryArr[i].length; j++) &#123;</span><br><span class="line">                System.out.print(binaryArr[i][j]);</span><br><span class="line">                curString += binaryArr[i][j];</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            binaryStringList.add(curString);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-------------二进制字符串转String字符串-----------"</span>);</span><br><span class="line">        String binaryToString = binaryToString(binaryStringList);</span><br><span class="line">        System.out.println(binaryToString);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Code2String code2String = <span class="keyword">new</span> Code2String();</span><br><span class="line">        code2String.codeParsing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 其实二维码就是由URL字符串转换得到的，那么手写一个最</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="计算机基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://ericzikun.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="程序是怎样跑起来的" scheme="https://ericzikun.github.io/tags/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    
    <category term="二进制" scheme="https://ericzikun.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="字节" scheme="https://ericzikun.github.io/tags/%E5%AD%97%E8%8A%82/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>原码、补码，字符串的底层存储都不懂，还敢说学过计算机？【计算机基础：二进制+字节+移位运算】</title>
    <link href="https://ericzikun.github.io/2021/06/08/Deep2%EF%BC%9A%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6+%E5%AD%97%E8%8A%82+%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%91/"/>
    <id>https://ericzikun.github.io/2021/06/08/Deep2%EF%BC%9A%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6+%E5%AD%97%E8%8A%82+%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%91/</id>
    <published>2021-06-08T10:11:01.000Z</published>
    <updated>2021-06-29T05:57:51.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h1><p>提到二进制，为啥计算机底层数据存储都采用二进制呢？计算机内部事由IC电子部件构成，IC的一个引脚，只能表示两个状态（《程序是怎样跑起来的》第二章）</p><img src="https://img-blog.csdnimg.cn/20210608182649936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h1 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h1><p>二进制的数一般是8位、16、32，8位的二进制数被称为一个字节，字节是最基本的信息计量单位，而位是最小单位，字节是基本单位，内存和磁盘都是用字节来储存和读写数据，使用位单位则无法读写数据，因此，字节是基本单位</p><h2 id="位bit"><a href="#位bit" class="headerlink" title="位bit"></a>位bit</h2><p>bit位:位是==计算机存储的最小单位==简称为b也称为比特(bit)例如1b,2b,3b<br>byte字节:byte字节是计算机用于计量存储容量的,一种计量单位<br>1byte= 8bit<br>1byte =1B<br>1byte=存1个字母<br>2byte=存一个汉字</p><p>32位和62位系统有什么区别：</p><ol><li>处理数据能力不同：64位的一次可以处理64位的数据，向下兼容，比如32位 16位</li><li>支持的内存不同，或者说寻址能力不同：32位的最多支持4gb的内存，而64最多支持上百g的内存</li><li>架构不同</li><li>对配置要求不同，32位系统需要32位的配套系统安装</li></ol><p>疑问：既然有32 64，那有没有128位呢？</p><p>字符：电子计算机或者说是无线电通信中字母、数字、符号的统称</p><h2 id="各类型占用比特（bit）"><a href="#各类型占用比特（bit）" class="headerlink" title="各类型占用比特（bit）"></a>各类型占用比特（bit）</h2><img src="https://img-blog.csdnimg.cn/2021060818305690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>1个byte（字节）= 8位（bit），每一位就是0、1二进制，那么8位就能储存$2^8=256$个数字，所以1个字节能够代表256个数字，取值范围在-128~127</li><li>以此类推，1个short（短整型）=16位，那么就能储存$2^{16}=65535$个，取值范围就在-32768~32767</li></ul><h2 id="吃透字符："><a href="#吃透字符：" class="headerlink" title="吃透字符："></a>吃透字符：</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>字符的历史比较复杂：<br>分为可见字符和控制字符：</p><ul><li>可见字符：英文字母、数字、标点符号</li><li>控制字符：如 换行、回车等</li></ul><img src="https://img-blog.csdnimg.cn/20210608223909373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" />如图，将这0~127（128个）的编号称作==码位==，代表了字符的id信息，再把这每个字符的码位转化二进制信息进行存储，这样的二进制信息为ASCII码：<img src="https://img-blog.csdnimg.cn/20210609170132592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>但是原始128个ASCII码字符过于少，仅满足==美国==需求，为了满足==欧洲等国家==字符集的需求，又对ASCII进行了扩充，从128扩充到255，那么ASCII码也就只能表示256个字符，对于==中国==来说，实在太少！</p><p>因为8位最多只能表示256个字符，对于中文来说，有几千个中文字符，我们则必须用16位表示一个字符了！那么要先设计字符集：</p><h3 id="GB2312字符集"><a href="#GB2312字符集" class="headerlink" title="GB2312字符集"></a>GB2312字符集</h3><p>使用分区管理，共计94个区，每个区含94个位，共8836个码位。<br>先介绍一下码位：<br><img src="https://img-blog.csdnimg.cn/2021060920062834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><br> <img src="https://img-blog.csdnimg.cn/2021060920050574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><br> <img src="https://img-blog.csdnimg.cn/20210609200829267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>前面的ASCII码可以直接转为二进制来存储，GB2312如何存储？<br><img src="https://img-blog.csdnimg.cn/20210609201044655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><br>GBK2312的高位和低位都大于127，那么计算机只要碰到大于127的字节就是汉字的开始<br><img src="https://img-blog.csdnimg.cn/2021061110542046.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>那么，世界上就会有不同的编码，会非常乱！<br><img src="https://img-blog.csdnimg.cn/20210611105453827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /></p><p>ISO组织为了解决这个问题，开始规范化编码！提出了Unicode，目的就是把世界上所有字符放在一起并编号<br><img src="https://img-blog.csdnimg.cn/20210611105733928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但是ASCII本来也只需要8位、GB2312只用16位，这里的UCS字符集需要32位，扩大了4倍、2倍，导致Unicode提出后并没有被广泛接受，而后期各国交流更加频繁，从而新生了一个新编码UTF-8<br>UTF-8每次传送8位数据，是一种可变长的编码格式<br><img src="https://img-blog.csdnimg.cn/20210611110356437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算<img src="https://img-blog.csdnimg.cn/20210608183243416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></h1><p>移位运算指的是将二进制数值各个数位进行左右移位（shift）的运算，移位有左移、右移两种。<br>左移好理解，就是将原数值乘以2的n次幂，但是右移要注意了！二进制中的最高位表示的是符号（1代表负数，0代表正数），<br>eg：那么-1用8位如何表示呢？<br>大部分人会理解成：1的二进制是00000001，那么-1就是10000001，答案错！正确为：11111111。<br>计算机做减法运算时，实际上内部是加法，那么表示负数，就要用到正数的==补数==表示，补数=正数取反+1；<br>验证：1+（-1）=</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000001</span></span><br><span class="line">+<span class="number">1111111</span></span><br><span class="line">   <span class="number">10000000</span></span><br></pre></td></tr></table></figure><p>这里相加后是9位，其中最高位的1溢出，答案为0，符合。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 仔细思考一下补数整个的机制，就不难理解如-32768至32767、 -128至127这些数据表示大范围为何正数最大值都比负数最大小1了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二进制&quot;&gt;&lt;a href=&quot;#二进制&quot; class=&quot;headerlink&quot; title=&quot;二进制&quot;&gt;&lt;/a&gt;二进制&lt;/h1&gt;&lt;p&gt;提到二进制，为啥计算机底层数据存储都采用二进制呢？计算机内部事由IC电子部件构成，IC的一个引脚，只能表示两个状态（《程序是怎样跑起</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="计算机基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://ericzikun.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="程序是怎样跑起来的" scheme="https://ericzikun.github.io/tags/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/"/>
    
    <category term="二进制" scheme="https://ericzikun.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="字节" scheme="https://ericzikun.github.io/tags/%E5%AD%97%E8%8A%82/"/>
    
    <category term="移位运算" scheme="https://ericzikun.github.io/tags/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>儿子到底继承了爸爸哪些优良传统？【OOP+继承+接口】</title>
    <link href="https://ericzikun.github.io/2021/05/28/Deep1%EF%BC%9A%E3%80%90OOP-%E7%BB%A7%E6%89%BF-%E6%8E%A5%E5%8F%A3%E3%80%91/"/>
    <id>https://ericzikun.github.io/2021/05/28/Deep1%EF%BC%9A%E3%80%90OOP-%E7%BB%A7%E6%89%BF-%E6%8E%A5%E5%8F%A3%E3%80%91/</id>
    <published>2021-05-28T10:22:49.000Z</published>
    <updated>2021-06-29T05:53:46.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在Java中，继承是类与类之间的一种关系，分为父类和子类两种。这里和接口区分一下：一个类只能继承一个父类，而不能继承多个——即单继承关系；而一个类却可以实现多个接口。如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>子类继承了父类的所有内容，但是对于不同访问修饰父类修饰的属性方法，子类所调用的权限也不相同。对于public关键词修饰的属性和方法，子类同一个项目下都可以继承和调用。protected关键词修饰的属性和方法，可以在同包下和子类继承关系下继承和调用。对于缺省关键词的方法和属性，只能在同包下继承的调用，但是对于private修饰符修饰的属性和方法，只能自己该类使用。<br>子类继承父类的方法后，还可以根据需要重写其该方法。重写方法的名称必须与父类相同，访问修饰符可以和父类相同也可以比父类权限更大、返回值类型可以和父类相同也可以是父的子类，这样可以丰富扩展子类继承父类的方法。<br>对于继承父类的子类方法，在初始化方法时可以使用父类容器来初始化子类</p><h1 id="OOP"><a href="#OOP" class="headerlink" title="OOP"></a>OOP</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="继承的内容"><a href="#继承的内容" class="headerlink" title="继承的内容"></a>继承的内容</h3><ol><li>子类继承到父类的哪些东西？</li></ol><p>所有</p><ol start="2"><li>子类以及子类对象可以调用到继承的哪些属性和方法？</li></ol><p>要看 父类的属性、方法的具体==访问修饰符==：</p><table><thead><tr><th>访问修饰符</th><th>访问范围</th></tr></thead><tbody><tr><td>public</td><td>项目里</td></tr><tr><td>private</td><td>类里</td></tr><tr><td>protected</td><td>包下，不同包的子类</td></tr><tr><td>缺省</td><td>同包下</td></tr></tbody></table><p>那么对于子类来说，</p><p>同包下：</p><p>​    只有private不能调用</p><p>不同包下：</p><p>​    public，protected 可以调用</p><p>==protected== 受保护的，子类不能访问父类的私有字段。不过有时候希望限制<strong>父类中的某个方法只允许子类访问</strong>，或者<strong>希望子类的方法访问超类的某个字段</strong>。</p><h3 id="方法重写："><a href="#方法重写：" class="headerlink" title="方法重写："></a>方法重写：</h3><p>注解格式：除方法体之外与父类一致</p><h4 id="访问修饰符："><a href="#访问修饰符：" class="headerlink" title="访问修饰符："></a>访问修饰符：</h4><p>子类中重写的方法，与父类权限一致或者大于（因为子类继承，希望它有更强的扩展性，所以权限理应更大）</p><h4 id="返回值类型："><a href="#返回值类型：" class="headerlink" title="返回值类型："></a>返回值类型：</h4><p>与父类方法的返回值类型类/子类</p><h4 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h4><p>参数类型 不能修改</p><p>对于子类而言：子类及子类对象可以优先调用重写之后的</p><h4 id="重载："><a href="#重载：" class="headerlink" title="重载："></a>重载：</h4><p>方法名相同，参数不一致（子类 父类也可以实现重载，并不会归为一种类型）</p><h4 id="自动转型："><a href="#自动转型：" class="headerlink" title="自动转型："></a>自动转型：</h4><p>强制转型：int i = (int)1.2;<br>        A a = new B();<br>        A 是 B 的 父类——&gt; 祖先<br>        向上转型 之后 还会优先调用重写的方法吗？<br>            会</p><p>子类对像  向上 -&gt; 父类类型 ——&gt;向下转回子类类型 【可以】<br>父类对象 –&gt; 向下转型 子类类型 （==对象 无中生有== 子类可能有一些特别的属性方法 父类没有）【不可以】</p><p>==注意==：子类向上转型后，只能调用父类有的方法，并且是调的子类覆盖重写的，而不能调用子类独立的方法；子类独有的方法在父类中根本没有定义，所以父类无法找到子类独有的方法。</p><p>任务：一个类实例化的加载过程：</p><p>顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.加载静态成员&#x2F;代码块：</span><br><span class="line"></span><br><span class="line">先递归地加载父类的静态成员&#x2F;代码块(Object的最先)；再依次加载到本类的静态成员。</span><br><span class="line">同一个类里的静态成员&#x2F;代码块，按写代码的顺序加载。</span><br><span class="line">如果其间调用静态方法，则调用时会先运行静态方法，再继续加载。同一个类里调用静态方法时，可以不理会写代码的顺序。</span><br><span class="line">调用父类的静态成员，可以像调用自己的一样；但调用其子类的静态成员，必须使用“子类名.成员名”来调用。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.加载非静态成员&#x2F;普通代码块，初始化构造方法：（实例块在创建对象时才会被加载。而静态成员在不创建对象时可以加载）</span><br><span class="line"></span><br><span class="line">先递归地加载父类的非静态成员&#x2F;代码块(Object的最先)，非静态成员和代码块按代码出现顺序加载，并在加载完非静态成员后初始化构造方法；再依次加载到本类的非静态成员，并初始化构造方法，默认为无参构造，当然也可以指定父类初始化构造方法，和本类初始化构造方法。在子类构造方法中用super(参数列表);可以指定初始化父类构造方法，默认不写super(参数列表)为初始化父类无参构造方法。</span><br><span class="line">同一个类里的非静态成员&#x2F;普通代码块，按写代码的顺序加载。同一个类里调用方法时，可以不理会写代码的顺序。</span><br><span class="line">但调用属性时，必须注意加载顺序。一般编译就会不通过。</span><br><span class="line">调用父类的非静态成员(private 除外)，也可以像调用自己的一样。</span><br></pre></td></tr></table></figure><p>问题：静态代码块只加载一次，静态方法先于静态代码块？<br>这里要看情况，我这里样例是 由于声明成员变量时调用到了静态方法 所以静态方法优先于静态代码块 但实际上这两者本没有优先区别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">     <span class="keyword">static</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(<span class="string">"Static Init Base "</span> + a);</span><br><span class="line">         <span class="comment">//System.out.println("Null Init " + b);</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Init Base "</span> + <span class="keyword">this</span>.b);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *一级子类和基类包含的内容一样</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  <span class="comment">//静态变量、静态块执行顺序，按书写先后顺序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a1 = getSuperStaticNumber();</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> b1 = getSuperInstanceNumber();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">SuperClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Init SuperClass"</span> + <span class="keyword">this</span>.b1);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(<span class="string">"Static Init SuperClass"</span> + a1);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSuperStaticNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Static member init"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSuperInstanceNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Instance member init"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  *二级子类为测试该代码的驱动类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a2 = getStaticNumber();</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">int</span> b2 = getInstanceNumber();</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Sub</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Init SubClass "</span> + <span class="keyword">this</span>.b2);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStaticNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Static member init Sub"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInstanceNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"Instance member init Sub"</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">2000</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span></span><br><span class="line">     &#123;</span><br><span class="line">         System.out.println(<span class="string">"Static Init "</span> + a2);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 程序入口,main</span></span><br><span class="line"><span class="comment">      * </span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">new</span> Sub();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><!-- ![在这里插入图片描述]() --><img src="https://img-blog.csdnimg.cn/20210527153502546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70"  style="zoom:50%;" /><p>几个面试常见问题：</p><ul><li>请解释hashCode()和equals()方法有什么联系？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java对象的eqauls方法和hashCode方法是这样规定的：</span><br><span class="line"></span><br><span class="line">➀相等（相同）的对象必须具有相等的哈希码（或者散列码）。</span><br><span class="line"></span><br><span class="line">➁如果两个对象的hashCode相同，它们并不一定相同。</span><br></pre></td></tr></table></figure></li><li>若对一个类不重写，它的equals()方法是如何比较的？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">地址</span><br></pre></td></tr></table></figure></li><li>请说明Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。</span><br><span class="line">与此相对，方法覆盖是说子类重新定义了父类的方法。</span><br><span class="line">方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</span><br></pre></td></tr></table></figure></li><li>请判断，两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不对，如果两个对象x和y满足x.equals(y) &#x3D;&#x3D; true，它们的哈希码（hash code）应当相同。</span><br><span class="line">Java对于eqauls方法和hashCode方法是这样规定的：</span><br><span class="line">(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</span><br><span class="line">(2)如果两个对象的hashCode相同，它们并不一定相同。</span><br><span class="line">当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降</span><br><span class="line">（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）</span><br></pre></td></tr></table></figure></li><li>请判断当一个对象被当作参数传递给一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是值传递。Java 编程语言只有值传递参数。</span><br><span class="line">当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。</span><br><span class="line">对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</span><br></pre></td></tr></table></figure>==Java是值传递== 就算传的是对象 也是传的对象地址<br><a href="https://www.zhihu.com/question/31203609/answer/164430457" target="_blank" rel="noopener">https://www.zhihu.com/question/31203609/answer/164430457</a><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要==实现接口里面所有的方法和属性==，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;在Java中，继承是类与类之间的一种关系，分为父类和子类两种。这里和接口区分一下：一个类只能继承一个父类，而不能继承多个——即单继承关系；而</summary>
      
    
    
    
    <category term="深入" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/"/>
    
    <category term="Java基础" scheme="https://ericzikun.github.io/categories/%E6%B7%B1%E5%85%A5/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ericzikun.github.io/tags/java/"/>
    
    <category term="OOP" scheme="https://ericzikun.github.io/tags/OOP/"/>
    
    <category term="继承" scheme="https://ericzikun.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="接口" scheme="https://ericzikun.github.io/tags/%E6%8E%A5%E5%8F%A3/"/>
    
    <category term="提升" scheme="https://ericzikun.github.io/tags/%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>Docker 集成多容器镜像实 践:Jdk8,py37,Mysql,es,采用Dockfile+docker-compose编排</title>
    <link href="https://ericzikun.github.io/2021/01/29/Docker-%E9%9B%86%E6%88%90%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%9E-%E8%B7%B5-Jdk8-py37-Mysql-es-%E9%87%87%E7%94%A8Dockfile-docker-compose%E7%BC%96%E6%8E%92/"/>
    <id>https://ericzikun.github.io/2021/01/29/Docker-%E9%9B%86%E6%88%90%E5%A4%9A%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%9E-%E8%B7%B5-Jdk8-py37-Mysql-es-%E9%87%87%E7%94%A8Dockfile-docker-compose%E7%BC%96%E6%8E%92/</id>
    <published>2021-01-29T13:50:19.000Z</published>
    <updated>2021-05-28T10:28:35.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><img src="https://img-blog.csdnimg.cn/202101292257120.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于一个较大的项目(Jdk8+py37+Mysql+es)，如果仅仅使用一个容器做部署，安装过程可能会极其复杂，并且并不利于后期各模块的更新，为了方便他人，也为了快速生成镜像部署，对于多服务的项目，我采用了Dock-compose技术生成多容器，并进行编排，第一次做，耗时3天成功，有不少经验分享于此，便于以后快速部署环境！</p><h1 id="1-Mysql"><a href="#1-Mysql" class="headerlink" title="1. Mysql"></a>1. Mysql</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 强烈不建议自己先生成一个干净的centos，然后进到容器里面安装Mysql，这个过程谁试过谁知道，很耗时间并且不易成功！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一开始我已经调通了Springboot和es在一个容器，本想着装一个Mysql就基本结束了，谁料这将会是一个大坑！！<br>最终的Mysql方案，直接采用Dockerhub官方镜像，<br><img src="https://img-blog.csdnimg.cn/20210129220051755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里补充几点，对于Mysql，一般需要初始化sql，可以改动docker-entrypoint.sh文件，并替换进容器里，该文件内容修改地方如下，这里我只是一个空库空表：<br><img src="https://img-blog.csdnimg.cn/20210129220459734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么这个文件如何得到？可以先启动这个容器，然后用cp命令考出来，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  d5200819a46d:/usr/local/bin/docker-entrypoint.sh .</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 启动Docker-compose.yaml中的单个容器，如只启动Mysql：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d mysql</span><br></pre></td></tr></table></figure><h1 id="2-es-amp-Jdk8"><a href="#2-es-amp-Jdk8" class="headerlink" title="2.es &amp; Jdk8"></a>2.es &amp; Jdk8</h1><h2 id="2-1-es"><a href="#2-1-es" class="headerlink" title="2.1 es"></a>2.1 es</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这两个相对容易一点，只需要配好jdk8环境即可，如果都放一个容器里面容易出内存问题，且不方便看两个服务的日志，并不利于调试，故拆成两个容器最好！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; es：本地的整个es文件夹放进容器内即可，这里我先用dockerfile配好了一个含有jdk8及es文件夹的容器，然后commit成一个新的镜像es:vcoustom，再丢进docker-compose进行编排：<br><img src="https://img-blog.csdnimg.cn/20210129221137232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里的解释一下为何把9201对宿主机进行了映射，为了方便调试，在localhost:9201下看到es的数据结构页面。<br>es文件夹内的端口配置，elasticsearch.yml<br><img src="https://img-blog.csdnimg.cn/20210129221437303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>tcp端口配置(与Java通信)：<br><img src="https://img-blog.csdnimg.cn/20210129221520837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>es启动的报错：</strong><br>这里的cluster.routing.allocation.disk.threshold_enabled一定要配，否则容易报空间不足的问题<br>如果es启动报内存不足问题，修改config/jvm.options,将1g改小到512m解决问题，减小启动内存的消耗<br><img src="https://img-blog.csdnimg.cn/2021012922184722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>es容器采用dockerfile生成镜像：</strong><br><img src="https://img-blog.csdnimg.cn/20210129222219167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="2-2-Springboot项目"><a href="#2-2-Springboot项目" class="headerlink" title="2.2 Springboot项目"></a>2.2 Springboot项目</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 很简单，只需要配好jdk8环境即可，这里需要注意一下工作路径，也就是执行最终启动命令的位置，否则jar包启动时不会扫描当前jar包所在目录下的文件<br><img src="https://img-blog.csdnimg.cn/2021012922253052.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该Springboot项目只需jdk9环境。所以和前面的es写的dockerfile类似，只改COPY内容即可</p><h1 id="python模块"><a href="#python模块" class="headerlink" title="python模块"></a>python模块</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该模块在整个Springboot项目中承担了一个django接口，所以也不难配置，只需拉取一个python37镜像，简单配置<br><img src="https://img-blog.csdnimg.cn/20210129222859352.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里我采用了另一种docker-compose的写法，就是直接在yaml里面写好镜像的build方法，CMD在dockerfile里面已经写了，那么docker-compose.yaml内就不用写了<br><img src="https://img-blog.csdnimg.cn/20210129223015878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里的几个容器我分别采用了三种方式写docker-compose，殊途同归，但是自己去体会，他的目的以及侧重点还是不一样的！<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果我们需要将整个目录发给别人去部署，那么就尽量不要用save命令将自己写的镜像保存成tar 给别人导入，而是尽可能的发给别人少量的文件，让别人能够从docker-hub拉取，如这里的python和mysql镜像，这两个容器内部的原始镜像都是从官方拉取的，那么就不需要自己save了！<br><img src="https://img-blog.csdnimg.cn/20210129223443563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210129223500671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>save方法解释一下：就是将自己配好的镜像save成一个tar包，发给别人，别人通过load命令导入到他电脑的docker镜像库中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker save frontier2:vpopo -o xxx.tar</span><br><span class="line">docker load -i xxx.tar</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里再解释一下RUN和CMD命令，对于一个镜像的生成，RUN执行于生成镜像的过程中(比如安装相应的系统环境)，CMD命令执行于启动该镜像后系统初始化要执行的命令(比如某个服务的启动)</p><h1 id="Docker-compose-yaml"><a href="#Docker-compose-yaml" class="headerlink" title="Docker-compose.yaml"></a>Docker-compose.yaml</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'mysql:5.7'</span></span><br><span class="line"><span class="comment">#     network_mode: "host"</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"3306:3306"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PWD/opt/mysql/conf.d:/etc/mysql/conf.d</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PWD/opt/mysql/logs:/logs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PWD/opt/mysql//data:/var/lib/mysql</span></span><br><span class="line">    <span class="comment"># - $PWD/schema.sql:/docker-entrypoint-initdb.d/schema.sql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">$PWD/docker-entrypoint.sh:/docker-entrypoint.sh</span></span><br><span class="line"><span class="comment">#    command: ["mysql","-uroot","-p123456","&lt;","/tmp/schema.sql"]</span></span><br><span class="line">  <span class="attr">es:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'es:vcoustom'</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"9201:9201"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"9301:9301"</span></span><br><span class="line">    <span class="comment">#network_mode: "host"</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">["su","-","es","-c","/usr/app_file/elasticsearch-6.4.2/bin/elasticsearch"]</span></span><br><span class="line">  <span class="attr">python:</span></span><br><span class="line">    <span class="comment"># image: 'python:3.7.4'</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./docker-python</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"8000:8000"</span></span><br><span class="line">    <span class="comment">#network_mode: "host"</span></span><br><span class="line">    <span class="comment"># volumes:</span></span><br><span class="line">    <span class="comment"># - $PWD/word_funtion2:/usr/src/app/word_funtion2</span></span><br><span class="line">    <span class="comment"># working_dir: /usr/src/app/word_funtion2</span></span><br><span class="line">    <span class="comment"># # command: ["chmod","u+x","/usr/local/pystart.sh","&amp;&amp;","/usr/local/pystart.sh"]</span></span><br><span class="line">    <span class="comment"># command: </span></span><br><span class="line">    <span class="comment"># - sh</span></span><br><span class="line">    <span class="comment"># - -c </span></span><br><span class="line">    <span class="comment"># - |</span></span><br><span class="line">    <span class="comment">#     pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line">    <span class="comment">#     python manage.py runserver 0.0.0.0:8000</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">  <span class="attr">frontier_prediction:</span></span><br><span class="line">    <span class="comment">#network_mode: "host"</span></span><br><span class="line">    <span class="comment"># image: 'frontier2:vpopo'</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"mysql"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"es"</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"python"</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'frontier_prediction:vcoustom'</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">"8081:8081"</span></span><br><span class="line">    <span class="comment"># command: ["/usr/local/jdk1.8.0_202/bin/java","-jar","/usr/app_file/agri-1.0-SNAPSHOT.jar"]</span></span><br><span class="line">    <span class="attr">command:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">|</span></span><br><span class="line">        <span class="string">cd</span> <span class="string">/usr/app_file/</span> </span><br><span class="line">        <span class="string">/usr/local/jdk1.8.0_202/bin/java</span> <span class="string">-jar</span> <span class="string">agri-1.0-SNAPSHOT.jar</span></span><br></pre></td></tr></table></figure><h1 id="高频Docker命令"><a href="#高频Docker命令" class="headerlink" title="高频Docker命令"></a>高频Docker命令</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker images #查看本机镜像</span><br><span class="line">docker ps #查看目前启动的容器</span><br><span class="line">docker exec -it cab0db06ada2 /bin/bash #进入到某个容器中</span><br><span class="line">docker stop cab0db06ada2</span><br><span class="line">docker logs -f ea504eaaf08e</span><br></pre></td></tr></table></figure><p>将容器提交为镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -a "popo" -m "popo" b83f55190bf3 frontier2:vpopo</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 解释一下commit，当我们将一个配好的容器提交为一个镜像时，无论你是否开启端口 服务，它保存的是一个静态的系统关机状态，相当于它只保存了这个容器的环境(包括文件改动等)，并不意味着你打开这个镜像，他就已经开好了服务，这里要清晰！这也是之前一直困扰了我的问题，通过实践解决了！<br>这里还有一个高级的奇淫技巧,如果启动容器忘记了挂载，可以中途拷贝容器内的文件出来到本机目录下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  d5200819a46d:/usr/local/bin/docker-entrypoint.sh .</span><br></pre></td></tr></table></figure><h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker-compose up -d frontier_prediction</span><br><span class="line">docker-compose stop frontier_prediction</span><br><span class="line">docker-compose rm frontier_prediction</span><br></pre></td></tr></table></figure><h1 id="多个容器间通信"><a href="#多个容器间通信" class="headerlink" title="多个容器间通信"></a>多个容器间通信</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这里走了很多弯路。其实很简单，如果都是容器与容器通信的话，host直接改为docker-compose.yaml中各个services的名字即可，比如frontier_prediction这个Springboot项目要访问mysql容器的3306端口，只需改项目中的host为：mysql即可，而不是localhost</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202101292257120.png?x-oss-proces</summary>
      
    
    
    
    <category term="技术栈" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="Docker" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/Docker/"/>
    
    
    <category term="Elasticsearch" scheme="https://ericzikun.github.io/tags/Elasticsearch/"/>
    
    <category term="Docker" scheme="https://ericzikun.github.io/tags/Docker/"/>
    
    <category term="java" scheme="https://ericzikun.github.io/tags/java/"/>
    
    <category term="Docker-compose" scheme="https://ericzikun.github.io/tags/Docker-compose/"/>
    
    <category term="Mysql" scheme="https://ericzikun.github.io/tags/Mysql/"/>
    
    <category term="python" scheme="https://ericzikun.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>【Springboot】用户权限框架：Spring security &amp; Shiro</title>
    <link href="https://ericzikun.github.io/2021/01/24/Springboot%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6%EF%BC%9ASpring-security-Shiro/"/>
    <id>https://ericzikun.github.io/2021/01/24/Springboot%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E6%A1%86%E6%9E%B6%EF%BC%9ASpring-security-Shiro/</id>
    <published>2021-01-24T04:18:30.000Z</published>
    <updated>2021-01-29T13:45:39.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、Shiro简介"><a href="#1、Shiro简介" class="headerlink" title="1、Shiro简介"></a>1、Shiro简介</h1><h2 id="1-1、Shiro-是什么？"><a href="#1-1、Shiro-是什么？" class="headerlink" title="1.1、Shiro 是什么？"></a>1.1、Shiro 是什么？</h2><ul><li><p>Apache Shiro 是 Java 的一个安全（权限）框架。</p></li><li><p>Shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。</p></li><li><p>Shiro 可以完成：认证、授权、加密、会话管理、与Web 集成、缓存等。</p></li><li><p>下载地址</p><ul><li>官网：<a href="http://shiro.apache.org/" target="_blank" rel="noopener">http://shiro.apache.org/</a></li><li>github：<a href="https://github.com/apache/shiro" target="_blank" rel="noopener">https://github.com/apache/shiro</a></li></ul></li></ul><h2 id="1-2、有哪些功能？"><a href="#1-2、有哪些功能？" class="headerlink" title="1.2、有哪些功能？"></a>1.2、有哪些功能？</h2><p><img src="https://img-blog.csdnimg.cn/20210129213400955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>Authentication:身份认证/登录，验证用户是不是拥有相应的身份</p></li><li><p>Authorization:授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能进行什么操作，如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限</p></li><li><p>Session Management:会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境，也可以是Web 环境的</p></li><li><p>Cryptography:加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储</p></li><li><p>Web Support:Web 支持，可以非常容易的集成到Web 环境</p></li><li><p>Caching:缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率</p></li><li><p>Concurrency:Shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去</p></li><li><p>Testing:提供测试支持</p></li><li><p>“Run As”:允许一个用户假装为另一个用户（如果他们允许）的身份进行访问</p></li><li><p>Remember Me:记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了</p></li></ul><h2 id="1-3、Shiro架构-外部"><a href="#1-3、Shiro架构-外部" class="headerlink" title="1.3、Shiro架构(外部)"></a>1.3、Shiro架构(外部)</h2><p>从外部来看Shiro，即从应用程序角度的来观察如何使用Shiro完成工作<br><img src="https://img-blog.csdnimg.cn/20210129213425685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><p>Subject：应用代码直接交互的对象是Subject，也就是说Shiro的对外API 核心就是Subject。Subject 代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；与Subject 的所有交互都会委托给SecurityManager；Subject 其实是一个门面，SecurityManager才是实际的执行者</p></li><li><p>SecurityManager：安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且其管理着所有Subject；可以看出它是Shiro的核心，它负责与Shiro的其他组件进行交互，它相当于SpringMVC中DispatcherServlet的角色</p></li><li><p>Realm：Shiro从Realm 获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm 获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm 得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm 看成DataSource</p></li><li><p>1.4、Shiro架构(内部)<br><img src="https://img-blog.csdnimg.cn/20210129213458977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>Subject：任何可以与应用交互的“用户”；</p></li><li><p>SecurityManager：相当于SpringMVC中的DispatcherServlet；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证、授权、会话及缓存的管理。</p></li><li><p>Authenticator：负责Subject 认证，是一个扩展点，可以自定义实现；可以使用认证策略（Authentication Strategy），即什么情况下算用户认证通过了；</p></li><li><p>Authorizer：授权器、即访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能；</p></li><li><p>Realm：可以有1 个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC 实现，也可以是内存实现等等；由用户提供；所以一般在应用中都需要实现自己的Realm；</p></li><li><p>SessionManager：管理Session 生命周期的组件；而Shiro并不仅仅可以用在Web 环境，也可以用在如普通的JavaSE环境<br>CacheManager：缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少改变，放到缓存中后可以提高访问的性能</p></li><li><p>Cryptography：密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密。</p><h1 id="2、SpringBoot集成"><a href="#2、SpringBoot集成" class="headerlink" title="2、SpringBoot集成"></a>2、SpringBoot集成</h1><p>项目结构：<br><img src="https://img-blog.csdnimg.cn/20210129213729703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li></ul><p>编写ShiroConfig配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//shiroFilterFactoryBean  过滤的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">getShiroFilterFactoryBean</span><span class="params">(@Qualifier(<span class="string">"getDefaultWebSecurityManager"</span>)</span> DefaultWebSecurityManager defaultWebSecurityManager) </span>&#123;</span><br><span class="line">        ShiroFilterFactoryBean bean = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">        <span class="comment">// 设置安全管理器</span></span><br><span class="line">        bean.setSecurityManager(defaultWebSecurityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加shiro的内置过滤器</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            anon： 无需认证就可以访问</span></span><br><span class="line"><span class="comment">            authc： 必须认证了才能访问</span></span><br><span class="line"><span class="comment">            user： 必须拥有记住我功能才能用</span></span><br><span class="line"><span class="comment">            perms： 拥有对某个资源的权限才能访问</span></span><br><span class="line"><span class="comment">            role： 拥有某个角色权限</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//拦截</span></span><br><span class="line">        Map&lt;String, String&gt; filterMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//filterMap.put("/user/add","authc");</span></span><br><span class="line">        <span class="comment">//filterMap.put("/user/update","authc");</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//授权，正常情况下，没有授权会跳转到为授权页面</span></span><br><span class="line">        filterMap.put(<span class="string">"/user/add"</span>,<span class="string">"perms[user:add]"</span>);</span><br><span class="line">        filterMap.put(<span class="string">"/user/update"</span>,<span class="string">"perms[user:update]"</span>);</span><br><span class="line"></span><br><span class="line">        filterMap.put(<span class="string">"/user/*"</span>,<span class="string">"authc"</span>);</span><br><span class="line"></span><br><span class="line">        bean.setFilterChainDefinitionMap(filterMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置登录的请求</span></span><br><span class="line">        bean.setLoginUrl(<span class="string">"/toLogin"</span>);  <span class="comment">//设置登录页面 如果没有权限则跳转到此页面</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//为授权页面</span></span><br><span class="line">        bean.setUnauthorizedUrl(<span class="string">"/noauto"</span>); <span class="comment">//如果没有授权则返回此页面</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DefaultWebSecurityManager  安全对象</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">getDefaultWebSecurityManager</span><span class="params">(@Qualifier(<span class="string">"userRealm"</span>)</span> UserRealm userRealm) </span>&#123;</span><br><span class="line">        DefaultWebSecurityManager securityManager = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关联userRealm</span></span><br><span class="line">        securityManager.setRealm(userRealm);</span><br><span class="line">        <span class="keyword">return</span> securityManager;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建realm对象，需要自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"userRealm"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserRealm <span class="title">userRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserRealm();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整合ShiroDialect： 用来整合 Shiro thymeleaf</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShiroDialect <span class="title">getShiroDialect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShiroDialect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义的UserRealm：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的UserRealm</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了=&gt;授权doGetAuthorizationInfo"</span>);</span><br><span class="line"></span><br><span class="line">        SimpleAuthorizationInfo info = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//info.addStringPermission("user:add");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到当前登录的这个对象</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line">        User currentUser = (User)subject.getPrincipal();<span class="comment">//拿到user对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置当前用户的权限</span></span><br><span class="line">        info.addStringPermission(currentUser.getPerms());</span><br><span class="line">        System.out.println(<span class="string">"----用户的权限perms----"</span> + currentUser.getPerms());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行了=&gt;认证doGetAuthorizationInfo"</span>);</span><br><span class="line">        <span class="comment">// 拿到前端传来的userToken，UsernamePasswordToken在MyController中</span></span><br><span class="line">        UsernamePasswordToken userToken = (UsernamePasswordToken) token;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虚拟用户</span></span><br><span class="line">        <span class="comment">//String name = "root";</span></span><br><span class="line">        <span class="comment">//String password = "123456";</span></span><br><span class="line">        <span class="comment">//if (!userToken.getUsername().equals(name)) &#123;</span></span><br><span class="line">        <span class="comment">//    return null;//抛出异常 UnknownAccountException</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真实数据库 用户名、密码， 数据中取</span></span><br><span class="line">        User user = userService.queryUserByName(userToken.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;<span class="comment">//没有这个人</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//首页</span></span><br><span class="line">        <span class="comment">//Subject currentSubject = SecurityUtils.getSubject();</span></span><br><span class="line">        <span class="comment">//Session session = currentSubject.getSession();</span></span><br><span class="line">        <span class="comment">//session.setAttribute("loginUser",user);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以加密：MD5(简单密码可能被破解)，MD5盐值加密(再加上user等信息加密)</span></span><br><span class="line">        <span class="comment">// 密码认证，shiro做，不需要在这里判断密码正确与否，因为密码有可能泄露，根本不让你接触密码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(user,user.getPwd(),<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2021012921415083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、Shiro简介&quot;&gt;&lt;a href=&quot;#1、Shiro简介&quot; class=&quot;headerlink&quot; title=&quot;1、Shiro简介&quot;&gt;&lt;/a&gt;1、Shiro简介&lt;/h1&gt;&lt;h2 id=&quot;1-1、Shiro-是什么？&quot;&gt;&lt;a href=&quot;#1-1、Shiro-是</summary>
      
    
    
    
    <category term="技术栈" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="Springboot" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/Springboot/"/>
    
    
    <category term="Springboot" scheme="https://ericzikun.github.io/tags/Springboot/"/>
    
    <category term="Shiro" scheme="https://ericzikun.github.io/tags/Shiro/"/>
    
    <category term="权限管理" scheme="https://ericzikun.github.io/tags/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【Springboot】Mybatis-plus学习笔记：大大简化Mybatis 无须繁琐CRUD</title>
    <link href="https://ericzikun.github.io/2021/01/22/Mybatis-plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%A7%E5%A4%A7%E7%AE%80%E5%8C%96Mybatis/"/>
    <id>https://ericzikun.github.io/2021/01/22/Mybatis-plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%A4%A7%E5%A4%A7%E7%AE%80%E5%8C%96Mybatis/</id>
    <published>2021-01-22T01:17:31.000Z</published>
    <updated>2021-01-29T13:45:48.752Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MyBatisPlus概述"><a href="#MyBatisPlus概述" class="headerlink" title="MyBatisPlus概述"></a>MyBatisPlus概述</h2><p>需要的基础:把我的MyBatis、Spring、SpringMVC就可以学习这个了! 为什么要学习它呢?MyBatisPlus可以节省我们大量工作时间，所有的CRUD代码它都可以自动化完成! JPA 、 tk-mapper、MyBatisPlus<br>偷懒的!</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>是什么? MyBatis 本来就是简化 JDBC 操作的! 官网:<a href="https://mp.baomidou.com/" target="_blank" rel="noopener">https://mp.baomidou.com/</a> MyBatis Plus，简化 MyBatis !<br><img src="https://img-blog.csdnimg.cn/20210124161928400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-plus --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis-plus 是自己开发，并非官方的! --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mapper继承BaseMapper"><a href="#mapper继承BaseMapper" class="headerlink" title="mapper继承BaseMapper"></a>mapper继承BaseMapper</h3><p>之前的Mybatis，需要写mapper接口，还需要写它的实现类，实现类中药写所有的CRUD方法，以下为Mybatis：<br><img src="https://img-blog.csdnimg.cn/20210124162739567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210124162908818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在的Mybatis-plus，无须繁琐的CRUD方法，继承了BaseMapper，就已经完成了简单增删改查的方法<br><img src="https://img-blog.csdnimg.cn/20210124162356852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面进行CRUD测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatisplus.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.mybatisplus.example.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.mybatisplus.example.pojo.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;User&gt; userList = userMapper.selectList(<span class="keyword">null</span>);</span><br><span class="line">        userList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setBirth(<span class="string">"1997-10-14"</span>);</span><br><span class="line">        user.setGender(<span class="string">"男"</span>);</span><br><span class="line">        user.setName(<span class="string">"小马先生"</span>);</span><br><span class="line">        user.setRole(<span class="string">"admin"</span>);</span><br><span class="line">        user.setSuggestion(<span class="string">"所有的不平凡都来自平凡"</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        <span class="keyword">int</span> insert = userMapper.insert(user);</span><br><span class="line">        System.out.println(insert);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        User user = userMapper.selectById(<span class="number">28</span>);</span><br><span class="line"><span class="comment">//        user.setBirth("1996-10-1");</span></span><br><span class="line">        user.setSuggestion(<span class="string">"所有的不平凡都来自平凡"</span>);</span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 测试乐观锁  成功案例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOptimisticLocker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、查询用户信息</span></span><br><span class="line">        User user = userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2、修改用户信息</span></span><br><span class="line">        user.setName(<span class="string">"刘邦"</span>);</span><br><span class="line">        user.setGender(<span class="string">"女"</span>);</span><br><span class="line">        <span class="comment">//3、执行更新操作</span></span><br><span class="line">        userMapper.updateById(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">// 测试乐观锁  失败案例---多线程下</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOptimisticLocker2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程1</span></span><br><span class="line"></span><br><span class="line">        User user = userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">        user.setName(<span class="string">"刘邦"</span>);</span><br><span class="line">        user.setGender(<span class="string">"女"</span>);</span><br><span class="line">        <span class="comment">//模拟另一个线程执行了插队操作</span></span><br><span class="line">       User user2 = userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">       user2.setName(<span class="string">"刘备"</span>);</span><br><span class="line">       user2.setGender(<span class="string">"男"</span>);</span><br><span class="line">       userMapper.updateById(user2);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//自旋锁来多次尝试提交</span></span><br><span class="line">       userMapper.updateById(user);<span class="comment">// 如果没有乐观锁就会覆盖插队线程的值!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByid</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User user = userMapper.selectById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span>  <span class="comment">//批量查询固定id 集合传入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectBuBatchId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line"><span class="comment">//        System.out.println(users.get(1).getName());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//用map来指定字段查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectBuBatchId2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"name"</span>,<span class="string">"徐淑高"</span>);</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectByMap(map);</span><br><span class="line">        users.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> <span class="comment">//测试分页查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//current当前页 size大小</span></span><br><span class="line">        userMapper.selectPage(page,<span class="keyword">null</span>); <span class="comment">//wrapper是高级查询</span></span><br><span class="line"></span><br><span class="line">        page.getRecords().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteById</span><span class="params">()</span></span>&#123;</span><br><span class="line">        userMapper.deleteById(<span class="number">28</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeleteMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"name"</span>,<span class="string">"小马先生"</span>);</span><br><span class="line">        userMapper.deleteByMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>实体类User中，可以对该实体类进行表名绑定（如果表名和实体类名不一致时）</p></li><li><p>对于类建立的Getter、Setter、有参无参可以通过lombok注解来简化<br><img src="https://img-blog.csdnimg.cn/20210124163325833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2021012416350528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>阿里的数据库构建规范中，需要给每个表至少拥有create_time、update_time字段，这个可以通过写一个MyMetaObjectHandler类来实现官方给的MetaObjectHandler接口，覆盖重写插入时候的填充策略、更新时候的填充策略，记得用@Component丢进spring中，即可保证在插入时候、更新时候，create_time、update_time字段同步更新，无须手动写时间<br><img src="https://img-blog.csdnimg.cn/2021012416372831.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></li><li><p>乐观锁和分页，按照官网进行配置即可，乐观锁需要加一个version字段，在操作数据库时会判断version版本</p></li></ul><p>乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁!如果出现了问题， 再次更新值测试<br>悲观锁:故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁!再去操作!</p><p>我们这里主要讲解 乐观锁机制! 乐观锁实现方式:</p><ol><li>取出记录时，获取当前 version</li><li>更新时，带上这个version</li><li>执行更新时， set version = newVersion where version = oldVersion 如果version不对，就更新失败</li></ol><p>乐观锁和分页插件对应的config：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatisplus.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.mybatisplus.example.mapper"</span>)</span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisPlusConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------注册乐观锁插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OptimisticLockerInterceptor <span class="title">optimisticLockerInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptimisticLockerInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------分页插件</span></span><br><span class="line">    <span class="comment">// 分页插件</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PaginationInterceptor <span class="title">paginationInterceptor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> PaginationInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MyBatisPlus概述&quot;&gt;&lt;a href=&quot;#MyBatisPlus概述&quot; class=&quot;headerlink&quot; title=&quot;MyBatisPlus概述&quot;&gt;&lt;/a&gt;MyBatisPlus概述&lt;/h2&gt;&lt;p&gt;需要的基础:把我的MyBatis、Spring、Sp</summary>
      
    
    
    
    <category term="技术栈" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="Springboot" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/Springboot/"/>
    
    
    <category term="数据库" scheme="https://ericzikun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Springboot" scheme="https://ericzikun.github.io/tags/Springboot/"/>
    
    <category term="Mybatis-plus" scheme="https://ericzikun.github.io/tags/Mybatis-plus/"/>
    
  </entry>
  
  <entry>
    <title>【Springboot】Redis学习笔记</title>
    <link href="https://ericzikun.github.io/2021/01/04/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://ericzikun.github.io/2021/01/04/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-01-04T04:16:51.000Z</published>
    <updated>2021-01-24T08:47:42.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Nosql概述"><a href="#一、Nosql概述" class="headerlink" title="一、Nosql概述"></a>一、Nosql概述</h2><h3 id="为什么使用Nosql"><a href="#为什么使用Nosql" class="headerlink" title="为什么使用Nosql"></a>为什么使用Nosql</h3><p> 1、单机Mysql时代</p><p><img src="https://img-blog.csdnimg.cn/20210124122915940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p><ol><li>数据量增加到一定程度，单机数据库就放不下了</li><li>数据的索引（B+ Tree）,一个机器内存也存放不下</li><li>访问量变大后（读写混合），一台服务器承受不住。</li></ol><p>2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）<br>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！<br><img src="https://img-blog.csdnimg.cn/20210124122903412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>优化过程经历了以下几个过程：</p><ol><li>优化数据库的数据结构和索引(难度大)</li><li>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</li><li>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</li></ol><p>3、分库分表 + 水平拆分 + Mysql集群<br>技术和业务在发展的同时，对人的要求也越来越高!<br>本质:数据库(读，写)<br>早些年MyISAM: 表锁，十分影响效率!高并发下就会出现严重的锁问题 转战Innodb:行锁<br>慢慢的就开始使用分库分表来解决写的压力! MySQL 在哪个年代推出 了表分区!这个并没有多少公司 使用!<br>MySQL 的 集群，很好满足哪个年代的所有需求!<br><img src="https://img-blog.csdnimg.cn/20210124123205551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、如今最近的年代<br>2010–2020 十年之间，世界已经发生了翻天覆地的变化;(定位，也是一种数据，音乐，热榜!) MySQL 等关系型数据库就不够用了!数据量很多，变化很快~!<br>MySQL 有的使用它来存储一些比较大的文件，博客，图片!数据库表很大，效率就低了!如果有一种数 据库来专门处理这种数据,<br>MySQL压力就变得十分小(研究如何处理这些问题!)大数据的IO压力下，表几乎没法更大!</p><p>目前一个基本的互联网项目!<br><img src="https://img-blog.csdnimg.cn/20210124123324246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为什么要用NoSQL!<br>用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！<br>这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p><h3 id="什么是Nosql"><a href="#什么是Nosql" class="headerlink" title="什么是Nosql"></a>什么是Nosql</h3><p><strong>NoSQL = Not Only SQL（不仅仅是SQL）</strong></p><p>Not Only Structured Query Language</p><p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p><p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p><p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p><h3 id="Nosql特点"><a href="#Nosql特点" class="headerlink" title="Nosql特点"></a>Nosql特点</h3><ol><li><p>方便扩展（数据之间没有关系，很好扩展！）</p></li><li><p>大数据量高性能（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</p></li><li><p>数据类型是多样型的！（不需要事先设计数据库，随取随用）</p></li><li><p>传统的 RDBMS 和 NoSQL</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传统的 RDBMS(关系型数据库)</span><br><span class="line">- 结构化组织</span><br><span class="line">- SQL</span><br><span class="line">- 数据和关系都存在单独的表中 row col</span><br><span class="line">- 操作，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础的事务</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Nosql</span><br><span class="line">- 不仅仅是数据</span><br><span class="line">- 没有固定的查询语言</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库（社交关系）</span><br><span class="line">- 最终一致性</span><br><span class="line">- CAP定理和BASE</span><br><span class="line">- 高性能，高可用，高扩展</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><p>了解：3V + 3高<br>大数据时代的3V ：主要是<strong>描述问题</strong>的</p><ol><li>海量Velume</li><li>多样Variety</li><li>实时Velocity</li></ol><p>大数据时代的3高 ： 主要是<strong>对程序的要求</strong></p><ol><li>高并发</li><li>高可扩</li><li>高性能</li></ol><p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的。</p><h3 id="Nosql的四大分类"><a href="#Nosql的四大分类" class="headerlink" title="Nosql的四大分类"></a>Nosql的四大分类</h3><blockquote><p><strong>KV键值对</strong></p></blockquote><ul><li>新浪：<strong>Redis</strong></li><li>美团：Redis + Tair</li><li>阿里、百度：Redis + Memcache</li></ul><blockquote><p><strong>文档型数据库（bson数据格式）：</strong></p></blockquote><ul><li><strong>MongoDB</strong>(掌握)<ul><li>基于分布式文件存储的数据库。C++编写，用于处理大量文档。</li><li>MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。</li></ul></li><li>ConthDB</li></ul><blockquote><p><strong>列存储数据库</strong></p></blockquote><ul><li><strong>HBase</strong>(大数据必学)</li><li>分布式文件系统</li></ul><blockquote><p><strong>图关系数据库</strong></p></blockquote><p>用于广告推荐，社交网络</p><ul><li><strong>Neo4j</strong>、InfoGrid</li></ul><table><thead><tr><th><strong>分类</strong></th><th><strong>Examples举例</strong></th><th><strong>典型应用场景</strong></th><th><strong>数据模型</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>键值对（key-value）</strong></td><td>Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB</td><td>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。</td><td>Key 指向 Value 的键值对，通常用hash table来实现</td><td>查找速度快</td><td>数据无结构化，通常只被当作字符串或者二进制数据</td></tr><tr><td><strong>列存储数据库</strong></td><td>Cassandra, HBase, Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同一列数据存在一起</td><td>查找速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td><strong>文档型数据库</strong></td><td>CouchDB, MongoDb</td><td>Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容）</td><td>Key-Value对应的键值对，Value为结构化数据</td><td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td><td>查询性能不高，而且缺乏统一的查询语法。</td></tr><tr><td><strong>图形(Graph)数据库</strong></td><td>Neo4J, InfoGrid, Infinite Graph</td><td>社交网络，推荐系统等。专注于构建关系图谱</td><td>图结构</td><td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td><td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群</td></tr></tbody></table><h2 id="二、Redis入门"><a href="#二、Redis入门" class="headerlink" title="二、Redis入门"></a>二、Redis入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>Redis是什么？</p></blockquote><p>Redis（Remote Dictionary Server )，即远程字典服务。</p><p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p><p>与memcached一样，为了保证效率，<strong>数据都是缓存在内存中</strong>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><blockquote><p>Redis能该干什么？</p></blockquote><ol><li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li><li>高效率、用于高速缓冲</li><li>发布订阅系统</li><li>地图信息分析</li><li>计时器、计数器(eg：浏览量)</li><li>。。。</li></ol><blockquote><p>特性</p></blockquote><ol><li><p>多样的数据类型</p></li><li><p>持久化</p></li><li><p>集群</p></li><li><p>事务</p><p>…</p><h3 id="安装（略）"><a href="#安装（略）" class="headerlink" title="安装（略）"></a>安装（略）</h3><h3 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h3></li></ol><p><strong>redis-benchmark：</strong> Redis官方提供的性能测试工具，参数选项如下：</p><p><img src="https://img-blog.csdnimg.cn/20210124133354636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>简单测试：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试：100个并发连接 100000请求</span></span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100000</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210124133436761.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><blockquote><p>redis默认有16个数据库<br><img src="https://img-blog.csdnimg.cn/20210124133502896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>默认使用的第0个;</p></blockquote><p>16个数据库为：DB 0~DB 15<br>默认使用DB 0 ，可以使用<code>select n</code>切换到DB n，<code>dbsize</code>可以查看当前数据库的大小，与key数量相关。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get databases <span class="comment"># 命令行查看数据库数量databases</span></span><br><span class="line">1) <span class="string">"databases"</span></span><br><span class="line">2) <span class="string">"16"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; select 8 <span class="comment"># 切换数据库 DB 8</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; dbsize <span class="comment"># 查看数据库大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; SELECT 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; get name <span class="comment"># db8中并不能获取db0中的键值对。</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[8]&gt; DBSIZE</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[8]&gt; SELECT 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"counter:__rand_int__"</span></span><br><span class="line">2) <span class="string">"mylist"</span></span><br><span class="line">3) <span class="string">"name"</span></span><br><span class="line">4) <span class="string">"key:__rand_int__"</span></span><br><span class="line">5) <span class="string">"myset:__rand_int__"</span></span><br><span class="line">127.0.0.1:6379&gt; DBSIZE <span class="comment"># size和key个数相关</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><p><code>keys *</code> ：查看当前数据库中所有的key。</p><p><code>flushdb</code>：清空当前数据库中的键值对。</p><p><code>flushall</code>：清空所有数据库的键值对。</p><blockquote><p><strong>Redis是单线程的，Redis是基于内存操作的。</strong></p></blockquote><p>所以Redis的性能瓶颈不是CPU,而是机器内存和网络带宽。</p><p>那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</p><blockquote><p><strong>Redis为什么单线程还这么快？</strong></p></blockquote><ul><li>误区1：高性能的服务器一定是多线程的？</li><li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li></ul><p>核心：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</p><h2 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h2><p> Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作<strong>数据库</strong>，<strong>高速缓存</strong>和<strong>消息队列代理</strong>。它支持<a href="https://www.redis.net.cn/tutorial/3508.html" target="_blank" rel="noopener">字符串</a>、<a href="https://www.redis.net.cn/tutorial/3509.html" target="_blank" rel="noopener">哈希表</a>、<a href="https://www.redis.net.cn/tutorial/3510.html" target="_blank" rel="noopener">列表</a>、<a href="https://www.redis.net.cn/tutorial/3511.html" target="_blank" rel="noopener">集合</a>、<a href="https://www.redis.net.cn/tutorial/3512.html" target="_blank" rel="noopener">有序集合</a>，<a href="https://www.redis.net.cn/tutorial/3508.html" target="_blank" rel="noopener">位图</a>，<a href="https://www.redis.net.cn/tutorial/3513.html" target="_blank" rel="noopener">hyperloglogs</a>等数据类型。内置复制、<a href="https://www.redis.net.cn/tutorial/3516.html" target="_blank" rel="noopener">Lua脚本</a>、LRU收回、<a href="https://www.redis.net.cn/tutorial/3515.html" target="_blank" rel="noopener">事务</a>以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动<a href="https://www.redis.net.cn/tutorial/3524.html" target="_blank" rel="noopener">分区</a>。</p><h3 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h3><blockquote><p>在redis中无论什么数据类型，在数据库中都是以key-value形式保存，通过进行对Redis-key的操作，来完成对数据库中数据的操作。</p></blockquote><p>下面学习的命令：</p><ul><li><code>exists key</code>：判断键是否存在</li><li><code>del key</code>：删除键值对</li><li><code>move key db</code>：将键值对移动到指定数据库</li><li><code>expire key second</code>：设置键值对的过期时间</li><li><code>type key</code>：查看value的数据类型</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看当前数据库所有key</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name qinjiang <span class="comment"># set key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"age"</span></span><br><span class="line">2) <span class="string">"name"</span></span><br><span class="line">127.0.0.1:6379&gt; move age 1 <span class="comment"># 将键值对移动到指定数据库</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; EXISTS age <span class="comment"># 判断键是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line">127.0.0.1:6379&gt; EXISTS name</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; SELECT 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) <span class="string">"age"</span></span><br><span class="line">127.0.0.1:6379[1]&gt; del age <span class="comment"># 删除键值对</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 删除个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> age 20</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXPIRE age 15 <span class="comment"># 设置键值对的过期时间</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 设置成功 开始计数</span></span><br><span class="line">127.0.0.1:6379&gt; ttl age <span class="comment"># 查看key的过期剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 13</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -2 <span class="comment"># -2 表示key过期，-1表示key未设置过期时间</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get age <span class="comment"># 过期的key 会被自动delete</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> name <span class="comment"># 查看value的数据类型</span></span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>关于<code>TTL</code>命令</p><p>Redis的key，通过TTL命令返回key的==过期时间==，一般来说有3种：</p><ol><li>当前key没有设置过期时间，所以会返回-1.</li><li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li><li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li></ol><p>关于重命名<code>RENAME</code>和<code>RENAMENX</code></p><ul><li><code>RENAME key newkey</code>修改 key 的名称</li><li><code>RENAMENX key newkey</code>仅当 newkey 不存在时，将 key 改名为 newkey 。</li></ul><p>更多命令学习：<a href="https://www.redis.net.cn/order/" target="_blank" rel="noopener">https://www.redis.net.cn/order/</a></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-wBVZtGVm-1597890996517)(狂神说 Redis.assets/image-20200813114228439.png)]</p><h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><p>普通的set、get直接略过。</p><table><thead><tr><th>命令</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><code>APPEND key value</code></td><td>向指定的key的value后追加字符串</td><td>127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg “ world” (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</td></tr><tr><td><code>DECR/INCR key</code></td><td>将指定key的value数值进行+1/-1(仅对于数字)</td><td>127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</td></tr><tr><td><code>INCRBY/DECRBY key n</code></td><td>按指定的步长对数值进行加减</td><td>127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</td></tr><tr><td><code>INCRBYFLOAT key n</code></td><td>为数值加上浮点型数值</td><td>127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td></tr><tr><td><code>STRLEN key</code></td><td>获取key保存值的字符串长度</td><td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</td></tr><tr><td><code>GETRANGE key start end</code></td><td>按起止位置获取字符串（闭区间，起止位置都取）</td><td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</td></tr><tr><td><code>SETRANGE key offset value</code></td><td>用指定的value 替换key中 offset开始的值</td><td>127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”</td></tr><tr><td><code>GETSET key value</code></td><td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td><td>127.0.0.1:6379&gt; GETSET msg test “hello world”</td></tr><tr><td><code>SETNX key value</code></td><td>仅当key不存在时进行set</td><td>127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</td></tr><tr><td><code>SETEX key seconds value</code></td><td>set 键值对并设置过期时间</td><td>127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</td></tr><tr><td><code>MSET key1 value1 [key2 value2..]</code></td><td>批量set键值对</td><td>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</td></tr><tr><td><code>MSETNX key1 value1 [key2 value2..]</code></td><td>批量设置键值对，仅当参数中所有的key都不存在时执行</td><td>127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</td></tr><tr><td><code>MGET key1 [key2..]</code></td><td>批量获取多个key保存的值</td><td>127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td></tr><tr><td><code>PSETEX key milliseconds value</code></td><td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td><td></td></tr><tr><td><code>getset key value</code></td><td>如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值</td><td></td></tr></tbody></table><p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p><ul><li>计数器</li><li>统计多单位的数量：uid:123666：follow 0</li><li>粉丝数</li><li>对象存储缓存</li></ul><h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h3><blockquote><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p></blockquote><p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等<br><img src="https://img-blog.csdnimg.cn/20210124133604137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>LPUSH/RPUSH key value1[value2..]</code></td><td>从左边/右边向列表中PUSH值(一个或者多个)。</td></tr><tr><td><code>LRANGE key start end</code></td><td>获取list 起止元素==（索引从左往右 递增）==</td></tr><tr><td><code>LPUSHX/RPUSHX key value</code></td><td>向已存在的列名中push值（一个或者多个）</td></tr><tr><td>`LINSERT key BEFORE</td><td>AFTER pivot value`</td></tr><tr><td><code>LLEN key</code></td><td>查看列表长度</td></tr><tr><td><code>LINDEX key index</code></td><td>通过索引获取列表元素</td></tr><tr><td><code>LSET key index value</code></td><td>通过索引为元素设值</td></tr><tr><td><code>LPOP/RPOP key</code></td><td>从最左边/最右边移除值 并返回</td></tr><tr><td><code>RPOPLPUSH source destination</code></td><td>将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</td></tr><tr><td><code>LTRIM key start end</code></td><td>通过下标截取指定范围内的列表</td></tr><tr><td><code>LREM key count value</code></td><td>List中是允许value重复的 <code>count &gt; 0</code>：从头部开始搜索 然后删除指定的value 至多删除count个 <code>count &lt; 0</code>：从尾部开始搜索… <code>count = 0</code>：删除列表中所有的指定value。</td></tr><tr><td><code>BLPOP/BRPOP key1[key2] timout</code></td><td>移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td><code>BRPOPLPUSH source destination timeout</code></td><td>和<code>RPOPLPUSH</code>功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">---------------------------LPUSH---RPUSH---LRANGE--------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k1 <span class="comment"># LPUSH mylist=&gt;&#123;1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; LPUSH mylist k2 <span class="comment"># LPUSH mylist=&gt;&#123;2,1&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; RPUSH mylist k3 <span class="comment"># RPUSH mylist=&gt;&#123;2,1,3&#125;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get mylist <span class="comment"># 普通的get是无法获取list值的</span></span><br><span class="line">(error) WRONGTYPE Operation against a key holding the wrong kind of value</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 4 <span class="comment"># LRANGE 获取起止位置范围内的元素</span></span><br><span class="line">1) <span class="string">"k2"</span></span><br><span class="line">2) <span class="string">"k1"</span></span><br><span class="line">3) <span class="string">"k3"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 2</span><br><span class="line">1) <span class="string">"k2"</span></span><br><span class="line">2) <span class="string">"k1"</span></span><br><span class="line">3) <span class="string">"k3"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 1</span><br><span class="line">1) <span class="string">"k2"</span></span><br><span class="line">2) <span class="string">"k1"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1 <span class="comment"># 获取全部元素</span></span><br><span class="line">1) <span class="string">"k2"</span></span><br><span class="line">2) <span class="string">"k1"</span></span><br><span class="line">3) <span class="string">"k3"</span></span><br><span class="line"></span><br><span class="line">---------------------------LPUSHX---RPUSHX-----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 <span class="comment"># list不存在 LPUSHX失败</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX list v1 v2  </span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; LPUSHX mylist k4 k5 <span class="comment"># 向mylist中 左边 PUSH k4 k5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"k5"</span></span><br><span class="line">2) <span class="string">"k4"</span></span><br><span class="line">3) <span class="string">"k2"</span></span><br><span class="line">4) <span class="string">"k1"</span></span><br><span class="line">5) <span class="string">"k3"</span></span><br><span class="line"></span><br><span class="line">---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LINSERT mylist after k2 ins_key1 <span class="comment"># 在k2元素后 插入ins_key1</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"k5"</span></span><br><span class="line">2) <span class="string">"k4"</span></span><br><span class="line">3) <span class="string">"k2"</span></span><br><span class="line">4) <span class="string">"ins_key1"</span></span><br><span class="line">5) <span class="string">"k1"</span></span><br><span class="line">6) <span class="string">"k3"</span></span><br><span class="line">127.0.0.1:6379&gt; LLEN mylist <span class="comment"># 查看mylist的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 3 <span class="comment"># 获取下标为3的元素</span></span><br><span class="line"><span class="string">"ins_key1"</span></span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist 0</span><br><span class="line"><span class="string">"k5"</span></span><br><span class="line">127.0.0.1:6379&gt; LSET mylist 3 k6 <span class="comment"># 将下标3的元素 set值为k6</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"k5"</span></span><br><span class="line">2) <span class="string">"k4"</span></span><br><span class="line">3) <span class="string">"k2"</span></span><br><span class="line">4) <span class="string">"k6"</span></span><br><span class="line">5) <span class="string">"k1"</span></span><br><span class="line">6) <span class="string">"k3"</span></span><br><span class="line"></span><br><span class="line">---------------------------LPOP--RPOP--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LPOP mylist <span class="comment"># 左侧(头部)弹出</span></span><br><span class="line"><span class="string">"k5"</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP mylist <span class="comment"># 右侧(尾部)弹出</span></span><br><span class="line"><span class="string">"k3"</span></span><br><span class="line"></span><br><span class="line">---------------------------RPOPLPUSH--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"k4"</span></span><br><span class="line">2) <span class="string">"k2"</span></span><br><span class="line">3) <span class="string">"k6"</span></span><br><span class="line">4) <span class="string">"k1"</span></span><br><span class="line">127.0.0.1:6379&gt; RPOPLPUSH mylist newlist <span class="comment"># 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span></span><br><span class="line"><span class="string">"k1"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE newlist 0 -1</span><br><span class="line">1) <span class="string">"k1"</span></span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"k4"</span></span><br><span class="line">2) <span class="string">"k2"</span></span><br><span class="line">3) <span class="string">"k6"</span></span><br><span class="line"></span><br><span class="line">---------------------------LTRIM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LTRIM mylist 0 1 <span class="comment"># 截取mylist中的 0~1部分</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"k4"</span></span><br><span class="line">2) <span class="string">"k2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line">---------------------------LREM--------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist 3 k2 <span class="comment"># 从头部开始搜索 至多删除3个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; LREM mylist -2 k2 <span class="comment">#从尾部开始搜索 至多删除2个 k2</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"><span class="comment"># 删除后：mylist: k2,k2,k2,k4,k2,k2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---------------------------BLPOP--BRPOP--------------------------</span><br><span class="line"></span><br><span class="line">mylist: k2,k2,k2,k4,k2,k2</span><br><span class="line">newlist: k1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30 <span class="comment"># 从newlist中弹出第一个值，mylist作为候选</span></span><br><span class="line">1) <span class="string">"newlist"</span> <span class="comment"># 弹出</span></span><br><span class="line">2) <span class="string">"k1"</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist mylist 30</span><br><span class="line">1) <span class="string">"mylist"</span> <span class="comment"># 由于newlist空了 从mylist中弹出</span></span><br><span class="line">2) <span class="string">"k2"</span></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30</span><br><span class="line">(30.10s) <span class="comment"># 超时了</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; BLPOP newlist 30 <span class="comment"># 我们连接另一个客户端向newlist中push了test, 阻塞被解决。</span></span><br><span class="line">1) <span class="string">"newlist"</span></span><br><span class="line">2) <span class="string">"test"</span></span><br><span class="line">(12.54s)</span><br></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><ul><li>list实际上是一个链表，before Node after , left, right 都可以插入值</li><li><strong>如果key不存在，则创建新的链表</strong></li><li>如果key存在，新增内容</li><li>如果移除了所有值，空链表，也代表不存在</li><li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li></ul><p><strong>应用：</strong></p><p><strong>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</strong></p><h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h3><blockquote><p>Redis的Set是<strong>string类型</strong>的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>SADD key member1[member2..]</code></td><td>向集合中无序增加一个/多个成员</td></tr><tr><td><code>SCARD key</code></td><td>获取集合的成员数</td></tr><tr><td><code>SMEMBERS key</code></td><td>返回集合中所有的成员</td></tr><tr><td><code>SISMEMBER key member</code></td><td>查询member元素是否是集合的成员,结果是无序的</td></tr><tr><td><code>SRANDMEMBER key [count]</code></td><td>随机返回集合中count个成员，count缺省值为1</td></tr><tr><td><code>SPOP key [count]</code></td><td>随机移除并返回集合中count个成员，count缺省值为1</td></tr><tr><td><code>SMOVE source destination member</code></td><td>将source集合的成员member移动到destination集合</td></tr><tr><td><code>SREM key member1[member2..]</code></td><td>移除集合中一个/多个成员</td></tr><tr><td><code>SDIFF key1[key2..]</code></td><td>返回所有集合的差集 key1- key2 - …</td></tr><tr><td><code>SDIFFSTORE destination key1[key2..]</code></td><td>在SDIFF的基础上，将结果保存到集合中==(覆盖)==。不能保存到其他类型key噢！</td></tr><tr><td><code>SINTER key1 [key2..]</code></td><td>返回所有集合的交集</td></tr><tr><td><code>SINTERSTORE destination key1[key2..]</code></td><td>在SINTER的基础上，存储结果到集合中。覆盖</td></tr><tr><td><code>SUNION key1 [key2..]</code></td><td>返回所有集合的并集</td></tr><tr><td><code>SUNIONSTORE destination key1 [key2..]</code></td><td>在SUNION的基础上，存储结果到及和张。覆盖</td></tr><tr><td><code>SSCAN KEY [MATCH pattern] [COUNT count]</code></td><td>在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SADD myset m1 m2 m3 m4 <span class="comment"># 向myset中增加成员 m1~m4</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; SCARD myset <span class="comment"># 获取集合的成员数目</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers myset <span class="comment"># 获取集合中所有成员</span></span><br><span class="line">1) <span class="string">"m4"</span></span><br><span class="line">2) <span class="string">"m3"</span></span><br><span class="line">3) <span class="string">"m2"</span></span><br><span class="line">4) <span class="string">"m1"</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m5 <span class="comment"># 查询m5是否是myset的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不是，返回0</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m2</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 是，返回1</span></span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset m3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">---------------------SRANDMEMBER--SPOP----------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset 3 <span class="comment"># 随机返回3个成员</span></span><br><span class="line">1) <span class="string">"m2"</span></span><br><span class="line">2) <span class="string">"m3"</span></span><br><span class="line">3) <span class="string">"m4"</span></span><br><span class="line">127.0.0.1:6379&gt; SRANDMEMBER myset <span class="comment"># 随机返回1个成员</span></span><br><span class="line"><span class="string">"m3"</span></span><br><span class="line">127.0.0.1:6379&gt; SPOP myset 2 <span class="comment"># 随机移除并返回2个成员</span></span><br><span class="line">1) <span class="string">"m1"</span></span><br><span class="line">2) <span class="string">"m4"</span></span><br><span class="line"><span class="comment"># 将set还原到&#123;m1,m2,m3,m4&#125;</span></span><br><span class="line"></span><br><span class="line">---------------------SMOVE--SREM----------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SMOVE myset newset m3 <span class="comment"># 将myset中m3成员移动到newset集合</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">"m4"</span></span><br><span class="line">2) <span class="string">"m2"</span></span><br><span class="line">3) <span class="string">"m1"</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">1) <span class="string">"m3"</span></span><br><span class="line">127.0.0.1:6379&gt; SREM newset m3 <span class="comment"># 从newset中移除m3元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS newset</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算</span></span><br><span class="line"><span class="comment"># setx=&gt;&#123;m1,m2,m4,m6&#125;, sety=&gt;&#123;m2,m5,m6&#125;, setz=&gt;&#123;m1,m3,m6&#125;</span></span><br><span class="line"></span><br><span class="line">-----------------------------SDIFF------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety setz <span class="comment"># 等价于setx-sety-setz</span></span><br><span class="line">1) <span class="string">"m4"</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF setx sety <span class="comment"># setx - sety</span></span><br><span class="line">1) <span class="string">"m4"</span></span><br><span class="line">2) <span class="string">"m1"</span></span><br><span class="line">127.0.0.1:6379&gt; SDIFF sety setx <span class="comment"># sety - setx</span></span><br><span class="line">1) <span class="string">"m5"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------------SINTER---------------------------------------</span><br><span class="line"><span class="comment"># 共同关注（交集）</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety setz <span class="comment"># 求 setx、sety、setx的交集</span></span><br><span class="line">1) <span class="string">"m6"</span></span><br><span class="line">127.0.0.1:6379&gt; SINTER setx sety <span class="comment"># 求setx sety的交集</span></span><br><span class="line">1) <span class="string">"m2"</span></span><br><span class="line">2) <span class="string">"m6"</span></span><br><span class="line"></span><br><span class="line">-------------------------SUNION---------------------------------------</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety setz <span class="comment"># setx sety setz的并集</span></span><br><span class="line">1) <span class="string">"m4"</span></span><br><span class="line">2) <span class="string">"m6"</span></span><br><span class="line">3) <span class="string">"m3"</span></span><br><span class="line">4) <span class="string">"m2"</span></span><br><span class="line">5) <span class="string">"m1"</span></span><br><span class="line">6) <span class="string">"m5"</span></span><br><span class="line">127.0.0.1:6379&gt; SUNION setx sety <span class="comment"># setx sety 并集</span></span><br><span class="line">1) <span class="string">"m4"</span></span><br><span class="line">2) <span class="string">"m6"</span></span><br><span class="line">3) <span class="string">"m2"</span></span><br><span class="line">4) <span class="string">"m1"</span></span><br><span class="line">5) <span class="string">"m5"</span></span><br></pre></td></tr></table></figure><h3 id="Hash（哈希）"><a href="#Hash（哈希）" class="headerlink" title="Hash（哈希）"></a>Hash（哈希）</h3><blockquote><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>Set就是一种简化的Hash,只变动key,而value使用默认值填充。可以将一个Hash表作为一个对象进行存储，表中存放对象的信息。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>HSET key field value</code></td><td>将哈希表 key 中的字段 field 的值设为 value 。重复设置同一个field会覆盖,返回0</td></tr><tr><td><code>HMSET key field1 value1 [field2 value2..]</code></td><td>同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td><code>HSETNX key field value</code></td><td>只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td><code>HEXISTS key field</code></td><td>查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td><code>HGET key field value</code></td><td>获取存储在哈希表中指定字段的值</td></tr><tr><td><code>HMGET key field1 [field2..]</code></td><td>获取所有给定字段的值</td></tr><tr><td><code>HGETALL key</code></td><td>获取在哈希表key 的所有字段和值</td></tr><tr><td><code>HKEYS key</code></td><td>获取哈希表key中所有的字段</td></tr><tr><td><code>HLEN key</code></td><td>获取哈希表中字段的数量</td></tr><tr><td><code>HVALS key</code></td><td>获取哈希表中所有值</td></tr><tr><td><code>HDEL key field1 [field2..]</code></td><td>删除哈希表key中一个/多个field字段</td></tr><tr><td><code>HINCRBY key field n</code></td><td>为哈希表 key 中的指定字段的整数值加上增量n，并返回增量后结果 一样只适用于整数型字段</td></tr><tr><td><code>HINCRBYFLOAT key field n</code></td><td>为哈希表 key 中的指定字段的浮点数值加上增量 n。</td></tr><tr><td><code>HSCAN key cursor [MATCH pattern] [COUNT count]</code></td><td>迭代哈希表中的键值对。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">------------------------HSET--HMSET--HSETNX----------------</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name sakura <span class="comment"># 将studentx哈希表作为一个对象，设置name为sakura</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx name gyc <span class="comment"># 重复设置field进行覆盖，并返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; HSET studentx age 20 <span class="comment"># 设置studentx的age为20</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HMSET studentx sex 1 tel 15623667886 <span class="comment"># 设置sex为1，tel为15623667886</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx name gyc <span class="comment"># HSETNX 设置已存在的field</span></span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 失败</span></span><br><span class="line">127.0.0.1:6379&gt; HSETNX studentx email 12345@qq.com</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 成功</span></span><br><span class="line"></span><br><span class="line">----------------------HEXISTS--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx name <span class="comment"># name字段在studentx中是否存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment"># 存在</span></span><br><span class="line">127.0.0.1:6379&gt; HEXISTS studentx addr</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment"># 不存在</span></span><br><span class="line"></span><br><span class="line">-------------------HGET--HMGET--HGETALL-----------</span><br><span class="line">127.0.0.1:6379&gt; HGET studentx name <span class="comment"># 获取studentx中name字段的value</span></span><br><span class="line"><span class="string">"gyc"</span></span><br><span class="line">127.0.0.1:6379&gt; HMGET studentx name age tel <span class="comment"># 获取studentx中name、age、tel字段的value</span></span><br><span class="line">1) <span class="string">"gyc"</span></span><br><span class="line">2) <span class="string">"20"</span></span><br><span class="line">3) <span class="string">"15623667886"</span></span><br><span class="line">127.0.0.1:6379&gt; HGETALL studentx <span class="comment"># 获取studentx中所有的field及其value</span></span><br><span class="line"> 1) <span class="string">"name"</span></span><br><span class="line"> 2) <span class="string">"gyc"</span></span><br><span class="line"> 3) <span class="string">"age"</span></span><br><span class="line"> 4) <span class="string">"20"</span></span><br><span class="line"> 5) <span class="string">"sex"</span></span><br><span class="line"> 6) <span class="string">"1"</span></span><br><span class="line"> 7) <span class="string">"tel"</span></span><br><span class="line"> 8) <span class="string">"15623667886"</span></span><br><span class="line"> 9) <span class="string">"email"</span></span><br><span class="line">10) <span class="string">"12345@qq.com"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------HKEYS--HLEN--HVALS--------------</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx <span class="comment"># 查看studentx中所有的field</span></span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"age"</span></span><br><span class="line">3) <span class="string">"sex"</span></span><br><span class="line">4) <span class="string">"tel"</span></span><br><span class="line">5) <span class="string">"email"</span></span><br><span class="line">127.0.0.1:6379&gt; HLEN studentx <span class="comment"># 查看studentx中的字段数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; HVALS studentx <span class="comment"># 查看studentx中所有的value</span></span><br><span class="line">1) <span class="string">"gyc"</span></span><br><span class="line">2) <span class="string">"20"</span></span><br><span class="line">3) <span class="string">"1"</span></span><br><span class="line">4) <span class="string">"15623667886"</span></span><br><span class="line">5) <span class="string">"12345@qq.com"</span></span><br><span class="line"></span><br><span class="line">-------------------------HDEL--------------------------</span><br><span class="line">127.0.0.1:6379&gt; HDEL studentx sex tel <span class="comment"># 删除studentx 中的sex、tel字段</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; HKEYS studentx</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"age"</span></span><br><span class="line">3) <span class="string">"email"</span></span><br><span class="line"></span><br><span class="line">-------------HINCRBY--HINCRBYFLOAT------------------------</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx age 1 <span class="comment"># studentx的age字段数值+1</span></span><br><span class="line">(<span class="built_in">integer</span>) 21</span><br><span class="line">127.0.0.1:6379&gt; HINCRBY studentx name 1 <span class="comment"># 非整数字型字段不可用</span></span><br><span class="line">(error) ERR <span class="built_in">hash</span> value is not an <span class="built_in">integer</span></span><br><span class="line">127.0.0.1:6379&gt; HINCRBYFLOAT studentx weight 0.6 <span class="comment"># weight字段增加0.6</span></span><br><span class="line"><span class="string">"90.8"</span></span><br></pre></td></tr></table></figure><p> Hash变更的数据user name age，尤其是用户信息之类的，经常变动的信息！<strong>Hash更适合于对象的存储，Sring更加适合字符串存储！</strong></p><h3 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h3><blockquote><p>不同的是每个元素都会关联一个double类型的分数（score）。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>score相同：按字典顺序排序</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>ZADD key score member1 [score2 member2]</code></td><td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td><code>ZCARD key</code></td><td>获取有序集合的成员数</td></tr><tr><td><code>ZCOUNT key min max</code></td><td>计算在有序集合中指定区间score的成员数</td></tr><tr><td><code>ZINCRBY key n member</code></td><td>有序集合中对指定成员的分数加上增量 n</td></tr><tr><td><code>ZSCORE key member</code></td><td>返回有序集中，成员的分数值</td></tr><tr><td><code>ZRANK key member</code></td><td>返回有序集合中指定成员的索引</td></tr><tr><td><code>ZRANGE key start end</code></td><td>通过索引区间返回有序集合成指定区间内的成员</td></tr><tr><td><code>ZRANGEBYLEX key min max</code></td><td>通过字典区间返回有序集合的成员</td></tr><tr><td><code>ZRANGEBYSCORE key min max</code></td><td>通过分数返回有序集合指定区间内的成员==-inf 和 +inf分别表示最小最大值，只支持开区间()==</td></tr><tr><td><code>ZLEXCOUNT key min max</code></td><td>在有序集合中计算指定字典区间内成员数量</td></tr><tr><td><code>ZREM key member1 [member2..]</code></td><td>移除有序集合中一个/多个成员</td></tr><tr><td><code>ZREMRANGEBYLEX key min max</code></td><td>移除有序集合中给定的字典区间的所有成员</td></tr><tr><td><code>ZREMRANGEBYRANK key start stop</code></td><td>移除有序集合中给定的排名区间的所有成员</td></tr><tr><td><code>ZREMRANGEBYSCORE key min max</code></td><td>移除有序集合中给定的分数区间的所有成员</td></tr><tr><td><code>ZREVRANGE key start end</code></td><td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td><code>ZREVRANGEBYSCORRE key max min</code></td><td>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td><code>ZREVRANGEBYLEX key max min</code></td><td>返回有序集中指定字典区间内的成员，按字典顺序倒序</td></tr><tr><td><code>ZREVRANK key member</code></td><td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td><code>ZINTERSTORE destination numkeys key1 [key2 ..]</code></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中，numkeys：表示参与运算的集合数，将score相加作为结果的score</td></tr><tr><td><code>ZUNIONSTORE destination numkeys key1 [key2..]</code></td><td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td><code>ZSCAN key cursor [MATCH pattern\] [COUNT count]</code></td><td>迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">-------------------ZADD--ZCARD--ZCOUNT--------------</span><br><span class="line">127.0.0.1:6379&gt; ZADD myzset 1 m1 2 m2 3 m3 <span class="comment"># 向有序集合myzset中添加成员m1 score=1 以及成员m2 score=2..</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCARD myzset <span class="comment"># 获取有序集合的成员数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 1 <span class="comment"># 获取score在 [0,1]区间的成员数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZCOUNT myzset 0 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line">----------------ZINCRBY--ZSCORE--------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINCRBY myzset 5 m2 <span class="comment"># 将成员m2的score +5</span></span><br><span class="line"><span class="string">"7"</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m1 <span class="comment"># 获取成员m1的score</span></span><br><span class="line"><span class="string">"1"</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myzset m2</span><br><span class="line"><span class="string">"7"</span></span><br><span class="line"></span><br><span class="line">--------------ZRANK--ZRANGE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m1 <span class="comment"># 获取成员m1的索引，索引按照score排序，score相同索引值按字典顺序顺序增加</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; ZRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 1 <span class="comment"># 获取索引在 0~1的成员</span></span><br><span class="line">1) <span class="string">"m1"</span></span><br><span class="line">2) <span class="string">"m3"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myzset 0 -1 <span class="comment"># 获取全部成员</span></span><br><span class="line">1) <span class="string">"m1"</span></span><br><span class="line">2) <span class="string">"m3"</span></span><br><span class="line">3) <span class="string">"m2"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#testset=&gt;&#123;abc,add,amaze,apple,back,java,redis&#125; score均为0</span></span><br><span class="line">------------------ZRANGEBYLEX---------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + <span class="comment"># 返回所有成员</span></span><br><span class="line">1) <span class="string">"abc"</span></span><br><span class="line">2) <span class="string">"add"</span></span><br><span class="line">3) <span class="string">"amaze"</span></span><br><span class="line">4) <span class="string">"apple"</span></span><br><span class="line">5) <span class="string">"back"</span></span><br><span class="line">6) <span class="string">"java"</span></span><br><span class="line">7) <span class="string">"redis"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 0 3 <span class="comment"># 分页 按索引显示查询结果的 0,1,2条记录</span></span><br><span class="line">1) <span class="string">"abc"</span></span><br><span class="line">2) <span class="string">"add"</span></span><br><span class="line">3) <span class="string">"amaze"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset - + LIMIT 3 3 <span class="comment"># 显示 3,4,5条记录</span></span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"back"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset (- [apple <span class="comment"># 显示 (-,apple] 区间内的成员</span></span><br><span class="line">1) <span class="string">"abc"</span></span><br><span class="line">2) <span class="string">"add"</span></span><br><span class="line">3) <span class="string">"amaze"</span></span><br><span class="line">4) <span class="string">"apple"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYLEX testset [apple [java <span class="comment"># 显示 [apple,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">"apple"</span></span><br><span class="line">2) <span class="string">"back"</span></span><br><span class="line">3) <span class="string">"java"</span></span><br><span class="line"></span><br><span class="line">-----------------------ZRANGEBYSCORE---------------------</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 10 <span class="comment"># 返回score在 [1,10]之间的的成员</span></span><br><span class="line">1) <span class="string">"m1"</span></span><br><span class="line">2) <span class="string">"m3"</span></span><br><span class="line">3) <span class="string">"m2"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE myzset 1 5</span><br><span class="line">1) <span class="string">"m1"</span></span><br><span class="line">2) <span class="string">"m3"</span></span><br><span class="line"></span><br><span class="line">--------------------ZLEXCOUNT-----------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset - +</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; ZLEXCOUNT testset [apple [java</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"></span><br><span class="line">------------------ZREM--ZREMRANGEBYLEX--ZREMRANGBYRANK--ZREMRANGEBYSCORE--------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREM testset abc <span class="comment"># 移除成员abc</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYLEX testset [apple [java <span class="comment"># 移除字典区间[apple,java]中的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK testset 0 1 <span class="comment"># 移除排名0~1的所有成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE myzset 0 3 <span class="comment"># 移除score在 [0,3]的成员</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># testset=&gt; &#123;abc,add,apple,amaze,back,java,redis&#125; score均为0</span></span><br><span class="line"><span class="comment"># myzset=&gt; &#123;(m1,1),(m2,2),(m3,3),(m4,4),(m7,7),(m9,9)&#125;</span></span><br><span class="line">----------------ZREVRANGE--ZREVRANGEBYSCORE--ZREVRANGEBYLEX-----------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 0 3 <span class="comment"># 按score递减排序，然后按索引，返回结果的 0~3</span></span><br><span class="line">1) <span class="string">"m9"</span></span><br><span class="line">2) <span class="string">"m7"</span></span><br><span class="line">3) <span class="string">"m4"</span></span><br><span class="line">4) <span class="string">"m3"</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE myzset 2 4 <span class="comment"># 返回排序结果的 索引的2~4</span></span><br><span class="line">1) <span class="string">"m4"</span></span><br><span class="line">2) <span class="string">"m3"</span></span><br><span class="line">3) <span class="string">"m2"</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYSCORE myzset 6 2 <span class="comment"># 按score递减顺序 返回集合中分数在[2,6]之间的成员</span></span><br><span class="line">1) <span class="string">"m4"</span></span><br><span class="line">2) <span class="string">"m3"</span></span><br><span class="line">3) <span class="string">"m2"</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGEBYLEX testset [java (add <span class="comment"># 按字典倒序 返回集合中(add,java]字典区间的成员</span></span><br><span class="line">1) <span class="string">"java"</span></span><br><span class="line">2) <span class="string">"back"</span></span><br><span class="line">3) <span class="string">"apple"</span></span><br><span class="line">4) <span class="string">"amaze"</span></span><br><span class="line"></span><br><span class="line">-------------------------ZREVRANK------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m7 <span class="comment"># 按score递减顺序，返回成员m7索引</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ZREVRANK myzset m2</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mathscore=&gt;&#123;(xm,90),(xh,95),(xg,87)&#125; 小明、小红、小刚的数学成绩</span></span><br><span class="line"><span class="comment"># enscore=&gt;&#123;(xm,70),(xh,93),(xg,90)&#125; 小明、小红、小刚的英语成绩</span></span><br><span class="line">-------------------ZINTERSTORE--ZUNIONSTORE-----------------------------------</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE sumscore 2 mathscore enscore <span class="comment"># 将mathscore enscore进行合并 结果存放到sumscore</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE sumscore 0 -1 withscores <span class="comment"># 合并后的score是之前集合中所有score的和</span></span><br><span class="line">1) <span class="string">"xm"</span></span><br><span class="line">2) <span class="string">"160"</span></span><br><span class="line">3) <span class="string">"xg"</span></span><br><span class="line">4) <span class="string">"177"</span></span><br><span class="line">5) <span class="string">"xh"</span></span><br><span class="line">6) <span class="string">"188"</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZUNIONSTORE lowestscore 2 mathscore enscore AGGREGATE MIN <span class="comment"># 取两个集合的成员score最小值作为结果的</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE lowestscore 0 -1 withscores</span><br><span class="line">1) <span class="string">"xm"</span></span><br><span class="line">2) <span class="string">"70"</span></span><br><span class="line">3) <span class="string">"xg"</span></span><br><span class="line">4) <span class="string">"87"</span></span><br><span class="line">5) <span class="string">"xh"</span></span><br><span class="line">6) <span class="string">"93"</span></span><br></pre></td></tr></table></figure><p>应用案例：</p><ul><li>set排序 存储班级成绩表 工资表排序！</li><li>普通消息，1.重要消息 2.带权重进行判断</li><li>排行榜应用实现，取Top N测试</li></ul><h2 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h2><h3 id="Geospatial-地理位置"><a href="#Geospatial-地理位置" class="headerlink" title="Geospatial(地理位置)"></a>Geospatial(地理位置)</h3><blockquote><p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以zset命令也可以使用</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>geoadd key longitud(经度) latitude(纬度) member [..]</code></td><td>将具体经纬度的坐标存入一个有序集合</td></tr><tr><td><code>geopos key member [member..]</code></td><td>获取集合中的一个/多个成员坐标</td></tr><tr><td><code>geodist key member1 member2 [unit]</code></td><td>返回两个给定位置之间的距离。默认以米作为单位。</td></tr><tr><td>`georadius key longitude latitude radius m</td><td>km</td></tr><tr><td><code>GEORADIUSBYMEMBER key member radius...</code></td><td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td></tr><tr><td><code>geohash key member1 [member2..]</code></td><td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td></tr></tbody></table><p><strong>有效经纬度</strong></p><blockquote><ul><li>有效的经度从-180度到180度。</li><li>有效的纬度从-85.05112878度到85.05112878度。</li></ul></blockquote><p>指定单位的参数 <strong>unit</strong> 必须是以下单位的其中一个：</p><ul><li><strong>m</strong> 表示单位为米。</li><li><strong>km</strong> 表示单位为千米。</li><li><strong>mi</strong> 表示单位为英里。</li><li><strong>ft</strong> 表示单位为英尺。</li></ul><p><strong>关于GEORADIUS的参数</strong></p><blockquote><p>通过<code>georadius</code>就可以完成 <strong>附近的人</strong>功能</p><p>withcoord:带上坐标</p><p>withdist:带上距离，单位与半径单位相同</p><p>COUNT n : 只显示前n个(按距离递增排序)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----------------georadius---------------------</span><br><span class="line">127.0.0.1:6379&gt; GEORADIUS china:city 120 30 500 km withcoord withdist <span class="comment"># 查询经纬度(120,30)坐标500km半径内的成员</span></span><br><span class="line">1) 1) <span class="string">"hangzhou"</span></span><br><span class="line">   2) <span class="string">"29.4151"</span></span><br><span class="line">   3) 1) <span class="string">"120.20000249147415"</span></span><br><span class="line">      2) <span class="string">"30.199999888333501"</span></span><br><span class="line">2) 1) <span class="string">"shanghai"</span></span><br><span class="line">   2) <span class="string">"205.3611"</span></span><br><span class="line">   3) 1) <span class="string">"121.40000134706497"</span></span><br><span class="line">      2) <span class="string">"31.400000253193539"</span></span><br><span class="line">     </span><br><span class="line">------------geohash---------------------------</span><br><span class="line">127.0.0.1:6379&gt; geohash china:city yichang shanghai <span class="comment"># 获取成员经纬坐标的geohash表示</span></span><br><span class="line">1) <span class="string">"wmrjwbr5250"</span></span><br><span class="line">2) <span class="string">"wtw6ds0y300"</span></span><br></pre></td></tr></table></figure><h3 id="Hyperloglog-基数统计"><a href="#Hyperloglog-基数统计" class="headerlink" title="Hyperloglog(基数统计)"></a>Hyperloglog(基数统计)</h3><blockquote><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。</p><p>因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>其底层使用string数据类型</p></blockquote><p><strong>什么是基数？</strong></p><blockquote><p>数据集中不重复的元素的个数。</p></blockquote><p><strong>应用场景：</strong></p><p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p><blockquote><p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的目的只是<strong>计数</strong>，Hyperloglog就能帮助我们利用最小的空间完成。</p></blockquote><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>PFADD key element1 [elememt2..]</code></td><td>添加指定元素到 HyperLogLog 中</td></tr><tr><td><code>PFCOUNT key [key]</code></td><td>返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td><code>PFMERGE destkey sourcekey [sourcekey..]</code></td><td>将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">----------PFADD--PFCOUNT---------------------</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemx a b c d e f g h i j k <span class="comment"># 添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> myelemx <span class="comment"># hyperloglog底层使用String</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemx <span class="comment"># 估算myelemx的基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; PFADD myelemy i j k z m c b v p q s</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemy</span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line"></span><br><span class="line">----------------PFMERGE-----------------------</span><br><span class="line">127.0.0.1:6379&gt; PFMERGE myelemz myelemx myelemy <span class="comment"># 合并myelemx和myelemy 成为myelemz</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; PFCOUNT myelemz <span class="comment"># 估算基数</span></span><br><span class="line">(<span class="built_in">integer</span>) 17</span><br></pre></td></tr></table></figure><p>如果允许容错，那么一定可以使用Hyperloglog !</p><p>如果不允许容错，就使用set或者自己的数据类型即可 ！</p><h3 id="BitMaps-位图"><a href="#BitMaps-位图" class="headerlink" title="BitMaps(位图)"></a>BitMaps(位图)</h3><blockquote><p>使用位存储，信息状态只有 0 和 1</p><p>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p></blockquote><p><strong>应用场景</strong></p><p>签到统计、状态统计</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>setbit key offset value</code></td><td>为指定key的offset位设置值</td></tr><tr><td><code>getbit key offset</code></td><td>获取offset位的值</td></tr><tr><td><code>bitcount key [start end]</code></td><td>统计字符串被设置为1的bit数，也可以指定统计范围按字节</td></tr><tr><td><code>bitop operration destkey key[key..]</code></td><td>对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。</td></tr><tr><td><code>BITPOS key bit [start] [end]</code></td><td>返回字符串里面第一个被设置为1或者0的bit位。start和end只能按字节,不能按位</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">------------setbit--getbit--------------</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1 <span class="comment"># 设置sign的第0位为 1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1 <span class="comment"># 设置sign的第2位为 1  不设置默认 是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> sign</span><br><span class="line">string</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2 <span class="comment"># 获取第2位的数值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4 <span class="comment"># 未设置默认是0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br><span class="line">-----------bitcount----------------------------</span><br><span class="line">127.0.0.1:6379&gt; BITCOUNT sign <span class="comment"># 统计sign中为1的位数</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br></pre></td></tr></table></figure><p><strong>bitmaps的底层</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PlszjhS-1597890996519)(D:\我\MyBlog\狂神说 Redis.assets\image-20200803234336175.png)]</p><p>这样设置以后你能get到的值是：<strong>\xA2\x80</strong>，所以bitmaps是一串从左到右的二进制串</p><h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><p>Redis的单条命令是保证原子性的，但是redis事务不能保证原子性</p><blockquote><p>Redis事务本质：一组命令的集合。</p><p>—————– 队列 set set set 执行 ——————-</p><p>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p><ul><li>一次性</li><li>顺序性</li><li>排他性</li></ul><hr><ol><li>Redis事务没有隔离级别的概念</li><li>Redis单条命令是保证原子性的，但是事务不保证原子性！</li></ol></blockquote><h3 id="Redis事务操作过程"><a href="#Redis事务操作过程" class="headerlink" title="Redis事务操作过程"></a>Redis事务操作过程</h3><ul><li>开启事务（<code>multi</code>）</li><li>命令入队</li><li>执行事务（<code>exec</code>）</li></ul><p>所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1 <span class="comment"># 命令入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2 <span class="comment"># ..</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 事务执行</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">"v1"</span></span><br><span class="line">4) OK</span><br><span class="line">5) 1) <span class="string">"k3"</span></span><br><span class="line">   2) <span class="string">"k2"</span></span><br><span class="line">   3) <span class="string">"k1"</span></span><br></pre></td></tr></table></figure><p><strong>取消事务(<code>discurd</code>)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; DISCARD <span class="comment"># 放弃事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; EXEC </span><br><span class="line">(error) ERR EXEC without MULTI <span class="comment"># 当前未开启事务</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 <span class="comment"># 被放弃事务中命令并未执行</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h3 id="事务错误"><a href="#事务错误" class="headerlink" title="事务错误"></a>事务错误</h3><blockquote><p>代码语法错误（编译时异常）所有的命令都不执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; error k1 <span class="comment"># 这是一条语法错误命令</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `error`, with args beginning with: `k1`, <span class="comment"># 会报错但是不影响后续命令入队 </span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; EXEC</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors. <span class="comment"># 执行报错</span></span><br><span class="line">127.0.0.1:6379&gt; get k1 </span><br><span class="line">(nil) <span class="comment"># 其他命令并没有被执行</span></span><br></pre></td></tr></table></figure><blockquote><p>代码逻辑错误 (运行时异常) *<em>其他命令可以正常执行 *</em> &gt;&gt;&gt; 所以不保证事务原子性</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCR k1 <span class="comment"># 这条命令逻辑错误（对字符串进行增量）</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) (error) ERR value is not an <span class="built_in">integer</span> or out of range <span class="comment"># 运行时报错</span></span><br><span class="line">4) <span class="string">"v2"</span> <span class="comment"># 其他命令正常执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然中间有一条命令报错了，但是后面的指令依旧正常执行成功了。</span></span><br><span class="line"><span class="comment"># 所以说Redis单条指令保证原子性，但是Redis事务不能保证原子性。</span></span><br></pre></td></tr></table></figure><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为什么时候都会出现问题，无论做什么都会加锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据</li><li>获取version</li><li>更新的时候比较version</li></ul><p>使用<code>watch key</code>监控指定数据，相当于乐观锁加锁。</p><blockquote><p>正常执行</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100 <span class="comment"># 设置余额:100</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> use 0 <span class="comment"># 支出使用:0</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money (上锁)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">exec</span> <span class="comment"># 监视值没有被中途修改，事务正常执行</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80</span><br><span class="line">2) (<span class="built_in">integer</span>) 20</span><br></pre></td></tr></table></figure><blockquote><p>测试多线程修改值，使用watch可以当做redis的乐观锁操作（相当于getversion）</p></blockquote><p>我们启动另外一个客户端模拟插队线程。</p><p>线程1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># money上锁</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; DECRBY money 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; INCRBY use 20</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; <span class="comment"># 此时事务并没有执行</span></span><br></pre></td></tr></table></figure><p>模拟线程插队，线程2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INCRBY money 500 <span class="comment"># 修改了线程一中监视的money</span></span><br><span class="line">(<span class="built_in">integer</span>) 600</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>回到线程1，执行事务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXEC <span class="comment"># 执行之前，另一个线程修改了我们的值，这个时候就会导致事务执行失败</span></span><br><span class="line">(nil) <span class="comment"># 没有结果，说明事务执行失败</span></span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get money <span class="comment"># 线程2 修改生效</span></span><br><span class="line"><span class="string">"600"</span></span><br><span class="line">127.0.0.1:6379&gt; get use <span class="comment"># 线程1事务执行失败，数值没有被修改</span></span><br><span class="line"><span class="string">"0"</span></span><br></pre></td></tr></table></figure><blockquote><p>解锁获取最新值，然后再加锁进行事务。</p><p><code>unwatch</code>进行解锁。</p></blockquote><p>注意：每次提交执行exec后都会自动释放锁，不管是否成功</p><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><p>SpringBoot 操作数据:spring-data jpa jdbc mongodb redis!<br>SpringData 也是和 SpringBoot 齐名的项目!<br>说明: 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?<br>jedis : 采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用 jedis pool 连接 池! 更像 BIO 模式<br>lettuce : 采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况!可以减少线程数据 了，更像 NIO 模式<br>源码分析:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"redisTemplate"</span>) <span class="comment">// 我们可以自己定义一个 redisTemplate来替换这个默认的!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line"><span class="comment">// 默认的 RedisTemplate 没有过多的设置，redis 对象都是需要序列化!</span></span><br><span class="line"><span class="comment">// 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 &lt;String, Object&gt; RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;(); template.setConnectionFactory(redisConnectionFactory);</span></span><br><span class="line"><span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// 由于 String 是redis中最常使用的类型，所以说单独提出来了一 个bean!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合：</p><ol><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 配置redis </span><br><span class="line">spring.redis.host&#x3D;127.0.0.1 </span><br><span class="line">spring.redis.port&#x3D;6379</span><br></pre></td></tr></table></figure></li><li>测试!<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redis02SpringbootApplicationTests</span> </span>&#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// redisTemplate 操作不同的数据类型，api和我们的指令是一样的</span></span><br><span class="line"><span class="comment">// opsForValue 操作字符串 类似String</span></span><br><span class="line"><span class="comment">// opsForList 操作List 类似List // opsForSet</span></span><br><span class="line"><span class="comment">// opsForHash</span></span><br><span class="line"><span class="comment">// opsForZSet</span></span><br><span class="line"><span class="comment">// opsForGeo</span></span><br><span class="line"><span class="comment">// opsForHyperLogLog</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">//CRUD</span></span><br><span class="line"><span class="comment">//除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的</span></span><br><span class="line"><span class="comment">//获取redis的连接对象</span></span><br><span class="line"><span class="comment">//RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line"><span class="comment">// connection.flushDb();</span></span><br><span class="line"><span class="comment">// connection.flushAll();</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"mykey"</span>,<span class="string">"关注狂神说公众号"</span>); </span><br><span class="line">System.out.println(redisTemplate.opsForValue().get(<span class="string">"mykey"</span>));</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/20210124135025661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>关于对象的保存:所有的对象需要序列化<br><img src="https://img-blog.csdnimg.cn/20210124135106502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>编写自己的RedisTemplate：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"><span class="comment">// 这是我给大家写好的一个固定模板，大家在企业中，拿去就可以直接使用! // 自己定义了一个 RedisTemplate</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"all"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory</span></span></span><br><span class="line"><span class="function"><span class="params">factory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt;</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String,</span><br><span class="line">Object&gt;();</span><br><span class="line">template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">// Json序列化配置</span></span><br><span class="line">Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); </span><br><span class="line">om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// String 的序列化</span></span><br><span class="line">StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span></span><br><span class="line">StringRedisSerializer();</span><br><span class="line"><span class="comment">// key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer);</span></span><br><span class="line"><span class="comment">// hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer);</span></span><br><span class="line"><span class="comment">// value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer);</span></span><br><span class="line"><span class="comment">// hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet();</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Redis-conf"><a href="#Redis-conf" class="headerlink" title="Redis.conf"></a>Redis.conf</h2><blockquote><p>容量单位不区分大小写，G和GB有区别<br><img src="https://img-blog.csdnimg.cn/20210124135434997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以使用 include 组合多个配置问题<br><img src="https://img-blog.csdnimg.cn/20210124135450341.png" alt="在这里插入图片描述"><br>网络配置<br><img src="https://img-blog.csdnimg.cn/20210124135512211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>日志输出级别<br><img src="https://img-blog.csdnimg.cn/20210124135532626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通用CENERAL</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes # 以守护进程的方式运行，默认是 no，我们需要自己开启为yes!</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid # 如果以后台的方式运行，我们就需要指定一个 pid 文件!</span><br><span class="line"># 日志</span><br><span class="line"># Specify the server verbosity level. # This can be one of:</span><br><span class="line"># debug (a lot of information, useful for development&#x2F;testing)</span><br><span class="line"># verbose (many rarely useful info, but not a mess like the debug level)</span><br><span class="line"># notice (moderately verbose, what you want in production probably) 生产环境 # warning (only very important &#x2F; critical messages are logged)</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;&quot; # 日志的文件位置名</span><br><span class="line">databases 16 # 数据库的数量，默认是 16 个数据库</span><br><span class="line">always-show-logo yes # 是否总是显示LOGO</span><br></pre></td></tr></table></figure><p>快照:</p><p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件 .rdb. aof redis 是内存数据库，如果没有持久化，那么数据断电及失!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 如果900s内，如果至少有一个1 key进行了修改，我们及进行持久化操作 </span><br><span class="line">save 900 1</span><br><span class="line"># 如果300s内，如果至少10 key进行了修改，我们及进行持久化操作 </span><br><span class="line">save 300 10</span><br><span class="line"># 如果60s内，如果至少10000 key进行了修改，我们及进行持久化操作 </span><br><span class="line">save 60 10000</span><br><span class="line"># 我们之后学习持久化，会自己定义这个测试!</span><br><span class="line">stop-writes-on-bgsave-error yes </span><br><span class="line"># 持久化如果出错，是否还需要继续工作!</span><br><span class="line"> rdbcompression yes </span><br><span class="line"># 是否压缩 rdb 文件，需要消耗一些cpu资源!</span><br><span class="line">  rdbchecksum yes</span><br><span class="line"># 保存rdb文件的时候，进行错误的检查校验!</span><br><span class="line">dir .&#x2F;     # rdb 文件保存的目录!</span><br></pre></td></tr></table></figure><p>SECURITY 安全:<br>可以在这里设置redis的密码，默认是没有密码!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass # 获取redis的密码</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; config set requirepass &quot;123456&quot; # 设置redis的密码 OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass # 发现所有的命令都没有权限了 (error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456 # 使用密码进行登录!</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;123456&quot;</span><br></pre></td></tr></table></figure><p>限制 CLIENTS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000 # 设置能连接上redis的最大客户端的数量</span><br><span class="line">maxmemory &lt;bytes&gt; # redis 配置最大的内存容量</span><br><span class="line">maxmemory-policy noeviction # 内存到达上限之后的处理策略 </span><br><span class="line">1、volatile-lru:只对设置了过期时间的key进行LRU(默认值) </span><br><span class="line">2、allkeys-lru : 删除lru算法的key </span><br><span class="line">3、volatile-random:随机删除即将过期key </span><br><span class="line">4、allkeys-random:随机删除</span><br><span class="line">5、volatile-ttl : 删除即将过期的 </span><br><span class="line">6、noeviction : 永不过期，返回错误</span><br></pre></td></tr></table></figure><p>APPEND ONLY 模式 aof配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">appendonly no # 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分所有的情况下， rdb完全够用!</span><br><span class="line">appendfilename &quot;appendonly.aof&quot; # 持久化的文件的名字</span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"># 每次修改都会 sync。消耗性能</span><br><span class="line"># 每秒执行一次 sync，可能会丢失这1s的数据!</span><br><span class="line"># 不执行 sync，这个时候操作系统自己同步数据，速度最快!</span><br></pre></td></tr></table></figure><h2 id="持久化—RDB"><a href="#持久化—RDB" class="headerlink" title="持久化—RDB"></a>持久化—RDB</h2><p>RDB：Redis Databases</p><p>持久化规则<br>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中</p><p>持久化方式：</p><ul><li>RDB</li><li>AOF</li></ul><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><p>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；<br><img src="https://img-blog.csdnimg.cn/20210124140255237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>默认情况下， Redis 将数据库快照保存在名字为 dump.rdb的二进制文件中。文件名可以在配置文件中进行自定义。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><hr><p>在进行 <strong><code>RDB</code></strong> 的时候，<strong><code>redis</code></strong> 的主线程是不会做 <strong><code>io</code></strong> 操作的，主线程会 <strong><code>fork</code></strong> 一个子线程来完成该操作；</p><ol><li>Redis 调用forks。同时拥有父进程和子进程。</li><li>子进程将数据集写入到一个临时 RDB 文件中。</li><li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li></ol><p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)<br><img src="https://img-blog.csdnimg.cn/20210124140426860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h3><hr><ol><li>save的规则满足的情况下，会自动触发rdb原则</li><li>执行flushall命令，也会触发我们的rdb原则</li><li>退出redis，也会自动产生rdb文件</li></ol><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><p>使用 <code>save</code> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p><blockquote><p>由于 <code>save</code> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，<code>save</code>命令执行速度会非常慢，阻塞所有客户端的请求。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20210124140533225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><p><code>flushall</code> 命令也会触发持久化 ；</p><h4 id="触发持久化规则"><a href="#触发持久化规则" class="headerlink" title="触发持久化规则"></a>触发持久化规则</h4><p>满足配置条件中的触发条件 ；</p><blockquote><p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。<br><img src="https://img-blog.csdnimg.cn/20210124140607446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210124140623863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h4 id="bgsave"><a href="#bgsave" class="headerlink" title="bgsave"></a>bgsave</h4><p><code>bgsave</code> 是异步进行，进行持久化的时候，<code>redis</code> 还可以将继续响应客户端请求 ；<br><img src="https://img-blog.csdnimg.cn/20210124140645467.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>bgsave和save对比</strong></p><table><thead><tr><th>命令</th><th>save</th><th>bgsave</th></tr></thead><tbody><tr><td>IO类型</td><td>同步</td><td>异步</td></tr><tr><td>阻塞？</td><td>是</td><td>是（阻塞发生在fock()，通常非常快）</td></tr><tr><td>复杂度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>优点</td><td>不会消耗额外的内存</td><td>不阻塞客户端命令</td></tr><tr><td>缺点</td><td>阻塞客户端命令</td><td>需要fock子进程，消耗内存</td></tr></tbody></table><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ol><li>适合大规模的数据恢复</li><li>对数据的完整性要求不高</li></ol><p><strong>缺点：</strong></p><ol><li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li><li>fork进程的时候，会占用一定的内容空间。</li></ol><h2 id="十一、持久化AOF"><a href="#十一、持久化AOF" class="headerlink" title="十一、持久化AOF"></a>十一、持久化AOF</h2><p><strong>Append Only File</strong></p><p>将我们所有的命令都记录下来，history，恢复的时候就把这个文件全部再执行一遍</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Z8wr9lBW-1597890996525)(狂神说 Redis.assets/image-20200818123711375.png)]</p><blockquote><p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p></blockquote><h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p> 快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p><p>如果要使用AOF，需要修改配置文件：<br><img src="https://img-blog.csdnimg.cn/20210124140719611.png" alt="在这里插入图片描述"><br><code>appendonly no yes</code>则表示启用AOF</p><p>默认是不开启的，我们需要手动配置，然后重启redis，就可以生效了！</p><p>如果这个aof文件有错位，这时候redis是启动不起来的，我需要修改这个aof文件</p><p>redis给我们提供了一个工具<code>redis-check-aof --fix</code></p><blockquote><p>优点和缺点</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes  <span class="comment"># 默认是不开启aof模式的，默认是使用rdb方式持久化的，在大部分的情况下，rdb完全够用</span></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always # 每次修改都会sync 消耗性能</span></span><br><span class="line">appendfsync everysec <span class="comment"># 每秒执行一次 sync 可能会丢失这一秒的数据</span></span><br><span class="line"><span class="comment"># appendfsync no # 不执行 sync ,这时候操作系统自己同步数据，速度最快</span></span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><ol><li>每一次修改都会同步，文件的完整性会更加好</li><li>没秒同步一次，可能会丢失一秒的数据</li><li>从不同步，效率最高</li></ol><p><strong>缺点</strong></p><ol><li>相对于数据文件来说，aof远远大于rdb，修复速度比rdb慢！</li><li>Aof运行效率也要比rdb慢，所以我们redis默认的配置就是rdb持久化</li></ol><h2 id="十二、RDB和AOP选择"><a href="#十二、RDB和AOP选择" class="headerlink" title="十二、RDB和AOP选择"></a>十二、RDB和AOP选择</h2><h3 id="RDB-和-AOF-对比"><a href="#RDB-和-AOF-对比" class="headerlink" title="RDB 和 AOF 对比"></a>RDB 和 AOF 对比</h3><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr></tbody></table><h3 id="如何选择使用哪种持久化方式？"><a href="#如何选择使用哪种持久化方式？" class="headerlink" title="如何选择使用哪种持久化方式？"></a>如何选择使用哪种持久化方式？</h3><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p><p>如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p><h2 id="十三、Redis发布与订阅"><a href="#十三、Redis发布与订阅" class="headerlink" title="十三、Redis发布与订阅"></a>十三、Redis发布与订阅</h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p><img src="https://img-blog.csdnimg.cn/20210124140904442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的 关系:<br><img src="https://img-blog.csdnimg.cn/20210124140944765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户 端:<br><img src="https://img-blog.csdnimg.cn/20210124141016130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt=""><br>命令：<br>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等。<br><img src="https://img-blog.csdnimg.cn/20210124141049171.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>测试：<br>订阅端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE kuangshenshuo # 订阅一个频道 kuangshenshuo Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;kuangshenshuo&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"># 等待读取推送的信息</span><br><span class="line">1) &quot;message&quot; # 消息</span><br><span class="line">2) &quot;kuangshenshuo&quot; # 那个频道的消息 3) &quot;hello,kuangshen&quot; # 消息的具体内容</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;kuangshenshuo&quot;</span><br><span class="line">3) &quot;hello,redis&quot;</span><br></pre></td></tr></table></figure><p>发送端:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH kuangshenshuo &quot;hello,kuangshen&quot; # 发布者发布消息到频道! (integer) 1</span><br><span class="line">127.0.0.1:6379&gt; PUBLISH kuangshenshuo &quot;hello,redis&quot; # 发布者发布消息到频道! (integer) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>原理:<br>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍 此加深对 Redis 的理解。<br>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。<br>微信:<br>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道!， 而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键， 就是将客户端添加到给定 channel 的订阅链表中。<br><img src="https://img-blog.csdnimg.cn/20210124141242791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel 字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。<br><img src="https://img-blog.csdnimg.cn/20210124141419910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt=""><br>Pub/Sub 从字面上理解就是发布(Publish)与订阅(Subscribe)，在Redis中，你可以设定对某一个 key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应 的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。<br>使用场景:<br>1、实时消息系统!<br>2、事实聊天!(频道当做聊天室，将信息回显给所有人即可!)<br>3、订阅，关注系统都是可以的!<br>稍微复杂的场景我们就会使用 消息中间件 MQ ()</p><h2 id="十四、Redis主从复制"><a href="#十四、Redis主从复制" class="headerlink" title="十四、Redis主从复制"></a>十四、Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。</p><p>默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。</li><li>故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式</li><li>负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。</li><li>高可用基石：主从复制还是哨兵和集群能够实施的基础。</li></ol><h3 id="为什么使用集群"><a href="#为什么使用集群" class="headerlink" title="为什么使用集群"></a>为什么使用集群</h3><ol><li>单台服务器难以负载大量的请求</li><li>单台服务器故障率高，系统崩坏概率大</li><li>单台服务器内存容量有限。</li></ol><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>我们在讲解配置文件的时候，注意到有一个<code>replication</code>模块 (见Redis.conf中第8条)</p><p>查看当前库的信息：<code>info replication</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master <span class="comment"># 角色</span></span><br><span class="line">connected_slaves:0 <span class="comment"># 从机数量</span></span><br><span class="line">master_replid:3b54deef5b7b7b7f7dd8acefa23be48879b4fcff</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure><p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p><ul><li>端口号</li><li>pid文件名</li><li>日志文件名</li><li>rdb文件名</li></ul><p>启动单机多服务集群：<br><img src="https://img-blog.csdnimg.cn/20210124141550717.png" alt="在这里插入图片描述"></p><h3 id="一主二从配置"><a href="#一主二从配置" class="headerlink" title="一主二从配置"></a>一主二从配置</h3><p>==默认情况下，每台Redis服务器都是主节点；==我们一般情况下只用配置从机就好了！</p><p>认老大！一主（79）二从（80，81）</p><p>使用<code>SLAVEOF host port</code>就可以为从机配置主机了。<br><img src="https://img-blog.csdnimg.cn/20210124141617285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后主机上也能看到从机的状态：<br><img src="https://img-blog.csdnimg.cn/20210124141634331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们这里是使用命令搭建，是暂时的，==真实开发中应该在从机的配置文件中进行配置，==这样的话是永久的。<br><img src="https://img-blog.csdnimg.cn/20210124141657721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><ol><li><p>从机只能读，不能写，主机可读可写但是多用于写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6381&gt; <span class="built_in">set</span> name sakura <span class="comment"># 从机6381写入失败</span></span><br><span class="line">(error) READONLY You can<span class="string">'t write against a read only replica.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">127.0.0.1:6380&gt; set name sakura # 从机6380写入失败</span></span><br><span class="line"><span class="string">(error) READONLY You can'</span>t write against a <span class="built_in">read</span> only replica.</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name sakura</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">"sakura"</span></span><br></pre></td></tr></table></figure></li><li><p>当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p></li><li><p>当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p></li><li><p>第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p><ul><li>从机手动执行命令<code>slaveof no one</code>,这样执行以后从机会独立出来成为一个主机</li><li>使用哨兵模式（自动选举）</li></ul></li></ol><blockquote><p>如果没有老大了，这个时候能不能选择出来一个老大呢？手动！</p></blockquote><p>如果主机断开了连接，我们可以使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的主节点（手动）！如果这个时候老大修复了，那么久重新连接！</p><h2 id="十五、哨兵模式"><a href="#十五、哨兵模式" class="headerlink" title="十五、哨兵模式"></a>十五、哨兵模式</h2><p>(自动选举老大的模式)</p><p>更多信息参考博客：<a href="https://www.jianshu.com/p/06ab9daf921d" target="_blank" rel="noopener">https://www.jianshu.com/p/06ab9daf921d</a></p><p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。</strong>这不是一种推荐的方式，更多时候，我们优先考虑<strong>哨兵模式</strong>。</p><p>概述:<br>主从切换技术的方法是:当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工 干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑 哨兵模式。Redis从2.8开始正式提供了Sentinel(哨兵) 架构来解决这个问题。<br>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。 哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独<br>立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。<br><img src="https://img-blog.csdnimg.cn/20210124141957325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里的哨兵有两个作用</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。 </li><li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服 务器，修改配置文件，让它们切换主机。</li></ul><p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。 各个哨兵之间还会进行监控，这样就形成了多哨兵模式。<br><img src="https://img-blog.csdnimg.cn/20210124142056745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认 为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一 定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。 切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为 客观下线。<br>测试!<br>我们目前的状态是 一主二从! 1、配置哨兵配置文件 sentinel.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sentinel monitor 被监控的名称 host port 1 </span><br><span class="line">sentinel monitor myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p> 后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机!</p><p> 2、启动哨兵!<br> <img src="https://img-blog.csdnimg.cn/20210124142300348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20210124142312270.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器! (这里面有一个投票算法!)<br><img src="https://img-blog.csdnimg.cn/20210124142333889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>哨兵日志!<br><img src="https://img-blog.csdnimg.cn/20210124142353788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt=""><br>如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则!</p><p>哨兵模式:<br>优点:<br>1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有<br>2、 主从可以切换，故障可以转移，系统的可用性就会更好<br>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮!<br>缺点:<br>1、Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦! 2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择!</p><p>哨兵模式的全部配置!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf</span><br><span class="line"> </span><br><span class="line"># 哨兵sentinel实例运行的端口 默认26379</span><br><span class="line">port 26379</span><br><span class="line"> </span><br><span class="line"># 哨兵sentinel的工作目录</span><br><span class="line">dir &#x2F;tmp</span><br><span class="line"> </span><br><span class="line"># 哨兵sentinel监控的redis主节点的 ip port </span><br><span class="line"># master-name  可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成。</span><br><span class="line"># quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了</span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br><span class="line"> </span><br><span class="line"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span><br><span class="line"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"> </span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，</span><br><span class="line">这个数字越小，完成failover所需的时间就越长，</span><br><span class="line">但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span><br><span class="line">可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span><br><span class="line">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span><br><span class="line">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</span><br><span class="line">#3.当想要取消一个正在进行的failover所需要的时间。  </span><br><span class="line">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span><br><span class="line"># 默认三分钟</span><br><span class="line"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"> </span><br><span class="line"># SCRIPTS EXECUTION</span><br><span class="line"> </span><br><span class="line">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。</span><br><span class="line">#对于脚本的运行结果有以下规则：</span><br><span class="line">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span><br><span class="line">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span><br><span class="line">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span><br><span class="line">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span><br><span class="line"> </span><br><span class="line">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，</span><br><span class="line">#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，</span><br><span class="line">#一个是事件的类型，</span><br><span class="line">#一个是事件的描述。</span><br><span class="line">#如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</span><br><span class="line">#通知脚本</span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">  sentinel notification-script mymaster &#x2F;var&#x2F;redis&#x2F;notify.sh</span><br><span class="line"> </span><br><span class="line"># 客户端重新配置主节点参数脚本</span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="line"># 以下参数将会在调用脚本时传给脚本:</span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="line"># 目前&lt;state&gt;总是“failover”,</span><br><span class="line"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><br><span class="line"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通信的</span><br><span class="line"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="line">sentinel client-reconfig-script mymaster &#x2F;var&#x2F;redis&#x2F;reconfig.sh</span><br></pre></td></tr></table></figure><h2 id="十六、缓存穿透与雪崩"><a href="#十六、缓存穿透与雪崩" class="headerlink" title="十六、缓存穿透与雪崩"></a>十六、缓存穿透与雪崩</h2><h3 id="缓存穿透（查不到）"><a href="#缓存穿透（查不到）" class="headerlink" title="缓存穿透（查不到）"></a>缓存穿透（查不到）</h3><blockquote><p>概念</p></blockquote><p>在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p><blockquote><p>解决方案</p></blockquote><p><strong>布隆过滤器</strong></p><p>对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。<br><img src="https://img-blog.csdnimg.cn/20210124143010474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>缓存空对象</strong></p><p>一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。<br><img src="https://img-blog.csdnimg.cn/20210124143032543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是设置较短过期时间</p><p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p><h3 id="缓存击穿（量太大，缓存过期）"><a href="#缓存击穿（量太大，缓存过期）" class="headerlink" title="缓存击穿（量太大，缓存过期）"></a>缓存击穿（量太大，缓存过期）</h3><blockquote><p>概念</p></blockquote><p> 相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p><p> 比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p><blockquote><p>解决方案</p></blockquote><ol><li><p><strong>设置热点数据永不过期</strong></p><p>这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p></li><li><p><strong>加互斥锁(分布式锁)</strong></p><p>在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p></li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><blockquote><p>概念</p></blockquote><p>大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。<br><img src="https://img-blog.csdnimg.cn/2021012414305256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BvcG9mems=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>解决方案</p></blockquote><ul><li><p>redis高可用</p><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群</p></li><li><p>限流降级</p><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p></li><li><p>数据预热</p><p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Nosql概述&quot;&gt;&lt;a href=&quot;#一、Nosql概述&quot; class=&quot;headerlink&quot; title=&quot;一、Nosql概述&quot;&gt;&lt;/a&gt;一、Nosql概述&lt;/h2&gt;&lt;h3 id=&quot;为什么使用Nosql&quot;&gt;&lt;a href=&quot;#为什么使用Nosql&quot; cla</summary>
      
    
    
    
    <category term="技术栈" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
    
    <category term="Redis" scheme="https://ericzikun.github.io/categories/%E6%8A%80%E6%9C%AF%E6%A0%88/Redis/"/>
    
    
    <category term="数据库" scheme="https://ericzikun.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Springboot" scheme="https://ericzikun.github.io/tags/Springboot/"/>
    
    <category term="Redis" scheme="https://ericzikun.github.io/tags/Redis/"/>
    
    <category term="java" scheme="https://ericzikun.github.io/tags/java/"/>
    
  </entry>
  
</feed>
